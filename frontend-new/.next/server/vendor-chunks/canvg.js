"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvg";
exports.ids = ["vendor-chunks/canvg"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvg/lib/index.es.js":
/*!********************************************!*\
  !*** ./node_modules/canvg/lib/index.es.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AElement: () => (/* binding */ AElement),\n/* harmony export */   AnimateColorElement: () => (/* binding */ AnimateColorElement),\n/* harmony export */   AnimateElement: () => (/* binding */ AnimateElement),\n/* harmony export */   AnimateTransformElement: () => (/* binding */ AnimateTransformElement),\n/* harmony export */   BoundingBox: () => (/* binding */ BoundingBox),\n/* harmony export */   CB1: () => (/* binding */ CB1),\n/* harmony export */   CB2: () => (/* binding */ CB2),\n/* harmony export */   CB3: () => (/* binding */ CB3),\n/* harmony export */   CB4: () => (/* binding */ CB4),\n/* harmony export */   Canvg: () => (/* binding */ Canvg),\n/* harmony export */   CircleElement: () => (/* binding */ CircleElement),\n/* harmony export */   ClipPathElement: () => (/* binding */ ClipPathElement),\n/* harmony export */   DefsElement: () => (/* binding */ DefsElement),\n/* harmony export */   DescElement: () => (/* binding */ DescElement),\n/* harmony export */   Document: () => (/* binding */ Document),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   EllipseElement: () => (/* binding */ EllipseElement),\n/* harmony export */   FeColorMatrixElement: () => (/* binding */ FeColorMatrixElement),\n/* harmony export */   FeCompositeElement: () => (/* binding */ FeCompositeElement),\n/* harmony export */   FeDropShadowElement: () => (/* binding */ FeDropShadowElement),\n/* harmony export */   FeGaussianBlurElement: () => (/* binding */ FeGaussianBlurElement),\n/* harmony export */   FeMorphologyElement: () => (/* binding */ FeMorphologyElement),\n/* harmony export */   FilterElement: () => (/* binding */ FilterElement),\n/* harmony export */   Font: () => (/* binding */ Font),\n/* harmony export */   FontElement: () => (/* binding */ FontElement),\n/* harmony export */   FontFaceElement: () => (/* binding */ FontFaceElement),\n/* harmony export */   GElement: () => (/* binding */ GElement),\n/* harmony export */   GlyphElement: () => (/* binding */ GlyphElement),\n/* harmony export */   GradientElement: () => (/* binding */ GradientElement),\n/* harmony export */   ImageElement: () => (/* binding */ ImageElement),\n/* harmony export */   LineElement: () => (/* binding */ LineElement),\n/* harmony export */   LinearGradientElement: () => (/* binding */ LinearGradientElement),\n/* harmony export */   MarkerElement: () => (/* binding */ MarkerElement),\n/* harmony export */   MaskElement: () => (/* binding */ MaskElement),\n/* harmony export */   Matrix: () => (/* binding */ Matrix),\n/* harmony export */   MissingGlyphElement: () => (/* binding */ MissingGlyphElement),\n/* harmony export */   Mouse: () => (/* binding */ Mouse),\n/* harmony export */   PSEUDO_ZERO: () => (/* binding */ PSEUDO_ZERO),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   PathElement: () => (/* binding */ PathElement),\n/* harmony export */   PathParser: () => (/* binding */ PathParser),\n/* harmony export */   PatternElement: () => (/* binding */ PatternElement),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PolygonElement: () => (/* binding */ PolygonElement),\n/* harmony export */   PolylineElement: () => (/* binding */ PolylineElement),\n/* harmony export */   Property: () => (/* binding */ Property),\n/* harmony export */   QB1: () => (/* binding */ QB1),\n/* harmony export */   QB2: () => (/* binding */ QB2),\n/* harmony export */   QB3: () => (/* binding */ QB3),\n/* harmony export */   RadialGradientElement: () => (/* binding */ RadialGradientElement),\n/* harmony export */   RectElement: () => (/* binding */ RectElement),\n/* harmony export */   RenderedElement: () => (/* binding */ RenderedElement),\n/* harmony export */   Rotate: () => (/* binding */ Rotate),\n/* harmony export */   SVGElement: () => (/* binding */ SVGElement),\n/* harmony export */   SVGFontLoader: () => (/* binding */ SVGFontLoader),\n/* harmony export */   Scale: () => (/* binding */ Scale),\n/* harmony export */   Screen: () => (/* binding */ Screen),\n/* harmony export */   Skew: () => (/* binding */ Skew),\n/* harmony export */   SkewX: () => (/* binding */ SkewX),\n/* harmony export */   SkewY: () => (/* binding */ SkewY),\n/* harmony export */   StopElement: () => (/* binding */ StopElement),\n/* harmony export */   StyleElement: () => (/* binding */ StyleElement),\n/* harmony export */   SymbolElement: () => (/* binding */ SymbolElement),\n/* harmony export */   TRefElement: () => (/* binding */ TRefElement),\n/* harmony export */   TSpanElement: () => (/* binding */ TSpanElement),\n/* harmony export */   TextElement: () => (/* binding */ TextElement),\n/* harmony export */   TextPathElement: () => (/* binding */ TextPathElement),\n/* harmony export */   TitleElement: () => (/* binding */ TitleElement),\n/* harmony export */   Transform: () => (/* binding */ Transform),\n/* harmony export */   Translate: () => (/* binding */ Translate),\n/* harmony export */   UnknownElement: () => (/* binding */ UnknownElement),\n/* harmony export */   UseElement: () => (/* binding */ UseElement),\n/* harmony export */   ViewPort: () => (/* binding */ ViewPort),\n/* harmony export */   compressSpaces: () => (/* binding */ compressSpaces),\n/* harmony export */   \"default\": () => (/* binding */ Canvg),\n/* harmony export */   getSelectorSpecificity: () => (/* binding */ getSelectorSpecificity),\n/* harmony export */   normalizeAttributeName: () => (/* binding */ normalizeAttributeName),\n/* harmony export */   normalizeColor: () => (/* binding */ normalizeColor),\n/* harmony export */   parseExternalUrl: () => (/* binding */ parseExternalUrl),\n/* harmony export */   presets: () => (/* binding */ index),\n/* harmony export */   toNumbers: () => (/* binding */ toNumbers),\n/* harmony export */   trimLeft: () => (/* binding */ trimLeft),\n/* harmony export */   trimRight: () => (/* binding */ trimRight),\n/* harmony export */   vectorMagnitude: () => (/* binding */ vectorMagnitude),\n/* harmony export */   vectorsAngle: () => (/* binding */ vectorsAngle),\n/* harmony export */   vectorsRatio: () => (/* binding */ vectorsRatio)\n/* harmony export */ });\n/* harmony import */ var core_js_modules_es_promise_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! core-js/modules/es.promise.js */ \"(ssr)/./node_modules/core-js/modules/es.promise.js\");\n/* harmony import */ var _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/asyncToGenerator */ \"(ssr)/./node_modules/@babel/runtime/helpers/asyncToGenerator.js\");\n/* harmony import */ var core_js_modules_es_string_match_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! core-js/modules/es.string.match.js */ \"(ssr)/./node_modules/core-js/modules/es.string.match.js\");\n/* harmony import */ var core_js_modules_es_string_replace_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! core-js/modules/es.string.replace.js */ \"(ssr)/./node_modules/core-js/modules/es.string.replace.js\");\n/* harmony import */ var core_js_modules_es_string_starts_with_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! core-js/modules/es.string.starts-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.starts-with.js\");\n/* harmony import */ var core_js_modules_es_array_iterator_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! core-js/modules/es.array.iterator.js */ \"(ssr)/./node_modules/core-js/modules/es.array.iterator.js\");\n/* harmony import */ var core_js_modules_web_dom_collections_iterator_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! core-js/modules/web.dom-collections.iterator.js */ \"(ssr)/./node_modules/core-js/modules/web.dom-collections.iterator.js\");\n/* harmony import */ var _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @babel/runtime/helpers/defineProperty */ \"(ssr)/./node_modules/@babel/runtime/helpers/defineProperty.js\");\n/* harmony import */ var core_js_modules_es_array_reduce_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! core-js/modules/es.array.reduce.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reduce.js\");\n/* harmony import */ var core_js_modules_es_string_ends_with_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! core-js/modules/es.string.ends-with.js */ \"(ssr)/./node_modules/core-js/modules/es.string.ends-with.js\");\n/* harmony import */ var core_js_modules_es_string_split_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! core-js/modules/es.string.split.js */ \"(ssr)/./node_modules/core-js/modules/es.string.split.js\");\n/* harmony import */ var raf__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! raf */ \"(ssr)/./node_modules/raf/index.js\");\n/* harmony import */ var core_js_modules_es_string_trim_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! core-js/modules/es.string.trim.js */ \"(ssr)/./node_modules/core-js/modules/es.string.trim.js\");\n/* harmony import */ var rgbcolor__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! rgbcolor */ \"(ssr)/./node_modules/rgbcolor/index.js\");\n/* harmony import */ var core_js_modules_es_array_index_of_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! core-js/modules/es.array.index-of.js */ \"(ssr)/./node_modules/core-js/modules/es.array.index-of.js\");\n/* harmony import */ var core_js_modules_es_string_includes_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! core-js/modules/es.string.includes.js */ \"(ssr)/./node_modules/core-js/modules/es.string.includes.js\");\n/* harmony import */ var core_js_modules_es_array_reverse_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! core-js/modules/es.array.reverse.js */ \"(ssr)/./node_modules/core-js/modules/es.array.reverse.js\");\n/* harmony import */ var svg_pathdata__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! svg-pathdata */ \"(ssr)/./node_modules/svg-pathdata/lib/SVGPathData.module.js\");\n/* harmony import */ var core_js_modules_es_regexp_to_string_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! core-js/modules/es.regexp.to-string.js */ \"(ssr)/./node_modules/core-js/modules/es.regexp.to-string.js\");\n/* harmony import */ var stackblur_canvas__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! stackblur-canvas */ \"(ssr)/./node_modules/stackblur-canvas/dist/stackblur-es.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Options preset for `OffscreenCanvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @returns Preset object.\r\n */ function offscreen() {\n    var { DOMParser: DOMParserFallback } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var preset = {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParserFallback,\n        createCanvas (width, height) {\n            return new OffscreenCanvas(width, height);\n        },\n        createImage (url) {\n            return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n                var response = yield fetch(url);\n                var blob = yield response.blob();\n                var img = yield createImageBitmap(blob);\n                return img;\n            })();\n        }\n    };\n    if (typeof DOMParser !== \"undefined\" || typeof DOMParserFallback === \"undefined\") {\n        Reflect.deleteProperty(preset, \"DOMParser\");\n    }\n    return preset;\n}\n/**\r\n * Options preset for `node-canvas`.\r\n * @param config - Preset requirements.\r\n * @param config.DOMParser - XML/HTML parser from string into DOM Document.\r\n * @param config.canvas - `node-canvas` exports.\r\n * @param config.fetch - WHATWG-compatible `fetch` function.\r\n * @returns Preset object.\r\n */ function node(_ref) {\n    var { DOMParser: DOMParser1, canvas, fetch: fetch1 } = _ref;\n    return {\n        window: null,\n        ignoreAnimation: true,\n        ignoreMouse: true,\n        DOMParser: DOMParser1,\n        fetch: fetch1,\n        createCanvas: canvas.createCanvas,\n        createImage: canvas.loadImage\n    };\n}\nvar index = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    offscreen: offscreen,\n    node: node\n});\n/**\r\n * HTML-safe compress white-spaces.\r\n * @param str - String to compress.\r\n * @returns String.\r\n */ function compressSpaces(str) {\n    return str.replace(/(?!\\u3000)\\s+/gm, \" \");\n}\n/**\r\n * HTML-safe left trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimLeft(str) {\n    return str.replace(/^[\\n \\t]+/, \"\");\n}\n/**\r\n * HTML-safe right trim.\r\n * @param str - String to trim.\r\n * @returns String.\r\n */ function trimRight(str) {\n    return str.replace(/[\\n \\t]+$/, \"\");\n}\n/**\r\n * String to numbers array.\r\n * @param str - Numbers string.\r\n * @returns Numbers array.\r\n */ function toNumbers(str) {\n    var matches = (str || \"\").match(/-?(\\d+(?:\\.\\d*(?:[eE][+-]?\\d+)?)?|\\.\\d+)(?=\\D|$)/gm) || [];\n    return matches.map(parseFloat);\n} // Microsoft Edge fix\nvar allUppercase = /^[A-Z-]+$/;\n/**\r\n * Normalize attribute name.\r\n * @param name - Attribute name.\r\n * @returns Normalized attribute name.\r\n */ function normalizeAttributeName(name) {\n    if (allUppercase.test(name)) {\n        return name.toLowerCase();\n    }\n    return name;\n}\n/**\r\n * Parse external URL.\r\n * @param url - CSS url string.\r\n * @returns Parsed URL.\r\n */ function parseExternalUrl(url) {\n    //                      single quotes [2]\n    //                      v         double quotes [3]\n    //                      v         v         no quotes [4]\n    //                      v         v         v\n    var urlMatch = /url\\(('([^']+)'|\"([^\"]+)\"|([^'\")]+))\\)/.exec(url) || [];\n    return urlMatch[2] || urlMatch[3] || urlMatch[4];\n}\n/**\r\n * Transform floats to integers in rgb colors.\r\n * @param color - Color to normalize.\r\n * @returns Normalized color.\r\n */ function normalizeColor(color) {\n    if (!color.startsWith(\"rgb\")) {\n        return color;\n    }\n    var rgbParts = 3;\n    var normalizedColor = color.replace(/\\d+(\\.\\d+)?/g, (num, isFloat)=>rgbParts-- && isFloat ? String(Math.round(parseFloat(num))) : num);\n    return normalizedColor;\n}\n// slightly modified version of https://github.com/keeganstreet/specificity/blob/master/specificity.js\nvar attributeRegex = /(\\[[^\\]]+\\])/g;\nvar idRegex = /(#[^\\s+>~.[:]+)/g;\nvar classRegex = /(\\.[^\\s+>~.[:]+)/g;\nvar pseudoElementRegex = /(::[^\\s+>~.[:]+|:first-line|:first-letter|:before|:after)/gi;\nvar pseudoClassWithBracketsRegex = /(:[\\w-]+\\([^)]*\\))/gi;\nvar pseudoClassRegex = /(:[^\\s+>~.[:]+)/g;\nvar elementRegex = /([^\\s+>~.[:]+)/g;\nfunction findSelectorMatch(selector, regex) {\n    var matches = regex.exec(selector);\n    if (!matches) {\n        return [\n            selector,\n            0\n        ];\n    }\n    return [\n        selector.replace(regex, \" \"),\n        matches.length\n    ];\n}\n/**\r\n * Measure selector specificity.\r\n * @param selector - Selector to measure.\r\n * @returns Specificity.\r\n */ function getSelectorSpecificity(selector) {\n    var specificity = [\n        0,\n        0,\n        0\n    ];\n    var currentSelector = selector.replace(/:not\\(([^)]*)\\)/g, \"     $1 \").replace(/{[\\s\\S]*/gm, \" \");\n    var delta = 0;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, attributeRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, idRegex);\n    specificity[0] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, classRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoElementRegex);\n    specificity[2] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassWithBracketsRegex);\n    specificity[1] += delta;\n    [currentSelector, delta] = findSelectorMatch(currentSelector, pseudoClassRegex);\n    specificity[1] += delta;\n    currentSelector = currentSelector.replace(/[*\\s+>~]/g, \" \").replace(/[#.]/g, \" \");\n    [currentSelector, delta] = findSelectorMatch(currentSelector, elementRegex); // lgtm [js/useless-assignment-to-local]\n    specificity[2] += delta;\n    return specificity.join(\"\");\n}\nvar PSEUDO_ZERO = .00000001;\n/**\r\n * Vector magnitude.\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorMagnitude(v) {\n    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n}\n/**\r\n * Ratio between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsRatio(u, v) {\n    return (u[0] * v[0] + u[1] * v[1]) / (vectorMagnitude(u) * vectorMagnitude(v));\n}\n/**\r\n * Angle between two vectors.\r\n * @param u\r\n * @param v\r\n * @returns Number result.\r\n */ function vectorsAngle(u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vectorsRatio(u, v));\n}\nfunction CB1(t) {\n    return t * t * t;\n}\nfunction CB2(t) {\n    return 3 * t * t * (1 - t);\n}\nfunction CB3(t) {\n    return 3 * t * (1 - t) * (1 - t);\n}\nfunction CB4(t) {\n    return (1 - t) * (1 - t) * (1 - t);\n}\nfunction QB1(t) {\n    return t * t;\n}\nfunction QB2(t) {\n    return 2 * t * (1 - t);\n}\nfunction QB3(t) {\n    return (1 - t) * (1 - t);\n}\nclass Property {\n    constructor(document1, name, value){\n        this.document = document1;\n        this.name = name;\n        this.value = value;\n        this.isNormalizedColor = false;\n    }\n    static empty(document1) {\n        return new Property(document1, \"EMPTY\", \"\");\n    }\n    split() {\n        var separator = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \" \";\n        var { document: document1, name } = this;\n        return compressSpaces(this.getString()).trim().split(separator).map((value)=>new Property(document1, name, value));\n    }\n    hasValue(zeroIsValue) {\n        var { value } = this;\n        return value !== null && value !== \"\" && (zeroIsValue || value !== 0) && typeof value !== \"undefined\";\n    }\n    isString(regexp) {\n        var { value } = this;\n        var result = typeof value === \"string\";\n        if (!result || !regexp) {\n            return result;\n        }\n        return regexp.test(value);\n    }\n    isUrlDefinition() {\n        return this.isString(/^url\\(/);\n    }\n    isPixels() {\n        if (!this.hasValue()) {\n            return false;\n        }\n        var asString = this.getString();\n        switch(true){\n            case asString.endsWith(\"px\"):\n            case /^[0-9]+$/.test(asString):\n                return true;\n            default:\n                return false;\n        }\n    }\n    setValue(value) {\n        this.value = value;\n        return this;\n    }\n    getValue(def) {\n        if (typeof def === \"undefined\" || this.hasValue()) {\n            return this.value;\n        }\n        return def;\n    }\n    getNumber(def) {\n        if (!this.hasValue()) {\n            if (typeof def === \"undefined\") {\n                return 0;\n            }\n            return parseFloat(def);\n        }\n        var { value } = this;\n        var n = parseFloat(value);\n        if (this.isString(/%$/)) {\n            n /= 100.0;\n        }\n        return n;\n    }\n    getString(def) {\n        if (typeof def === \"undefined\" || this.hasValue()) {\n            return typeof this.value === \"undefined\" ? \"\" : String(this.value);\n        }\n        return String(def);\n    }\n    getColor(def) {\n        var color = this.getString(def);\n        if (this.isNormalizedColor) {\n            return color;\n        }\n        this.isNormalizedColor = true;\n        color = normalizeColor(color);\n        this.value = color;\n        return color;\n    }\n    getDpi() {\n        return 96.0; // TODO: compute?\n    }\n    getRem() {\n        return this.document.rootEmSize;\n    }\n    getEm() {\n        return this.document.emSize;\n    }\n    getUnits() {\n        return this.getString().replace(/[0-9.-]/g, \"\");\n    }\n    getPixels(axisOrIsFontSize) {\n        var processPercent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!this.hasValue()) {\n            return 0;\n        }\n        var [axis, isFontSize] = typeof axisOrIsFontSize === \"boolean\" ? [\n            undefined,\n            axisOrIsFontSize\n        ] : [\n            axisOrIsFontSize\n        ];\n        var { viewPort } = this.document.screen;\n        switch(true){\n            case this.isString(/vmin$/):\n                return this.getNumber() / 100.0 * Math.min(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n            case this.isString(/vmax$/):\n                return this.getNumber() / 100.0 * Math.max(viewPort.computeSize(\"x\"), viewPort.computeSize(\"y\"));\n            case this.isString(/vw$/):\n                return this.getNumber() / 100.0 * viewPort.computeSize(\"x\");\n            case this.isString(/vh$/):\n                return this.getNumber() / 100.0 * viewPort.computeSize(\"y\");\n            case this.isString(/rem$/):\n                return this.getNumber() * this.getRem();\n            case this.isString(/em$/):\n                return this.getNumber() * this.getEm();\n            case this.isString(/ex$/):\n                return this.getNumber() * this.getEm() / 2.0;\n            case this.isString(/px$/):\n                return this.getNumber();\n            case this.isString(/pt$/):\n                return this.getNumber() * this.getDpi() * (1.0 / 72.0);\n            case this.isString(/pc$/):\n                return this.getNumber() * 15;\n            case this.isString(/cm$/):\n                return this.getNumber() * this.getDpi() / 2.54;\n            case this.isString(/mm$/):\n                return this.getNumber() * this.getDpi() / 25.4;\n            case this.isString(/in$/):\n                return this.getNumber() * this.getDpi();\n            case this.isString(/%$/) && isFontSize:\n                return this.getNumber() * this.getEm();\n            case this.isString(/%$/):\n                return this.getNumber() * viewPort.computeSize(axis);\n            default:\n                {\n                    var n = this.getNumber();\n                    if (processPercent && n < 1.0) {\n                        return n * viewPort.computeSize(axis);\n                    }\n                    return n;\n                }\n        }\n    }\n    getMilliseconds() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        if (this.isString(/ms$/)) {\n            return this.getNumber();\n        }\n        return this.getNumber() * 1000;\n    }\n    getRadians() {\n        if (!this.hasValue()) {\n            return 0;\n        }\n        switch(true){\n            case this.isString(/deg$/):\n                return this.getNumber() * (Math.PI / 180.0);\n            case this.isString(/grad$/):\n                return this.getNumber() * (Math.PI / 200.0);\n            case this.isString(/rad$/):\n                return this.getNumber();\n            default:\n                return this.getNumber() * (Math.PI / 180.0);\n        }\n    }\n    getDefinition() {\n        var asString = this.getString();\n        var name = /#([^)'\"]+)/.exec(asString);\n        if (name) {\n            name = name[1];\n        }\n        if (!name) {\n            name = asString;\n        }\n        return this.document.definitions[name];\n    }\n    getFillStyleDefinition(element, opacity) {\n        var def = this.getDefinition();\n        if (!def) {\n            return null;\n        } // gradient\n        if (typeof def.createGradient === \"function\") {\n            return def.createGradient(this.document.ctx, element, opacity);\n        } // pattern\n        if (typeof def.createPattern === \"function\") {\n            if (def.getHrefAttribute().hasValue()) {\n                var patternTransform = def.getAttribute(\"patternTransform\");\n                def = def.getHrefAttribute().getDefinition();\n                if (patternTransform.hasValue()) {\n                    def.getAttribute(\"patternTransform\", true).setValue(patternTransform.value);\n                }\n            }\n            return def.createPattern(this.document.ctx, element, opacity);\n        }\n        return null;\n    }\n    getTextBaseline() {\n        if (!this.hasValue()) {\n            return null;\n        }\n        return Property.textBaselineMapping[this.getString()];\n    }\n    addOpacity(opacity) {\n        var value = this.getColor();\n        var len = value.length;\n        var commas = 0; // Simulate old RGBColor version, which can't parse rgba.\n        for(var i = 0; i < len; i++){\n            if (value[i] === \",\") {\n                commas++;\n            }\n            if (commas === 3) {\n                break;\n            }\n        }\n        if (opacity.hasValue() && this.isString() && commas !== 3) {\n            var color = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(value);\n            if (color.ok) {\n                color.alpha = opacity.getNumber();\n                value = color.toRGBA();\n            }\n        }\n        return new Property(this.document, this.name, value);\n    }\n}\nProperty.textBaselineMapping = {\n    \"baseline\": \"alphabetic\",\n    \"before-edge\": \"top\",\n    \"text-before-edge\": \"top\",\n    \"middle\": \"middle\",\n    \"central\": \"middle\",\n    \"after-edge\": \"bottom\",\n    \"text-after-edge\": \"bottom\",\n    \"ideographic\": \"ideographic\",\n    \"alphabetic\": \"alphabetic\",\n    \"hanging\": \"hanging\",\n    \"mathematical\": \"alphabetic\"\n};\nclass ViewPort {\n    constructor(){\n        this.viewPorts = [];\n    }\n    clear() {\n        this.viewPorts = [];\n    }\n    setCurrent(width, height) {\n        this.viewPorts.push({\n            width,\n            height\n        });\n    }\n    removeCurrent() {\n        this.viewPorts.pop();\n    }\n    getCurrent() {\n        var { viewPorts } = this;\n        return viewPorts[viewPorts.length - 1];\n    }\n    get width() {\n        return this.getCurrent().width;\n    }\n    get height() {\n        return this.getCurrent().height;\n    }\n    computeSize(d) {\n        if (typeof d === \"number\") {\n            return d;\n        }\n        if (d === \"x\") {\n            return this.width;\n        }\n        if (d === \"y\") {\n            return this.height;\n        }\n        return Math.sqrt(Math.pow(this.width, 2) + Math.pow(this.height, 2)) / Math.sqrt(2);\n    }\n}\nclass Point {\n    constructor(x, y){\n        this.x = x;\n        this.y = y;\n    }\n    static parse(point) {\n        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var [x = defaultValue, y = defaultValue] = toNumbers(point);\n        return new Point(x, y);\n    }\n    static parseScale(scale) {\n        var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        var [x = defaultValue, y = x] = toNumbers(scale);\n        return new Point(x, y);\n    }\n    static parsePath(path) {\n        var points = toNumbers(path);\n        var len = points.length;\n        var pathPoints = [];\n        for(var i = 0; i < len; i += 2){\n            pathPoints.push(new Point(points[i], points[i + 1]));\n        }\n        return pathPoints;\n    }\n    angleTo(point) {\n        return Math.atan2(point.y - this.y, point.x - this.x);\n    }\n    applyTransform(transform) {\n        var { x, y } = this;\n        var xp = x * transform[0] + y * transform[2] + transform[4];\n        var yp = x * transform[1] + y * transform[3] + transform[5];\n        this.x = xp;\n        this.y = yp;\n    }\n}\nclass Mouse {\n    constructor(screen){\n        this.screen = screen;\n        this.working = false;\n        this.events = [];\n        this.eventElements = []; // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onClick = this.onClick.bind(this); // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n        this.onMouseMove = this.onMouseMove.bind(this);\n    }\n    isWorking() {\n        return this.working;\n    }\n    start() {\n        if (this.working) {\n            return;\n        }\n        var { screen, onClick, onMouseMove } = this;\n        var canvas = screen.ctx.canvas;\n        canvas.onclick = onClick;\n        canvas.onmousemove = onMouseMove;\n        this.working = true;\n    }\n    stop() {\n        if (!this.working) {\n            return;\n        }\n        var canvas = this.screen.ctx.canvas;\n        this.working = false;\n        canvas.onclick = null;\n        canvas.onmousemove = null;\n    }\n    hasEvents() {\n        return this.working && this.events.length > 0;\n    }\n    runEvents() {\n        if (!this.working) {\n            return;\n        }\n        var { screen: document1, events, eventElements } = this;\n        var { style } = document1.ctx.canvas;\n        if (style) {\n            style.cursor = \"\";\n        }\n        events.forEach((_ref, i)=>{\n            var { run } = _ref;\n            var element = eventElements[i];\n            while(element){\n                run(element);\n                element = element.parent;\n            }\n        }); // done running, clear\n        this.events = [];\n        this.eventElements = [];\n    }\n    checkPath(element, ctx) {\n        if (!this.working || !ctx) {\n            return;\n        }\n        var { events, eventElements } = this;\n        events.forEach((_ref2, i)=>{\n            var { x, y } = _ref2;\n            if (!eventElements[i] && ctx.isPointInPath && ctx.isPointInPath(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    checkBoundingBox(element, boundingBox) {\n        if (!this.working || !boundingBox) {\n            return;\n        }\n        var { events, eventElements } = this;\n        events.forEach((_ref3, i)=>{\n            var { x, y } = _ref3;\n            if (!eventElements[i] && boundingBox.isPointInBox(x, y)) {\n                eventElements[i] = element;\n            }\n        });\n    }\n    mapXY(x, y) {\n        var { window: window1, ctx } = this.screen;\n        var point = new Point(x, y);\n        var element = ctx.canvas;\n        while(element){\n            point.x -= element.offsetLeft;\n            point.y -= element.offsetTop;\n            element = element.offsetParent;\n        }\n        if (window1.scrollX) {\n            point.x += window1.scrollX;\n        }\n        if (window1.scrollY) {\n            point.y += window1.scrollY;\n        }\n        return point;\n    }\n    onClick(event) {\n        var { x, y } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: \"onclick\",\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onClick) {\n                    eventTarget.onClick();\n                }\n            }\n        });\n    }\n    onMouseMove(event) {\n        var { x, y } = this.mapXY(event.clientX, event.clientY);\n        this.events.push({\n            type: \"onmousemove\",\n            x,\n            y,\n            run (eventTarget) {\n                if (eventTarget.onMouseMove) {\n                    eventTarget.onMouseMove();\n                }\n            }\n        });\n    }\n}\nvar defaultWindow =  false ? 0 : null;\nvar defaultFetch$1 = typeof fetch !== \"undefined\" ? fetch.bind(undefined) // `fetch` depends on context: `someObject.fetch(...)` will throw error.\n : null;\nclass Screen {\n    constructor(ctx){\n        var { fetch: fetch1 = defaultFetch$1, window: window1 = defaultWindow } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.ctx = ctx;\n        this.FRAMERATE = 30;\n        this.MAX_VIRTUAL_PIXELS = 30000;\n        this.CLIENT_WIDTH = 800;\n        this.CLIENT_HEIGHT = 600;\n        this.viewPort = new ViewPort();\n        this.mouse = new Mouse(this);\n        this.animations = [];\n        this.waits = [];\n        this.frameDuration = 0;\n        this.isReadyLock = false;\n        this.isFirstRender = true;\n        this.intervalId = null;\n        this.window = window1;\n        this.fetch = fetch1;\n    }\n    wait(checker) {\n        this.waits.push(checker);\n    }\n    ready() {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        if (!this.readyPromise) {\n            return Promise.resolve();\n        }\n        return this.readyPromise;\n    }\n    isReady() {\n        if (this.isReadyLock) {\n            return true;\n        }\n        var isReadyLock = this.waits.every((_)=>_());\n        if (isReadyLock) {\n            this.waits = [];\n            if (this.resolveReady) {\n                this.resolveReady();\n            }\n        }\n        this.isReadyLock = isReadyLock;\n        return isReadyLock;\n    }\n    setDefaults(ctx) {\n        // initial values and defaults\n        ctx.strokeStyle = \"rgba(0,0,0,0)\";\n        ctx.lineCap = \"butt\";\n        ctx.lineJoin = \"miter\";\n        ctx.miterLimit = 4;\n    }\n    setViewBox(_ref) {\n        var { document: document1, ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX = 0, minY = 0, refX, refY, clip = false, clipX = 0, clipY = 0 } = _ref;\n        // aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\n        var cleanAspectRatio = compressSpaces(aspectRatio).replace(/^defer\\s/, \"\"); // ignore defer\n        var [aspectRatioAlign, aspectRatioMeetOrSlice] = cleanAspectRatio.split(\" \");\n        var align = aspectRatioAlign || \"xMidYMid\";\n        var meetOrSlice = aspectRatioMeetOrSlice || \"meet\"; // calculate scale\n        var scaleX = width / desiredWidth;\n        var scaleY = height / desiredHeight;\n        var scaleMin = Math.min(scaleX, scaleY);\n        var scaleMax = Math.max(scaleX, scaleY);\n        var finalDesiredWidth = desiredWidth;\n        var finalDesiredHeight = desiredHeight;\n        if (meetOrSlice === \"meet\") {\n            finalDesiredWidth *= scaleMin;\n            finalDesiredHeight *= scaleMin;\n        }\n        if (meetOrSlice === \"slice\") {\n            finalDesiredWidth *= scaleMax;\n            finalDesiredHeight *= scaleMax;\n        }\n        var refXProp = new Property(document1, \"refX\", refX);\n        var refYProp = new Property(document1, \"refY\", refY);\n        var hasRefs = refXProp.hasValue() && refYProp.hasValue();\n        if (hasRefs) {\n            ctx.translate(-scaleMin * refXProp.getPixels(\"x\"), -scaleMin * refYProp.getPixels(\"y\"));\n        }\n        if (clip) {\n            var scaledClipX = scaleMin * clipX;\n            var scaledClipY = scaleMin * clipY;\n            ctx.beginPath();\n            ctx.moveTo(scaledClipX, scaledClipY);\n            ctx.lineTo(width, scaledClipY);\n            ctx.lineTo(width, height);\n            ctx.lineTo(scaledClipX, height);\n            ctx.closePath();\n            ctx.clip();\n        }\n        if (!hasRefs) {\n            var isMeetMinY = meetOrSlice === \"meet\" && scaleMin === scaleY;\n            var isSliceMaxY = meetOrSlice === \"slice\" && scaleMax === scaleY;\n            var isMeetMinX = meetOrSlice === \"meet\" && scaleMin === scaleX;\n            var isSliceMaxX = meetOrSlice === \"slice\" && scaleMax === scaleX;\n            if (align.startsWith(\"xMid\") && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width / 2.0 - finalDesiredWidth / 2.0, 0);\n            }\n            if (align.endsWith(\"YMid\") && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height / 2.0 - finalDesiredHeight / 2.0);\n            }\n            if (align.startsWith(\"xMax\") && (isMeetMinY || isSliceMaxY)) {\n                ctx.translate(width - finalDesiredWidth, 0);\n            }\n            if (align.endsWith(\"YMax\") && (isMeetMinX || isSliceMaxX)) {\n                ctx.translate(0, height - finalDesiredHeight);\n            }\n        } // scale\n        switch(true){\n            case align === \"none\":\n                ctx.scale(scaleX, scaleY);\n                break;\n            case meetOrSlice === \"meet\":\n                ctx.scale(scaleMin, scaleMin);\n                break;\n            case meetOrSlice === \"slice\":\n                ctx.scale(scaleMax, scaleMax);\n                break;\n        } // translate\n        ctx.translate(-minX, -minY);\n    }\n    start(element) {\n        var { enableRedraw = false, ignoreMouse = false, ignoreAnimation = false, ignoreDimensions = false, ignoreClear = false, forceRedraw, scaleWidth, scaleHeight, offsetX, offsetY } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        var { FRAMERATE, mouse } = this;\n        var frameDuration = 1000 / FRAMERATE;\n        this.frameDuration = frameDuration;\n        this.readyPromise = new Promise((resolve)=>{\n            this.resolveReady = resolve;\n        });\n        if (this.isReady()) {\n            this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n        }\n        if (!enableRedraw) {\n            return;\n        }\n        var now = Date.now();\n        var then = now;\n        var delta = 0;\n        var tick = ()=>{\n            now = Date.now();\n            delta = now - then;\n            if (delta >= frameDuration) {\n                then = now - delta % frameDuration;\n                if (this.shouldUpdate(ignoreAnimation, forceRedraw)) {\n                    this.render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY);\n                    mouse.runEvents();\n                }\n            }\n            this.intervalId = raf__WEBPACK_IMPORTED_MODULE_11__(tick);\n        };\n        if (!ignoreMouse) {\n            mouse.start();\n        }\n        this.intervalId = raf__WEBPACK_IMPORTED_MODULE_11__(tick);\n    }\n    stop() {\n        if (this.intervalId) {\n            raf__WEBPACK_IMPORTED_MODULE_11__.cancel(this.intervalId);\n            this.intervalId = null;\n        }\n        this.mouse.stop();\n    }\n    shouldUpdate(ignoreAnimation, forceRedraw) {\n        // need update from animations?\n        if (!ignoreAnimation) {\n            var { frameDuration } = this;\n            var shouldUpdate = this.animations.reduce((shouldUpdate, animation)=>animation.update(frameDuration) || shouldUpdate, false);\n            if (shouldUpdate) {\n                return true;\n            }\n        } // need update from redraw?\n        if (typeof forceRedraw === \"function\" && forceRedraw()) {\n            return true;\n        }\n        if (!this.isReadyLock && this.isReady()) {\n            return true;\n        } // need update from mouse events?\n        if (this.mouse.hasEvents()) {\n            return true;\n        }\n        return false;\n    }\n    render(element, ignoreDimensions, ignoreClear, scaleWidth, scaleHeight, offsetX, offsetY) {\n        var { CLIENT_WIDTH, CLIENT_HEIGHT, viewPort, ctx, isFirstRender } = this;\n        var canvas = ctx.canvas;\n        viewPort.clear();\n        if (canvas.width && canvas.height) {\n            viewPort.setCurrent(canvas.width, canvas.height);\n        } else {\n            viewPort.setCurrent(CLIENT_WIDTH, CLIENT_HEIGHT);\n        }\n        var widthStyle = element.getStyle(\"width\");\n        var heightStyle = element.getStyle(\"height\");\n        if (!ignoreDimensions && (isFirstRender || typeof scaleWidth !== \"number\" && typeof scaleHeight !== \"number\")) {\n            // set canvas size\n            if (widthStyle.hasValue()) {\n                canvas.width = widthStyle.getPixels(\"x\");\n                if (canvas.style) {\n                    canvas.style.width = \"\".concat(canvas.width, \"px\");\n                }\n            }\n            if (heightStyle.hasValue()) {\n                canvas.height = heightStyle.getPixels(\"y\");\n                if (canvas.style) {\n                    canvas.style.height = \"\".concat(canvas.height, \"px\");\n                }\n            }\n        }\n        var cWidth = canvas.clientWidth || canvas.width;\n        var cHeight = canvas.clientHeight || canvas.height;\n        if (ignoreDimensions && widthStyle.hasValue() && heightStyle.hasValue()) {\n            cWidth = widthStyle.getPixels(\"x\");\n            cHeight = heightStyle.getPixels(\"y\");\n        }\n        viewPort.setCurrent(cWidth, cHeight);\n        if (typeof offsetX === \"number\") {\n            element.getAttribute(\"x\", true).setValue(offsetX);\n        }\n        if (typeof offsetY === \"number\") {\n            element.getAttribute(\"y\", true).setValue(offsetY);\n        }\n        if (typeof scaleWidth === \"number\" || typeof scaleHeight === \"number\") {\n            var viewBox = toNumbers(element.getAttribute(\"viewBox\").getString());\n            var xRatio = 0;\n            var yRatio = 0;\n            if (typeof scaleWidth === \"number\") {\n                var _widthStyle = element.getStyle(\"width\");\n                if (_widthStyle.hasValue()) {\n                    xRatio = _widthStyle.getPixels(\"x\") / scaleWidth;\n                } else if (!isNaN(viewBox[2])) {\n                    xRatio = viewBox[2] / scaleWidth;\n                }\n            }\n            if (typeof scaleHeight === \"number\") {\n                var _heightStyle = element.getStyle(\"height\");\n                if (_heightStyle.hasValue()) {\n                    yRatio = _heightStyle.getPixels(\"y\") / scaleHeight;\n                } else if (!isNaN(viewBox[3])) {\n                    yRatio = viewBox[3] / scaleHeight;\n                }\n            }\n            if (!xRatio) {\n                xRatio = yRatio;\n            }\n            if (!yRatio) {\n                yRatio = xRatio;\n            }\n            element.getAttribute(\"width\", true).setValue(scaleWidth);\n            element.getAttribute(\"height\", true).setValue(scaleHeight);\n            var transformStyle = element.getStyle(\"transform\", true, true);\n            transformStyle.setValue(\"\".concat(transformStyle.getString(), \" scale(\").concat(1.0 / xRatio, \", \").concat(1.0 / yRatio, \")\"));\n        } // clear and render\n        if (!ignoreClear) {\n            ctx.clearRect(0, 0, cWidth, cHeight);\n        }\n        element.render(ctx);\n        if (isFirstRender) {\n            this.isFirstRender = false;\n        }\n    }\n}\nScreen.defaultWindow = defaultWindow;\nScreen.defaultFetch = defaultFetch$1;\nvar { defaultFetch } = Screen;\nvar DefaultDOMParser = typeof DOMParser !== \"undefined\" ? DOMParser : null;\nclass Parser {\n    constructor(){\n        var { fetch: fetch1 = defaultFetch, DOMParser: DOMParser1 = DefaultDOMParser } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        this.fetch = fetch1;\n        this.DOMParser = DOMParser1;\n    }\n    parse(resource) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            if (resource.startsWith(\"<\")) {\n                return _this.parseFromString(resource);\n            }\n            return _this.load(resource);\n        })();\n    }\n    parseFromString(xml) {\n        var parser = new this.DOMParser();\n        try {\n            return this.checkDocument(parser.parseFromString(xml, \"image/svg+xml\"));\n        } catch (err) {\n            return this.checkDocument(parser.parseFromString(xml, \"text/xml\"));\n        }\n    }\n    checkDocument(document1) {\n        var parserError = document1.getElementsByTagName(\"parsererror\")[0];\n        if (parserError) {\n            throw new Error(parserError.textContent);\n        }\n        return document1;\n    }\n    load(url) {\n        var _this2 = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var response = yield _this2.fetch(url);\n            var xml = yield response.text();\n            return _this2.parseFromString(xml);\n        })();\n    }\n}\nclass Translate {\n    constructor(_, point){\n        this.type = \"translate\";\n        this.point = null;\n        this.point = Point.parse(point);\n    }\n    apply(ctx) {\n        var { x, y } = this.point;\n        ctx.translate(x || 0.0, y || 0.0);\n    }\n    unapply(ctx) {\n        var { x, y } = this.point;\n        ctx.translate(-1.0 * x || 0.0, -1.0 * y || 0.0);\n    }\n    applyToPoint(point) {\n        var { x, y } = this.point;\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            x || 0.0,\n            y || 0.0\n        ]);\n    }\n}\nclass Rotate {\n    constructor(document1, rotate, transformOrigin){\n        this.type = \"rotate\";\n        this.angle = null;\n        this.originX = null;\n        this.originY = null;\n        this.cx = 0;\n        this.cy = 0;\n        var numbers = toNumbers(rotate);\n        this.angle = new Property(document1, \"angle\", numbers[0]);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n        this.cx = numbers[1] || 0;\n        this.cy = numbers[2] || 0;\n    }\n    apply(ctx) {\n        var { cx, cy, originX, originY, angle } = this;\n        var tx = cx + originX.getPixels(\"x\");\n        var ty = cy + originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.rotate(angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { cx, cy, originX, originY, angle } = this;\n        var tx = cx + originX.getPixels(\"x\");\n        var ty = cy + originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.rotate(-1.0 * angle.getRadians());\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        var { cx, cy, angle } = this;\n        var rad = angle.getRadians();\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            cx || 0.0,\n            cy || 0.0 // this.p.y\n        ]);\n        point.applyTransform([\n            Math.cos(rad),\n            Math.sin(rad),\n            -Math.sin(rad),\n            Math.cos(rad),\n            0,\n            0\n        ]);\n        point.applyTransform([\n            1,\n            0,\n            0,\n            1,\n            -cx || 0.0,\n            -cy || 0.0 // -this.p.y\n        ]);\n    }\n}\nclass Scale {\n    constructor(_, scale, transformOrigin){\n        this.type = \"scale\";\n        this.scale = null;\n        this.originX = null;\n        this.originY = null;\n        var scaleSize = Point.parseScale(scale); // Workaround for node-canvas\n        if (scaleSize.x === 0 || scaleSize.y === 0) {\n            scaleSize.x = PSEUDO_ZERO;\n            scaleSize.y = PSEUDO_ZERO;\n        }\n        this.scale = scaleSize;\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    apply(ctx) {\n        var { scale: { x, y }, originX, originY } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.scale(x, y || x);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { scale: { x, y }, originX, originY } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.scale(1.0 / x, 1.0 / y || x);\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        var { x, y } = this.scale;\n        point.applyTransform([\n            x || 0.0,\n            0,\n            0,\n            y || 0.0,\n            0,\n            0\n        ]);\n    }\n}\nclass Matrix {\n    constructor(_, matrix, transformOrigin){\n        this.type = \"matrix\";\n        this.matrix = [];\n        this.originX = null;\n        this.originY = null;\n        this.matrix = toNumbers(matrix);\n        this.originX = transformOrigin[0];\n        this.originY = transformOrigin[1];\n    }\n    apply(ctx) {\n        var { originX, originY, matrix } = this;\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n        ctx.translate(-tx, -ty);\n    }\n    unapply(ctx) {\n        var { originX, originY, matrix } = this;\n        var a = matrix[0];\n        var b = matrix[2];\n        var c = matrix[4];\n        var d = matrix[1];\n        var e = matrix[3];\n        var f = matrix[5];\n        var g = 0.0;\n        var h = 0.0;\n        var i = 1.0;\n        var det = 1 / (a * (e * i - f * h) - b * (d * i - f * g) + c * (d * h - e * g));\n        var tx = originX.getPixels(\"x\");\n        var ty = originY.getPixels(\"y\");\n        ctx.translate(tx, ty);\n        ctx.transform(det * (e * i - f * h), det * (f * g - d * i), det * (c * h - b * i), det * (a * i - c * g), det * (b * f - c * e), det * (c * d - a * f));\n        ctx.translate(-tx, -ty);\n    }\n    applyToPoint(point) {\n        point.applyTransform(this.matrix);\n    }\n}\nclass Skew extends Matrix {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skew\";\n        this.angle = null;\n        this.angle = new Property(document1, \"angle\", skew);\n    }\n}\nclass SkewX extends Skew {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skewX\";\n        this.matrix = [\n            1,\n            0,\n            Math.tan(this.angle.getRadians()),\n            1,\n            0,\n            0\n        ];\n    }\n}\nclass SkewY extends Skew {\n    constructor(document1, skew, transformOrigin){\n        super(document1, skew, transformOrigin);\n        this.type = \"skewY\";\n        this.matrix = [\n            1,\n            Math.tan(this.angle.getRadians()),\n            0,\n            1,\n            0,\n            0\n        ];\n    }\n}\nfunction parseTransforms(transform) {\n    return compressSpaces(transform).trim().replace(/\\)([a-zA-Z])/g, \") $1\").replace(/\\)(\\s?,\\s?)/g, \") \").split(/\\s(?=[a-z])/);\n}\nfunction parseTransform(transform) {\n    var [type, value] = transform.split(\"(\");\n    return [\n        type.trim(),\n        value.trim().replace(\")\", \"\")\n    ];\n}\nclass Transform {\n    constructor(document1, transform, transformOrigin){\n        this.document = document1;\n        this.transforms = [];\n        var data = parseTransforms(transform);\n        data.forEach((transform)=>{\n            if (transform === \"none\") {\n                return;\n            }\n            var [type, value] = parseTransform(transform);\n            var TransformType = Transform.transformTypes[type];\n            if (typeof TransformType !== \"undefined\") {\n                this.transforms.push(new TransformType(this.document, value, transformOrigin));\n            }\n        });\n    }\n    static fromElement(document1, element) {\n        var transformStyle = element.getStyle(\"transform\", false, true);\n        var [transformOriginXProperty, transformOriginYProperty = transformOriginXProperty] = element.getStyle(\"transform-origin\", false, true).split();\n        var transformOrigin = [\n            transformOriginXProperty,\n            transformOriginYProperty\n        ];\n        if (transformStyle.hasValue()) {\n            return new Transform(document1, transformStyle.getString(), transformOrigin);\n        }\n        return null;\n    }\n    apply(ctx) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = 0; i < len; i++){\n            transforms[i].apply(ctx);\n        }\n    }\n    unapply(ctx) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = len - 1; i >= 0; i--){\n            transforms[i].unapply(ctx);\n        }\n    }\n    applyToPoint(point) {\n        var { transforms } = this;\n        var len = transforms.length;\n        for(var i = 0; i < len; i++){\n            transforms[i].applyToPoint(point);\n        }\n    }\n}\nTransform.transformTypes = {\n    translate: Translate,\n    rotate: Rotate,\n    scale: Scale,\n    matrix: Matrix,\n    skewX: SkewX,\n    skewY: SkewY\n};\nclass Element {\n    constructor(document1, node){\n        var captureTextNodes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        this.document = document1;\n        this.node = node;\n        this.captureTextNodes = captureTextNodes;\n        this.attributes = Object.create(null);\n        this.styles = Object.create(null);\n        this.stylesSpecificity = Object.create(null);\n        this.animationFrozen = false;\n        this.animationFrozenValue = \"\";\n        this.parent = null;\n        this.children = [];\n        if (!node || node.nodeType !== 1) {\n            // ELEMENT_NODE\n            return;\n        } // add attributes\n        Array.from(node.attributes).forEach((attribute)=>{\n            var nodeName = normalizeAttributeName(attribute.nodeName);\n            this.attributes[nodeName] = new Property(document1, nodeName, attribute.value);\n        });\n        this.addStylesFromStyleDefinition(); // add inline styles\n        if (this.getAttribute(\"style\").hasValue()) {\n            var styles = this.getAttribute(\"style\").getString().split(\";\").map((_)=>_.trim());\n            styles.forEach((style)=>{\n                if (!style) {\n                    return;\n                }\n                var [name, value] = style.split(\":\").map((_)=>_.trim());\n                this.styles[name] = new Property(document1, name, value);\n            });\n        }\n        var { definitions } = document1;\n        var id = this.getAttribute(\"id\"); // add id\n        if (id.hasValue()) {\n            if (!definitions[id.getString()]) {\n                definitions[id.getString()] = this;\n            }\n        }\n        Array.from(node.childNodes).forEach((childNode)=>{\n            if (childNode.nodeType === 1) {\n                this.addChild(childNode); // ELEMENT_NODE\n            } else if (captureTextNodes && (childNode.nodeType === 3 || childNode.nodeType === 4)) {\n                var textNode = document1.createTextNode(childNode);\n                if (textNode.getText().length > 0) {\n                    this.addChild(textNode); // TEXT_NODE\n                }\n            }\n        });\n    }\n    getAttribute(name) {\n        var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var attr = this.attributes[name];\n        if (!attr && createIfNotExists) {\n            var _attr = new Property(this.document, name, \"\");\n            this.attributes[name] = _attr;\n            return _attr;\n        }\n        return attr || Property.empty(this.document);\n    }\n    getHrefAttribute() {\n        for(var key in this.attributes){\n            if (key === \"href\" || key.endsWith(\":href\")) {\n                return this.attributes[key];\n            }\n        }\n        return Property.empty(this.document);\n    }\n    getStyle(name) {\n        var createIfNotExists = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var skipAncestors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var style = this.styles[name];\n        if (style) {\n            return style;\n        }\n        var attr = this.getAttribute(name);\n        if (attr !== null && attr !== void 0 && attr.hasValue()) {\n            this.styles[name] = attr; // move up to me to cache\n            return attr;\n        }\n        if (!skipAncestors) {\n            var { parent } = this;\n            if (parent) {\n                var parentStyle = parent.getStyle(name);\n                if (parentStyle !== null && parentStyle !== void 0 && parentStyle.hasValue()) {\n                    return parentStyle;\n                }\n            }\n        }\n        if (createIfNotExists) {\n            var _style = new Property(this.document, name, \"\");\n            this.styles[name] = _style;\n            return _style;\n        }\n        return style || Property.empty(this.document);\n    }\n    render(ctx) {\n        // don't render display=none\n        // don't render visibility=hidden\n        if (this.getStyle(\"display\").getString() === \"none\" || this.getStyle(\"visibility\").getString() === \"hidden\") {\n            return;\n        }\n        ctx.save();\n        if (this.getStyle(\"mask\").hasValue()) {\n            // mask\n            var mask = this.getStyle(\"mask\").getDefinition();\n            if (mask) {\n                this.applyEffects(ctx);\n                mask.apply(ctx, this);\n            }\n        } else if (this.getStyle(\"filter\").getValue(\"none\") !== \"none\") {\n            // filter\n            var filter = this.getStyle(\"filter\").getDefinition();\n            if (filter) {\n                this.applyEffects(ctx);\n                filter.apply(ctx, this);\n            }\n        } else {\n            this.setContext(ctx);\n            this.renderChildren(ctx);\n            this.clearContext(ctx);\n        }\n        ctx.restore();\n    }\n    setContext(_) {}\n    applyEffects(ctx) {\n        // transform\n        var transform = Transform.fromElement(this.document, this);\n        if (transform) {\n            transform.apply(ctx);\n        } // clip\n        var clipPathStyleProp = this.getStyle(\"clip-path\", false, true);\n        if (clipPathStyleProp.hasValue()) {\n            var clip = clipPathStyleProp.getDefinition();\n            if (clip) {\n                clip.apply(ctx);\n            }\n        }\n    }\n    clearContext(_) {}\n    renderChildren(ctx) {\n        this.children.forEach((child)=>{\n            child.render(ctx);\n        });\n    }\n    addChild(childNode) {\n        var child = childNode instanceof Element ? childNode : this.document.createElement(childNode);\n        child.parent = this;\n        if (!Element.ignoreChildTypes.includes(child.type)) {\n            this.children.push(child);\n        }\n    }\n    matchesSelector(selector) {\n        var _node$getAttribute;\n        var { node } = this;\n        if (typeof node.matches === \"function\") {\n            return node.matches(selector);\n        }\n        var styleClasses = (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, \"class\");\n        if (!styleClasses || styleClasses === \"\") {\n            return false;\n        }\n        return styleClasses.split(\" \").some((styleClass)=>\".\".concat(styleClass) === selector);\n    }\n    addStylesFromStyleDefinition() {\n        var { styles, stylesSpecificity } = this.document;\n        for(var selector in styles){\n            if (!selector.startsWith(\"@\") && this.matchesSelector(selector)) {\n                var style = styles[selector];\n                var specificity = stylesSpecificity[selector];\n                if (style) {\n                    for(var name in style){\n                        var existingSpecificity = this.stylesSpecificity[name];\n                        if (typeof existingSpecificity === \"undefined\") {\n                            existingSpecificity = \"000\";\n                        }\n                        if (specificity >= existingSpecificity) {\n                            this.styles[name] = style[name];\n                            this.stylesSpecificity[name] = specificity;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    removeStyles(element, ignoreStyles) {\n        var toRestore = ignoreStyles.reduce((toRestore, name)=>{\n            var styleProp = element.getStyle(name);\n            if (!styleProp.hasValue()) {\n                return toRestore;\n            }\n            var value = styleProp.getString();\n            styleProp.setValue(\"\");\n            return [\n                ...toRestore,\n                [\n                    name,\n                    value\n                ]\n            ];\n        }, []);\n        return toRestore;\n    }\n    restoreStyles(element, styles) {\n        styles.forEach((_ref)=>{\n            var [name, value] = _ref;\n            element.getStyle(name, true).setValue(value);\n        });\n    }\n    isFirstChild() {\n        var _this$parent;\n        return ((_this$parent = this.parent) === null || _this$parent === void 0 ? void 0 : _this$parent.children.indexOf(this)) === 0;\n    }\n}\nElement.ignoreChildTypes = [\n    \"title\"\n];\nclass UnknownElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n    }\n}\nfunction wrapFontFamily(fontFamily) {\n    var trimmed = fontFamily.trim();\n    return /^('|\")/.test(trimmed) ? trimmed : '\"'.concat(trimmed, '\"');\n}\nfunction prepareFontFamily(fontFamily) {\n    return typeof process === \"undefined\" ? fontFamily : fontFamily.trim().split(\",\").map(wrapFontFamily).join(\",\");\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-style\r\n * @param fontStyle\r\n * @returns CSS font style.\r\n */ function prepareFontStyle(fontStyle) {\n    if (!fontStyle) {\n        return \"\";\n    }\n    var targetFontStyle = fontStyle.trim().toLowerCase();\n    switch(targetFontStyle){\n        case \"normal\":\n        case \"italic\":\n        case \"oblique\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontStyle;\n        default:\n            if (/^oblique\\s+(-|)\\d+deg$/.test(targetFontStyle)) {\n                return targetFontStyle;\n            }\n            return \"\";\n    }\n}\n/**\r\n * https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight\r\n * @param fontWeight\r\n * @returns CSS font weight.\r\n */ function prepareFontWeight(fontWeight) {\n    if (!fontWeight) {\n        return \"\";\n    }\n    var targetFontWeight = fontWeight.trim().toLowerCase();\n    switch(targetFontWeight){\n        case \"normal\":\n        case \"bold\":\n        case \"lighter\":\n        case \"bolder\":\n        case \"inherit\":\n        case \"initial\":\n        case \"unset\":\n            return targetFontWeight;\n        default:\n            if (/^[\\d.]+$/.test(targetFontWeight)) {\n                return targetFontWeight;\n            }\n            return \"\";\n    }\n}\nclass Font {\n    constructor(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit){\n        var inheritFont = inherit ? typeof inherit === \"string\" ? Font.parse(inherit) : inherit : {};\n        this.fontFamily = fontFamily || inheritFont.fontFamily;\n        this.fontSize = fontSize || inheritFont.fontSize;\n        this.fontStyle = fontStyle || inheritFont.fontStyle;\n        this.fontWeight = fontWeight || inheritFont.fontWeight;\n        this.fontVariant = fontVariant || inheritFont.fontVariant;\n    }\n    static parse() {\n        var font = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n        var inherit = arguments.length > 1 ? arguments[1] : undefined;\n        var fontStyle = \"\";\n        var fontVariant = \"\";\n        var fontWeight = \"\";\n        var fontSize = \"\";\n        var fontFamily = \"\";\n        var parts = compressSpaces(font).trim().split(\" \");\n        var set = {\n            fontSize: false,\n            fontStyle: false,\n            fontWeight: false,\n            fontVariant: false\n        };\n        parts.forEach((part)=>{\n            switch(true){\n                case !set.fontStyle && Font.styles.includes(part):\n                    if (part !== \"inherit\") {\n                        fontStyle = part;\n                    }\n                    set.fontStyle = true;\n                    break;\n                case !set.fontVariant && Font.variants.includes(part):\n                    if (part !== \"inherit\") {\n                        fontVariant = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    break;\n                case !set.fontWeight && Font.weights.includes(part):\n                    if (part !== \"inherit\") {\n                        fontWeight = part;\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    break;\n                case !set.fontSize:\n                    if (part !== \"inherit\") {\n                        [fontSize] = part.split(\"/\");\n                    }\n                    set.fontStyle = true;\n                    set.fontVariant = true;\n                    set.fontWeight = true;\n                    set.fontSize = true;\n                    break;\n                default:\n                    if (part !== \"inherit\") {\n                        fontFamily += part;\n                    }\n            }\n        });\n        return new Font(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit);\n    }\n    toString() {\n        return [\n            prepareFontStyle(this.fontStyle),\n            this.fontVariant,\n            prepareFontWeight(this.fontWeight),\n            this.fontSize,\n            prepareFontFamily(this.fontFamily)\n        ].join(\" \").trim();\n    }\n}\nFont.styles = \"normal|italic|oblique|inherit\";\nFont.variants = \"normal|small-caps|inherit\";\nFont.weights = \"normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit\";\nclass BoundingBox {\n    constructor(){\n        var x1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Number.NaN;\n        var y1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.NaN;\n        var x2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Number.NaN;\n        var y2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Number.NaN;\n        this.x1 = x1;\n        this.y1 = y1;\n        this.x2 = x2;\n        this.y2 = y2;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    get x() {\n        return this.x1;\n    }\n    get y() {\n        return this.y1;\n    }\n    get width() {\n        return this.x2 - this.x1;\n    }\n    get height() {\n        return this.y2 - this.y1;\n    }\n    addPoint(x, y) {\n        if (typeof x !== \"undefined\") {\n            if (isNaN(this.x1) || isNaN(this.x2)) {\n                this.x1 = x;\n                this.x2 = x;\n            }\n            if (x < this.x1) {\n                this.x1 = x;\n            }\n            if (x > this.x2) {\n                this.x2 = x;\n            }\n        }\n        if (typeof y !== \"undefined\") {\n            if (isNaN(this.y1) || isNaN(this.y2)) {\n                this.y1 = y;\n                this.y2 = y;\n            }\n            if (y < this.y1) {\n                this.y1 = y;\n            }\n            if (y > this.y2) {\n                this.y2 = y;\n            }\n        }\n    }\n    addX(x) {\n        this.addPoint(x, null);\n    }\n    addY(y) {\n        this.addPoint(null, y);\n    }\n    addBoundingBox(boundingBox) {\n        if (!boundingBox) {\n            return;\n        }\n        var { x1, y1, x2, y2 } = boundingBox;\n        this.addPoint(x1, y1);\n        this.addPoint(x2, y2);\n    }\n    sumCubic(t, p0, p1, p2, p3) {\n        return Math.pow(1 - t, 3) * p0 + 3 * Math.pow(1 - t, 2) * t * p1 + 3 * (1 - t) * Math.pow(t, 2) * p2 + Math.pow(t, 3) * p3;\n    }\n    bezierCurveAdd(forX, p0, p1, p2, p3) {\n        var b = 6 * p0 - 12 * p1 + 6 * p2;\n        var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;\n        var c = 3 * p1 - 3 * p0;\n        if (a === 0) {\n            if (b === 0) {\n                return;\n            }\n            var t = -c / b;\n            if (0 < t && t < 1) {\n                if (forX) {\n                    this.addX(this.sumCubic(t, p0, p1, p2, p3));\n                } else {\n                    this.addY(this.sumCubic(t, p0, p1, p2, p3));\n                }\n            }\n            return;\n        }\n        var b2ac = Math.pow(b, 2) - 4 * c * a;\n        if (b2ac < 0) {\n            return;\n        }\n        var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t1 && t1 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t1, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t1, p0, p1, p2, p3));\n            }\n        }\n        var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n        if (0 < t2 && t2 < 1) {\n            if (forX) {\n                this.addX(this.sumCubic(t2, p0, p1, p2, p3));\n            } else {\n                this.addY(this.sumCubic(t2, p0, p1, p2, p3));\n            }\n        }\n    }\n    addBezierCurve(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {\n        this.addPoint(p0x, p0y);\n        this.addPoint(p3x, p3y);\n        this.bezierCurveAdd(true, p0x, p1x, p2x, p3x);\n        this.bezierCurveAdd(false, p0y, p1y, p2y, p3y);\n    }\n    addQuadraticCurve(p0x, p0y, p1x, p1y, p2x, p2y) {\n        var cp1x = p0x + 2 / 3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)\n        var cp1y = p0y + 2 / 3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)\n        var cp2x = cp1x + 1 / 3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)\n        var cp2y = cp1y + 1 / 3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)\n        this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y);\n    }\n    isPointInBox(x, y) {\n        var { x1, y1, x2, y2 } = this;\n        return x1 <= x && x <= x2 && y1 <= y && y <= y2;\n    }\n}\nclass PathParser extends svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData {\n    constructor(path){\n        super(path // Fix spaces after signs.\n        .replace(/([+\\-.])\\s+/gm, \"$1\") // Remove invalid part.\n        .replace(/[^MmZzLlHhVvCcSsQqTtAae\\d\\s.,+-].*/g, \"\"));\n        this.control = null;\n        this.start = null;\n        this.current = null;\n        this.command = null;\n        this.commands = this.commands;\n        this.i = -1;\n        this.previousCommand = null;\n        this.points = [];\n        this.angles = [];\n    }\n    reset() {\n        this.i = -1;\n        this.command = null;\n        this.previousCommand = null;\n        this.start = new Point(0, 0);\n        this.control = new Point(0, 0);\n        this.current = new Point(0, 0);\n        this.points = [];\n        this.angles = [];\n    }\n    isEnd() {\n        var { i, commands } = this;\n        return i >= commands.length - 1;\n    }\n    next() {\n        var command = this.commands[++this.i];\n        this.previousCommand = this.command;\n        this.command = command;\n        return command;\n    }\n    getPoint() {\n        var xProp = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"x\";\n        var yProp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"y\";\n        var point = new Point(this.command[xProp], this.command[yProp]);\n        return this.makeAbsolute(point);\n    }\n    getAsControlPoint(xProp, yProp) {\n        var point = this.getPoint(xProp, yProp);\n        this.control = point;\n        return point;\n    }\n    getAsCurrentPoint(xProp, yProp) {\n        var point = this.getPoint(xProp, yProp);\n        this.current = point;\n        return point;\n    }\n    getReflectedControlPoint() {\n        var previousCommand = this.previousCommand.type;\n        if (previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.SMOOTH_CURVE_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.QUAD_TO && previousCommand !== svg_pathdata__WEBPACK_IMPORTED_MODULE_17__.SVGPathData.SMOOTH_QUAD_TO) {\n            return this.current;\n        } // reflect point\n        var { current: { x: cx, y: cy }, control: { x: ox, y: oy } } = this;\n        var point = new Point(2 * cx - ox, 2 * cy - oy);\n        return point;\n    }\n    makeAbsolute(point) {\n        if (this.command.relative) {\n            var { x, y } = this.current;\n            point.x += x;\n            point.y += y;\n        }\n        return point;\n    }\n    addMarker(point, from, priorTo) {\n        var { points, angles } = this; // if the last angle isn't filled in because we didn't have this point yet ...\n        if (priorTo && angles.length > 0 && !angles[angles.length - 1]) {\n            angles[angles.length - 1] = points[points.length - 1].angleTo(priorTo);\n        }\n        this.addMarkerAngle(point, from ? from.angleTo(point) : null);\n    }\n    addMarkerAngle(point, angle) {\n        this.points.push(point);\n        this.angles.push(angle);\n    }\n    getMarkerPoints() {\n        return this.points;\n    }\n    getMarkerAngles() {\n        var { angles } = this;\n        var len = angles.length;\n        for(var i = 0; i < len; i++){\n            if (!angles[i]) {\n                for(var j = i + 1; j < len; j++){\n                    if (angles[j]) {\n                        angles[i] = angles[j];\n                        break;\n                    }\n                }\n            }\n        }\n        return angles;\n    }\n}\nclass RenderedElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.modifiedEmSizeStack = false;\n    }\n    calculateOpacity() {\n        var opacity = 1.0; // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        var element = this;\n        while(element){\n            var opacityStyle = element.getStyle(\"opacity\", false, true); // no ancestors on style call\n            if (opacityStyle.hasValue(true)) {\n                opacity *= opacityStyle.getNumber();\n            }\n            element = element.parent;\n        }\n        return opacity;\n    }\n    setContext(ctx) {\n        var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        if (!fromMeasure) {\n            // causes stack overflow when measuring text with gradients\n            // fill\n            var fillStyleProp = this.getStyle(\"fill\");\n            var fillOpacityStyleProp = this.getStyle(\"fill-opacity\");\n            var strokeStyleProp = this.getStyle(\"stroke\");\n            var strokeOpacityProp = this.getStyle(\"stroke-opacity\");\n            if (fillStyleProp.isUrlDefinition()) {\n                var fillStyle = fillStyleProp.getFillStyleDefinition(this, fillOpacityStyleProp);\n                if (fillStyle) {\n                    ctx.fillStyle = fillStyle;\n                }\n            } else if (fillStyleProp.hasValue()) {\n                if (fillStyleProp.getString() === \"currentColor\") {\n                    fillStyleProp.setValue(this.getStyle(\"color\").getColor());\n                }\n                var _fillStyle = fillStyleProp.getColor();\n                if (_fillStyle !== \"inherit\") {\n                    ctx.fillStyle = _fillStyle === \"none\" ? \"rgba(0,0,0,0)\" : _fillStyle;\n                }\n            }\n            if (fillOpacityStyleProp.hasValue()) {\n                var _fillStyle2 = new Property(this.document, \"fill\", ctx.fillStyle).addOpacity(fillOpacityStyleProp).getColor();\n                ctx.fillStyle = _fillStyle2;\n            } // stroke\n            if (strokeStyleProp.isUrlDefinition()) {\n                var strokeStyle = strokeStyleProp.getFillStyleDefinition(this, strokeOpacityProp);\n                if (strokeStyle) {\n                    ctx.strokeStyle = strokeStyle;\n                }\n            } else if (strokeStyleProp.hasValue()) {\n                if (strokeStyleProp.getString() === \"currentColor\") {\n                    strokeStyleProp.setValue(this.getStyle(\"color\").getColor());\n                }\n                var _strokeStyle = strokeStyleProp.getString();\n                if (_strokeStyle !== \"inherit\") {\n                    ctx.strokeStyle = _strokeStyle === \"none\" ? \"rgba(0,0,0,0)\" : _strokeStyle;\n                }\n            }\n            if (strokeOpacityProp.hasValue()) {\n                var _strokeStyle2 = new Property(this.document, \"stroke\", ctx.strokeStyle).addOpacity(strokeOpacityProp).getString();\n                ctx.strokeStyle = _strokeStyle2;\n            }\n            var strokeWidthStyleProp = this.getStyle(\"stroke-width\");\n            if (strokeWidthStyleProp.hasValue()) {\n                var newLineWidth = strokeWidthStyleProp.getPixels();\n                ctx.lineWidth = !newLineWidth ? PSEUDO_ZERO // browsers don't respect 0 (or node-canvas? :-)\n                 : newLineWidth;\n            }\n            var strokeLinecapStyleProp = this.getStyle(\"stroke-linecap\");\n            var strokeLinejoinStyleProp = this.getStyle(\"stroke-linejoin\");\n            var strokeMiterlimitProp = this.getStyle(\"stroke-miterlimit\"); // NEED TEST\n            // const pointOrderStyleProp = this.getStyle('paint-order');\n            var strokeDasharrayStyleProp = this.getStyle(\"stroke-dasharray\");\n            var strokeDashoffsetProp = this.getStyle(\"stroke-dashoffset\");\n            if (strokeLinecapStyleProp.hasValue()) {\n                ctx.lineCap = strokeLinecapStyleProp.getString();\n            }\n            if (strokeLinejoinStyleProp.hasValue()) {\n                ctx.lineJoin = strokeLinejoinStyleProp.getString();\n            }\n            if (strokeMiterlimitProp.hasValue()) {\n                ctx.miterLimit = strokeMiterlimitProp.getNumber();\n            } // NEED TEST\n            // if (pointOrderStyleProp.hasValue()) {\n            // \t// ?\n            // \tctx.paintOrder = pointOrderStyleProp.getValue();\n            // }\n            if (strokeDasharrayStyleProp.hasValue() && strokeDasharrayStyleProp.getString() !== \"none\") {\n                var gaps = toNumbers(strokeDasharrayStyleProp.getString());\n                if (typeof ctx.setLineDash !== \"undefined\") {\n                    ctx.setLineDash(gaps);\n                } else if (typeof ctx.webkitLineDash !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDash = gaps;\n                } else if (typeof ctx.mozDash !== \"undefined\" && !(gaps.length === 1 && gaps[0] === 0)) {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDash = gaps;\n                }\n                var offset = strokeDashoffsetProp.getPixels();\n                if (typeof ctx.lineDashOffset !== \"undefined\") {\n                    ctx.lineDashOffset = offset;\n                } else if (typeof ctx.webkitLineDashOffset !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.webkitLineDashOffset = offset;\n                } else if (typeof ctx.mozDashOffset !== \"undefined\") {\n                    // @ts-expect-error Handle browser prefix.\n                    ctx.mozDashOffset = offset;\n                }\n            }\n        } // font\n        this.modifiedEmSizeStack = false;\n        if (typeof ctx.font !== \"undefined\") {\n            var fontStyleProp = this.getStyle(\"font\");\n            var fontStyleStyleProp = this.getStyle(\"font-style\");\n            var fontVariantStyleProp = this.getStyle(\"font-variant\");\n            var fontWeightStyleProp = this.getStyle(\"font-weight\");\n            var fontSizeStyleProp = this.getStyle(\"font-size\");\n            var fontFamilyStyleProp = this.getStyle(\"font-family\");\n            var font = new Font(fontStyleStyleProp.getString(), fontVariantStyleProp.getString(), fontWeightStyleProp.getString(), fontSizeStyleProp.hasValue() ? \"\".concat(fontSizeStyleProp.getPixels(true), \"px\") : \"\", fontFamilyStyleProp.getString(), Font.parse(fontStyleProp.getString(), ctx.font));\n            fontStyleStyleProp.setValue(font.fontStyle);\n            fontVariantStyleProp.setValue(font.fontVariant);\n            fontWeightStyleProp.setValue(font.fontWeight);\n            fontSizeStyleProp.setValue(font.fontSize);\n            fontFamilyStyleProp.setValue(font.fontFamily);\n            ctx.font = font.toString();\n            if (fontSizeStyleProp.isPixels()) {\n                this.document.emSize = fontSizeStyleProp.getPixels();\n                this.modifiedEmSizeStack = true;\n            }\n        }\n        if (!fromMeasure) {\n            // effects\n            this.applyEffects(ctx); // opacity\n            ctx.globalAlpha = this.calculateOpacity();\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        if (this.modifiedEmSizeStack) {\n            this.document.popEmSize();\n        }\n    }\n}\nclass PathElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"path\";\n        this.pathParser = null;\n        this.pathParser = new PathParser(this.getAttribute(\"d\").getString());\n    }\n    path(ctx) {\n        var { pathParser } = this;\n        var boundingBox = new BoundingBox();\n        pathParser.reset();\n        if (ctx) {\n            ctx.beginPath();\n        }\n        while(!pathParser.isEnd()){\n            switch(pathParser.next().type){\n                case PathParser.MOVE_TO:\n                    this.pathM(ctx, boundingBox);\n                    break;\n                case PathParser.LINE_TO:\n                    this.pathL(ctx, boundingBox);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    this.pathH(ctx, boundingBox);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    this.pathV(ctx, boundingBox);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    this.pathS(ctx, boundingBox);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(ctx, boundingBox);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    this.pathT(ctx, boundingBox);\n                    break;\n                case PathParser.ARC:\n                    this.pathA(ctx, boundingBox);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    this.pathZ(ctx, boundingBox);\n                    break;\n            }\n        }\n        return boundingBox;\n    }\n    getBoundingBox(_) {\n        return this.path();\n    }\n    getMarkers() {\n        var { pathParser } = this;\n        var points = pathParser.getMarkerPoints();\n        var angles = pathParser.getMarkerAngles();\n        var markers = points.map((point, i)=>[\n                point,\n                angles[i]\n            ]);\n        return markers;\n    }\n    renderChildren(ctx) {\n        this.path(ctx);\n        this.document.screen.mouse.checkPath(this, ctx);\n        var fillRuleStyleProp = this.getStyle(\"fill-rule\");\n        if (ctx.fillStyle !== \"\") {\n            if (fillRuleStyleProp.getString(\"inherit\") !== \"inherit\") {\n                ctx.fill(fillRuleStyleProp.getString());\n            } else {\n                ctx.fill();\n            }\n        }\n        if (ctx.strokeStyle !== \"\") {\n            if (this.getAttribute(\"vector-effect\").getString() === \"non-scaling-stroke\") {\n                ctx.save();\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\n                ctx.stroke();\n                ctx.restore();\n            } else {\n                ctx.stroke();\n            }\n        }\n        var markers = this.getMarkers();\n        if (markers) {\n            var markersLastIndex = markers.length - 1;\n            var markerStartStyleProp = this.getStyle(\"marker-start\");\n            var markerMidStyleProp = this.getStyle(\"marker-mid\");\n            var markerEndStyleProp = this.getStyle(\"marker-end\");\n            if (markerStartStyleProp.isUrlDefinition()) {\n                var marker = markerStartStyleProp.getDefinition();\n                var [point, angle] = markers[0];\n                marker.render(ctx, point, angle);\n            }\n            if (markerMidStyleProp.isUrlDefinition()) {\n                var _marker = markerMidStyleProp.getDefinition();\n                for(var i = 1; i < markersLastIndex; i++){\n                    var [_point, _angle] = markers[i];\n                    _marker.render(ctx, _point, _angle);\n                }\n            }\n            if (markerEndStyleProp.isUrlDefinition()) {\n                var _marker2 = markerEndStyleProp.getDefinition();\n                var [_point2, _angle2] = markers[markersLastIndex];\n                _marker2.render(ctx, _point2, _angle2);\n            }\n        }\n    }\n    static pathM(pathParser) {\n        var point = pathParser.getAsCurrentPoint();\n        pathParser.start = pathParser.current;\n        return {\n            point\n        };\n    }\n    pathM(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { point } = PathElement.pathM(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.moveTo(x, y);\n        }\n    }\n    static pathL(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point\n        };\n    }\n    pathL(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathL(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathH(pathParser) {\n        var { current, command } = pathParser;\n        var point = new Point((command.relative ? current.x : 0) + command.x, current.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathH(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathH(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathV(pathParser) {\n        var { current, command } = pathParser;\n        var point = new Point(current.x, (command.relative ? current.y : 0) + command.y);\n        pathParser.current = point;\n        return {\n            current,\n            point\n        };\n    }\n    pathV(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point } = PathElement.pathV(pathParser);\n        var { x, y } = point;\n        pathParser.addMarker(point, current);\n        boundingBox.addPoint(x, y);\n        if (ctx) {\n            ctx.lineTo(x, y);\n        }\n    }\n    static pathC(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getPoint(\"x1\", \"y1\");\n        var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathC(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point, controlPoint, currentPoint } = PathElement.pathC(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathS(pathParser) {\n        var { current } = pathParser;\n        var point = pathParser.getReflectedControlPoint();\n        var controlPoint = pathParser.getAsControlPoint(\"x2\", \"y2\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            point,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathS(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, point, controlPoint, currentPoint } = PathElement.pathS(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, point);\n        boundingBox.addBezierCurve(current.x, current.y, point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.bezierCurveTo(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathQ(pathParser) {\n        var { current } = pathParser;\n        var controlPoint = pathParser.getAsControlPoint(\"x1\", \"y1\");\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathQ(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, controlPoint, currentPoint } = PathElement.pathQ(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathT(pathParser) {\n        var { current } = pathParser;\n        var controlPoint = pathParser.getReflectedControlPoint();\n        pathParser.control = controlPoint;\n        var currentPoint = pathParser.getAsCurrentPoint();\n        return {\n            current,\n            controlPoint,\n            currentPoint\n        };\n    }\n    pathT(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { current, controlPoint, currentPoint } = PathElement.pathT(pathParser);\n        pathParser.addMarker(currentPoint, controlPoint, controlPoint);\n        boundingBox.addQuadraticCurve(current.x, current.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        if (ctx) {\n            ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        }\n    }\n    static pathA(pathParser) {\n        var { current, command } = pathParser;\n        var { rX, rY, xRot, lArcFlag, sweepFlag } = command;\n        var xAxisRotation = xRot * (Math.PI / 180.0);\n        var currentPoint = pathParser.getAsCurrentPoint(); // Conversion from endpoint to center parameterization\n        // http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n        // x1', y1'\n        var currp = new Point(Math.cos(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.sin(xAxisRotation) * (current.y - currentPoint.y) / 2.0, -Math.sin(xAxisRotation) * (current.x - currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * (current.y - currentPoint.y) / 2.0); // adjust radii\n        var l = Math.pow(currp.x, 2) / Math.pow(rX, 2) + Math.pow(currp.y, 2) / Math.pow(rY, 2);\n        if (l > 1) {\n            rX *= Math.sqrt(l);\n            rY *= Math.sqrt(l);\n        } // cx', cy'\n        var s = (lArcFlag === sweepFlag ? -1 : 1) * Math.sqrt((Math.pow(rX, 2) * Math.pow(rY, 2) - Math.pow(rX, 2) * Math.pow(currp.y, 2) - Math.pow(rY, 2) * Math.pow(currp.x, 2)) / (Math.pow(rX, 2) * Math.pow(currp.y, 2) + Math.pow(rY, 2) * Math.pow(currp.x, 2)));\n        if (isNaN(s)) {\n            s = 0;\n        }\n        var cpp = new Point(s * rX * currp.y / rY, s * -rY * currp.x / rX); // cx, cy\n        var centp = new Point((current.x + currentPoint.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (current.y + currentPoint.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y); // initial angle\n        var a1 = vectorsAngle([\n            1,\n            0\n        ], [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ]); // θ1\n        // angle delta\n        var u = [\n            (currp.x - cpp.x) / rX,\n            (currp.y - cpp.y) / rY\n        ];\n        var v = [\n            (-currp.x - cpp.x) / rX,\n            (-currp.y - cpp.y) / rY\n        ];\n        var ad = vectorsAngle(u, v); // Δθ\n        if (vectorsRatio(u, v) <= -1) {\n            ad = Math.PI;\n        }\n        if (vectorsRatio(u, v) >= 1) {\n            ad = 0;\n        }\n        return {\n            currentPoint,\n            rX,\n            rY,\n            sweepFlag,\n            xAxisRotation,\n            centp,\n            a1,\n            ad\n        };\n    }\n    pathA(ctx, boundingBox) {\n        var { pathParser } = this;\n        var { currentPoint, rX, rY, sweepFlag, xAxisRotation, centp, a1, ad } = PathElement.pathA(pathParser); // for markers\n        var dir = 1 - sweepFlag ? 1.0 : -1.0;\n        var ah = a1 + dir * (ad / 2.0);\n        var halfWay = new Point(centp.x + rX * Math.cos(ah), centp.y + rY * Math.sin(ah));\n        pathParser.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);\n        pathParser.addMarkerAngle(currentPoint, ah - dir * Math.PI);\n        boundingBox.addPoint(currentPoint.x, currentPoint.y); // TODO: this is too naive, make it better\n        if (ctx && !isNaN(a1) && !isNaN(ad)) {\n            var r = rX > rY ? rX : rY;\n            var sx = rX > rY ? 1 : rX / rY;\n            var sy = rX > rY ? rY / rX : 1;\n            ctx.translate(centp.x, centp.y);\n            ctx.rotate(xAxisRotation);\n            ctx.scale(sx, sy);\n            ctx.arc(0, 0, r, a1, a1 + ad, Boolean(1 - sweepFlag));\n            ctx.scale(1 / sx, 1 / sy);\n            ctx.rotate(-xAxisRotation);\n            ctx.translate(-centp.x, -centp.y);\n        }\n    }\n    static pathZ(pathParser) {\n        pathParser.current = pathParser.start;\n    }\n    pathZ(ctx, boundingBox) {\n        PathElement.pathZ(this.pathParser);\n        if (ctx) {\n            // only close path if it is not a straight line\n            if (boundingBox.x1 !== boundingBox.x2 && boundingBox.y1 !== boundingBox.y2) {\n                ctx.closePath();\n            }\n        }\n    }\n}\nclass GlyphElement extends PathElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"glyph\";\n        this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber();\n        this.unicode = this.getAttribute(\"unicode\").getString();\n        this.arabicForm = this.getAttribute(\"arabic-form\").getString();\n    }\n}\nclass TextElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, new.target === TextElement ? true : captureTextNodes);\n        this.type = \"text\";\n        this.x = 0;\n        this.y = 0;\n        this.measureCache = -1;\n    }\n    setContext(ctx) {\n        var fromMeasure = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        super.setContext(ctx, fromMeasure);\n        var textBaseline = this.getStyle(\"dominant-baseline\").getTextBaseline() || this.getStyle(\"alignment-baseline\").getTextBaseline();\n        if (textBaseline) {\n            ctx.textBaseline = textBaseline;\n        }\n    }\n    initializeCoordinates() {\n        this.x = 0;\n        this.y = 0;\n        this.leafTexts = [];\n        this.textChunkStart = 0;\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n    }\n    getBoundingBox(ctx) {\n        if (this.type !== \"text\") {\n            return this.getTElementBoundingBox(ctx);\n        } // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx);\n        var boundingBox = null; // then calculate bounding box\n        this.children.forEach((_, i)=>{\n            var childBoundingBox = this.getChildBoundingBox(ctx, this, this, i);\n            if (!boundingBox) {\n                boundingBox = childBoundingBox;\n            } else {\n                boundingBox.addBoundingBox(childBoundingBox);\n            }\n        });\n        return boundingBox;\n    }\n    getFontSize() {\n        var { document: document1, parent } = this;\n        var inheritFontSize = Font.parse(document1.ctx.font).fontSize;\n        var fontSize = parent.getStyle(\"font-size\").getNumber(inheritFontSize);\n        return fontSize;\n    }\n    getTElementBoundingBox(ctx) {\n        var fontSize = this.getFontSize();\n        return new BoundingBox(this.x, this.y - fontSize, this.x + this.measureText(ctx), this.y);\n    }\n    getGlyph(font, text, i) {\n        var char = text[i];\n        var glyph = null;\n        if (font.isArabic) {\n            var len = text.length;\n            var prevChar = text[i - 1];\n            var nextChar = text[i + 1];\n            var arabicForm = \"isolated\";\n            if ((i === 0 || prevChar === \" \") && i < len - 1 && nextChar !== \" \") {\n                arabicForm = \"terminal\";\n            }\n            if (i > 0 && prevChar !== \" \" && i < len - 1 && nextChar !== \" \") {\n                arabicForm = \"medial\";\n            }\n            if (i > 0 && prevChar !== \" \" && (i === len - 1 || nextChar === \" \")) {\n                arabicForm = \"initial\";\n            }\n            if (typeof font.glyphs[char] !== \"undefined\") {\n                // NEED TEST\n                var maybeGlyph = font.glyphs[char];\n                glyph = maybeGlyph instanceof GlyphElement ? maybeGlyph : maybeGlyph[arabicForm];\n            }\n        } else {\n            glyph = font.glyphs[char];\n        }\n        if (!glyph) {\n            glyph = font.missingGlyph;\n        }\n        return glyph;\n    }\n    getText() {\n        return \"\";\n    }\n    getTextFromNode(node) {\n        var textNode = node || this.node;\n        var childNodes = Array.from(textNode.parentNode.childNodes);\n        var index = childNodes.indexOf(textNode);\n        var lastIndex = childNodes.length - 1;\n        var text = compressSpaces(// || textNode.text\n        textNode.textContent || \"\");\n        if (index === 0) {\n            text = trimLeft(text);\n        }\n        if (index === lastIndex) {\n            text = trimRight(text);\n        }\n        return text;\n    }\n    renderChildren(ctx) {\n        if (this.type !== \"text\") {\n            this.renderTElementChildren(ctx);\n            return;\n        } // first, calculate child positions\n        this.initializeCoordinates();\n        this.adjustChildCoordinatesRecursive(ctx); // then render\n        this.children.forEach((_, i)=>{\n            this.renderChild(ctx, this, this, i);\n        });\n        var { mouse } = this.document.screen; // Do not calc bounding box if mouse is not working.\n        if (mouse.isWorking()) {\n            mouse.checkBoundingBox(this, this.getBoundingBox(ctx));\n        }\n    }\n    renderTElementChildren(ctx) {\n        var { document: document1, parent } = this;\n        var renderText = this.getText();\n        var customFont = parent.getStyle(\"font-family\").getDefinition();\n        if (customFont) {\n            var { unitsPerEm } = customFont.fontFace;\n            var ctxFont = Font.parse(document1.ctx.font);\n            var fontSize = parent.getStyle(\"font-size\").getNumber(ctxFont.fontSize);\n            var fontStyle = parent.getStyle(\"font-style\").getString(ctxFont.fontStyle);\n            var scale = fontSize / unitsPerEm;\n            var text = customFont.isRTL ? renderText.split(\"\").reverse().join(\"\") : renderText;\n            var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n            var len = text.length;\n            for(var i = 0; i < len; i++){\n                var glyph = this.getGlyph(customFont, text, i);\n                ctx.translate(this.x, this.y);\n                ctx.scale(scale, -scale);\n                var lw = ctx.lineWidth;\n                ctx.lineWidth = ctx.lineWidth * unitsPerEm / fontSize;\n                if (fontStyle === \"italic\") {\n                    ctx.transform(1, 0, .4, 1, 0, 0);\n                }\n                glyph.render(ctx);\n                if (fontStyle === \"italic\") {\n                    ctx.transform(1, 0, -.4, 1, 0, 0);\n                }\n                ctx.lineWidth = lw;\n                ctx.scale(1 / scale, -1 / scale);\n                ctx.translate(-this.x, -this.y);\n                this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / unitsPerEm;\n                if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                    this.x += dx[i];\n                }\n            }\n            return;\n        }\n        var { x, y } = this; // NEED TEST\n        // if (ctx.paintOrder === 'stroke') {\n        // \tif (ctx.strokeStyle) {\n        // \t\tctx.strokeText(renderText, x, y);\n        // \t}\n        // \tif (ctx.fillStyle) {\n        // \t\tctx.fillText(renderText, x, y);\n        // \t}\n        // } else {\n        if (ctx.fillStyle) {\n            ctx.fillText(renderText, x, y);\n        }\n        if (ctx.strokeStyle) {\n            ctx.strokeText(renderText, x, y);\n        } // }\n    }\n    applyAnchoring() {\n        if (this.textChunkStart >= this.leafTexts.length) {\n            return;\n        } // This is basically the \"Apply anchoring\" part of https://www.w3.org/TR/SVG2/text.html#TextLayoutAlgorithm.\n        // The difference is that we apply the anchoring as soon as a chunk is finished. This saves some extra looping.\n        // Vertical text is not supported.\n        var firstElement = this.leafTexts[this.textChunkStart];\n        var textAnchor = firstElement.getStyle(\"text-anchor\").getString(\"start\");\n        var isRTL = false; // we treat RTL like LTR\n        var shift = 0;\n        if (textAnchor === \"start\" && !isRTL || textAnchor === \"end\" && isRTL) {\n            shift = firstElement.x - this.minX;\n        } else if (textAnchor === \"end\" && !isRTL || textAnchor === \"start\" && isRTL) {\n            shift = firstElement.x - this.maxX;\n        } else {\n            shift = firstElement.x - (this.minX + this.maxX) / 2;\n        }\n        for(var i = this.textChunkStart; i < this.leafTexts.length; i++){\n            this.leafTexts[i].x += shift;\n        } // start new chunk\n        this.minX = Number.POSITIVE_INFINITY;\n        this.maxX = Number.NEGATIVE_INFINITY;\n        this.textChunkStart = this.leafTexts.length;\n    }\n    adjustChildCoordinatesRecursive(ctx) {\n        this.children.forEach((_, i)=>{\n            this.adjustChildCoordinatesRecursiveCore(ctx, this, this, i);\n        });\n        this.applyAnchoring();\n    }\n    adjustChildCoordinatesRecursiveCore(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        if (child.children.length > 0) {\n            child.children.forEach((_, i)=>{\n                textParent.adjustChildCoordinatesRecursiveCore(ctx, textParent, child, i);\n            });\n        } else {\n            // only leafs are relevant\n            this.adjustChildCoordinates(ctx, textParent, parent, i);\n        }\n    }\n    adjustChildCoordinates(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        if (typeof child.measureText !== \"function\") {\n            return child;\n        }\n        ctx.save();\n        child.setContext(ctx, true);\n        var xAttr = child.getAttribute(\"x\");\n        var yAttr = child.getAttribute(\"y\");\n        var dxAttr = child.getAttribute(\"dx\");\n        var dyAttr = child.getAttribute(\"dy\");\n        var customFont = child.getStyle(\"font-family\").getDefinition();\n        var isRTL = Boolean(customFont) && customFont.isRTL;\n        if (i === 0) {\n            // First children inherit attributes from parent(s). Positional attributes\n            // are only inherited from a parent to it's first child.\n            if (!xAttr.hasValue()) {\n                xAttr.setValue(child.getInheritedAttribute(\"x\"));\n            }\n            if (!yAttr.hasValue()) {\n                yAttr.setValue(child.getInheritedAttribute(\"y\"));\n            }\n            if (!dxAttr.hasValue()) {\n                dxAttr.setValue(child.getInheritedAttribute(\"dx\"));\n            }\n            if (!dyAttr.hasValue()) {\n                dyAttr.setValue(child.getInheritedAttribute(\"dy\"));\n            }\n        }\n        var width = child.measureText(ctx);\n        if (isRTL) {\n            textParent.x -= width;\n        }\n        if (xAttr.hasValue()) {\n            // an \"x\" attribute marks the start of a new chunk\n            textParent.applyAnchoring();\n            child.x = xAttr.getPixels(\"x\");\n            if (dxAttr.hasValue()) {\n                child.x += dxAttr.getPixels(\"x\");\n            }\n        } else {\n            if (dxAttr.hasValue()) {\n                textParent.x += dxAttr.getPixels(\"x\");\n            }\n            child.x = textParent.x;\n        }\n        textParent.x = child.x;\n        if (!isRTL) {\n            textParent.x += width;\n        }\n        if (yAttr.hasValue()) {\n            child.y = yAttr.getPixels(\"y\");\n            if (dyAttr.hasValue()) {\n                child.y += dyAttr.getPixels(\"y\");\n            }\n        } else {\n            if (dyAttr.hasValue()) {\n                textParent.y += dyAttr.getPixels(\"y\");\n            }\n            child.y = textParent.y;\n        }\n        textParent.y = child.y; // update the current chunk and it's bounds\n        textParent.leafTexts.push(child);\n        textParent.minX = Math.min(textParent.minX, child.x, child.x + width);\n        textParent.maxX = Math.max(textParent.maxX, child.x, child.x + width);\n        child.clearContext(ctx);\n        ctx.restore();\n        return child;\n    }\n    getChildBoundingBox(ctx, textParent, parent, i) {\n        var child = parent.children[i]; // not a text node?\n        if (typeof child.getBoundingBox !== \"function\") {\n            return null;\n        }\n        var boundingBox = child.getBoundingBox(ctx);\n        if (!boundingBox) {\n            return null;\n        }\n        child.children.forEach((_, i)=>{\n            var childBoundingBox = textParent.getChildBoundingBox(ctx, textParent, child, i);\n            boundingBox.addBoundingBox(childBoundingBox);\n        });\n        return boundingBox;\n    }\n    renderChild(ctx, textParent, parent, i) {\n        var child = parent.children[i];\n        child.render(ctx);\n        child.children.forEach((_, i)=>{\n            textParent.renderChild(ctx, textParent, child, i);\n        });\n    }\n    measureText(ctx) {\n        var { measureCache } = this;\n        if (~measureCache) {\n            return measureCache;\n        }\n        var renderText = this.getText();\n        var measure = this.measureTargetText(ctx, renderText);\n        this.measureCache = measure;\n        return measure;\n    }\n    measureTargetText(ctx, targetText) {\n        if (!targetText.length) {\n            return 0;\n        }\n        var { parent } = this;\n        var customFont = parent.getStyle(\"font-family\").getDefinition();\n        if (customFont) {\n            var fontSize = this.getFontSize();\n            var text = customFont.isRTL ? targetText.split(\"\").reverse().join(\"\") : targetText;\n            var dx = toNumbers(parent.getAttribute(\"dx\").getString());\n            var len = text.length;\n            var _measure = 0;\n            for(var i = 0; i < len; i++){\n                var glyph = this.getGlyph(customFont, text, i);\n                _measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;\n                if (typeof dx[i] !== \"undefined\" && !isNaN(dx[i])) {\n                    _measure += dx[i];\n                }\n            }\n            return _measure;\n        }\n        if (!ctx.measureText) {\n            return targetText.length * 10;\n        }\n        ctx.save();\n        this.setContext(ctx, true);\n        var { width: measure } = ctx.measureText(targetText);\n        this.clearContext(ctx);\n        ctx.restore();\n        return measure;\n    }\n    /**\r\n   * Inherits positional attributes from {@link TextElement} parent(s). Attributes\r\n   * are only inherited from a parent to its first child.\r\n   * @param name - The attribute name.\r\n   * @returns The attribute value or null.\r\n   */ getInheritedAttribute(name) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias,consistent-this\n        var current = this;\n        while(current instanceof TextElement && current.isFirstChild()){\n            var parentAttr = current.parent.getAttribute(name);\n            if (parentAttr.hasValue(true)) {\n                return parentAttr.getValue(\"0\");\n            }\n            current = current.parent;\n        }\n        return null;\n    }\n}\nclass TSpanElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, new.target === TSpanElement ? true : captureTextNodes);\n        this.type = \"tspan\"; // if this node has children, then they own the text\n        this.text = this.children.length > 0 ? \"\" : this.getTextFromNode();\n    }\n    getText() {\n        return this.text;\n    }\n}\nclass TextNode extends TSpanElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"textNode\";\n    }\n}\nclass SVGElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"svg\";\n        this.root = false;\n    }\n    setContext(ctx) {\n        var _this$node$parentNode;\n        var { document: document1 } = this;\n        var { screen, window: window1 } = document1;\n        var canvas = ctx.canvas;\n        screen.setDefaults(ctx);\n        if (canvas.style && typeof ctx.font !== \"undefined\" && window1 && typeof window1.getComputedStyle !== \"undefined\") {\n            ctx.font = window1.getComputedStyle(canvas).getPropertyValue(\"font\");\n            var fontSizeProp = new Property(document1, \"fontSize\", Font.parse(ctx.font).fontSize);\n            if (fontSizeProp.hasValue()) {\n                document1.rootEmSize = fontSizeProp.getPixels(\"y\");\n                document1.emSize = document1.rootEmSize;\n            }\n        } // create new view port\n        if (!this.getAttribute(\"x\").hasValue()) {\n            this.getAttribute(\"x\", true).setValue(0);\n        }\n        if (!this.getAttribute(\"y\").hasValue()) {\n            this.getAttribute(\"y\", true).setValue(0);\n        }\n        var { width, height } = screen.viewPort;\n        if (!this.getStyle(\"width\").hasValue()) {\n            this.getStyle(\"width\", true).setValue(\"100%\");\n        }\n        if (!this.getStyle(\"height\").hasValue()) {\n            this.getStyle(\"height\", true).setValue(\"100%\");\n        }\n        if (!this.getStyle(\"color\").hasValue()) {\n            this.getStyle(\"color\", true).setValue(\"black\");\n        }\n        var refXAttr = this.getAttribute(\"refX\");\n        var refYAttr = this.getAttribute(\"refY\");\n        var viewBoxAttr = this.getAttribute(\"viewBox\");\n        var viewBox = viewBoxAttr.hasValue() ? toNumbers(viewBoxAttr.getString()) : null;\n        var clip = !this.root && this.getStyle(\"overflow\").getValue(\"hidden\") !== \"visible\";\n        var minX = 0;\n        var minY = 0;\n        var clipX = 0;\n        var clipY = 0;\n        if (viewBox) {\n            minX = viewBox[0];\n            minY = viewBox[1];\n        }\n        if (!this.root) {\n            width = this.getStyle(\"width\").getPixels(\"x\");\n            height = this.getStyle(\"height\").getPixels(\"y\");\n            if (this.type === \"marker\") {\n                clipX = minX;\n                clipY = minY;\n                minX = 0;\n                minY = 0;\n            }\n        }\n        screen.viewPort.setCurrent(width, height); // Default value of transform-origin is center only for root SVG elements\n        // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/transform-origin\n        if (this.node // is not temporary SVGElement\n         && (!this.parent || ((_this$node$parentNode = this.node.parentNode) === null || _this$node$parentNode === void 0 ? void 0 : _this$node$parentNode.nodeName) === \"foreignObject\") && this.getStyle(\"transform\", false, true).hasValue() && !this.getStyle(\"transform-origin\", false, true).hasValue()) {\n            this.getStyle(\"transform-origin\", true, true).setValue(\"50% 50%\");\n        }\n        super.setContext(ctx);\n        ctx.translate(this.getAttribute(\"x\").getPixels(\"x\"), this.getAttribute(\"y\").getPixels(\"y\"));\n        if (viewBox) {\n            width = viewBox[2];\n            height = viewBox[3];\n        }\n        document1.setViewBox({\n            ctx,\n            aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n            width: screen.viewPort.width,\n            desiredWidth: width,\n            height: screen.viewPort.height,\n            desiredHeight: height,\n            minX,\n            minY,\n            refX: refXAttr.getValue(),\n            refY: refYAttr.getValue(),\n            clip,\n            clipX,\n            clipY\n        });\n        if (viewBox) {\n            screen.viewPort.removeCurrent();\n            screen.viewPort.setCurrent(width, height);\n        }\n    }\n    clearContext(ctx) {\n        super.clearContext(ctx);\n        this.document.screen.viewPort.removeCurrent();\n    }\n    /**\r\n   * Resize SVG to fit in given size.\r\n   * @param width\r\n   * @param height\r\n   * @param preserveAspectRatio\r\n   */ resize(width) {\n        var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        var widthAttr = this.getAttribute(\"width\", true);\n        var heightAttr = this.getAttribute(\"height\", true);\n        var viewBoxAttr = this.getAttribute(\"viewBox\");\n        var styleAttr = this.getAttribute(\"style\");\n        var originWidth = widthAttr.getNumber(0);\n        var originHeight = heightAttr.getNumber(0);\n        if (preserveAspectRatio) {\n            if (typeof preserveAspectRatio === \"string\") {\n                this.getAttribute(\"preserveAspectRatio\", true).setValue(preserveAspectRatio);\n            } else {\n                var preserveAspectRatioAttr = this.getAttribute(\"preserveAspectRatio\");\n                if (preserveAspectRatioAttr.hasValue()) {\n                    preserveAspectRatioAttr.setValue(preserveAspectRatioAttr.getString().replace(/^\\s*(\\S.*\\S)\\s*$/, \"$1\"));\n                }\n            }\n        }\n        widthAttr.setValue(width);\n        heightAttr.setValue(height);\n        if (!viewBoxAttr.hasValue()) {\n            viewBoxAttr.setValue(\"0 0 \".concat(originWidth || width, \" \").concat(originHeight || height));\n        }\n        if (styleAttr.hasValue()) {\n            var widthStyle = this.getStyle(\"width\");\n            var heightStyle = this.getStyle(\"height\");\n            if (widthStyle.hasValue()) {\n                widthStyle.setValue(\"\".concat(width, \"px\"));\n            }\n            if (heightStyle.hasValue()) {\n                heightStyle.setValue(\"\".concat(height, \"px\"));\n            }\n        }\n    }\n}\nclass RectElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"rect\";\n    }\n    path(ctx) {\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\", false, true).getPixels(\"x\");\n        var height = this.getStyle(\"height\", false, true).getPixels(\"y\");\n        var rxAttr = this.getAttribute(\"rx\");\n        var ryAttr = this.getAttribute(\"ry\");\n        var rx = rxAttr.getPixels(\"x\");\n        var ry = ryAttr.getPixels(\"y\");\n        if (rxAttr.hasValue() && !ryAttr.hasValue()) {\n            ry = rx;\n        }\n        if (ryAttr.hasValue() && !rxAttr.hasValue()) {\n            rx = ry;\n        }\n        rx = Math.min(rx, width / 2.0);\n        ry = Math.min(ry, height / 2.0);\n        if (ctx) {\n            var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n            ctx.beginPath(); // always start the path so we don't fill prior paths\n            if (height > 0 && width > 0) {\n                ctx.moveTo(x + rx, y);\n                ctx.lineTo(x + width - rx, y);\n                ctx.bezierCurveTo(x + width - rx + KAPPA * rx, y, x + width, y + ry - KAPPA * ry, x + width, y + ry);\n                ctx.lineTo(x + width, y + height - ry);\n                ctx.bezierCurveTo(x + width, y + height - ry + KAPPA * ry, x + width - rx + KAPPA * rx, y + height, x + width - rx, y + height);\n                ctx.lineTo(x + rx, y + height);\n                ctx.bezierCurveTo(x + rx - KAPPA * rx, y + height, x, y + height - ry + KAPPA * ry, x, y + height - ry);\n                ctx.lineTo(x, y + ry);\n                ctx.bezierCurveTo(x, y + ry - KAPPA * ry, x + rx - KAPPA * rx, y, x + rx, y);\n                ctx.closePath();\n            }\n        }\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass CircleElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"circle\";\n    }\n    path(ctx) {\n        var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n        var r = this.getAttribute(\"r\").getPixels();\n        if (ctx && r > 0) {\n            ctx.beginPath();\n            ctx.arc(cx, cy, r, 0, Math.PI * 2, false);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - r, cy - r, cx + r, cy + r);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass EllipseElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"ellipse\";\n    }\n    path(ctx) {\n        var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n        var rx = this.getAttribute(\"rx\").getPixels(\"x\");\n        var ry = this.getAttribute(\"ry\").getPixels(\"y\");\n        var cx = this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = this.getAttribute(\"cy\").getPixels(\"y\");\n        if (ctx && rx > 0 && ry > 0) {\n            ctx.beginPath();\n            ctx.moveTo(cx + rx, cy);\n            ctx.bezierCurveTo(cx + rx, cy + KAPPA * ry, cx + KAPPA * rx, cy + ry, cx, cy + ry);\n            ctx.bezierCurveTo(cx - KAPPA * rx, cy + ry, cx - rx, cy + KAPPA * ry, cx - rx, cy);\n            ctx.bezierCurveTo(cx - rx, cy - KAPPA * ry, cx - KAPPA * rx, cy - ry, cx, cy - ry);\n            ctx.bezierCurveTo(cx + KAPPA * rx, cy - ry, cx + rx, cy - KAPPA * ry, cx + rx, cy);\n            ctx.closePath();\n        }\n        return new BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);\n    }\n    getMarkers() {\n        return null;\n    }\n}\nclass LineElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"line\";\n    }\n    getPoints() {\n        return [\n            new Point(this.getAttribute(\"x1\").getPixels(\"x\"), this.getAttribute(\"y1\").getPixels(\"y\")),\n            new Point(this.getAttribute(\"x2\").getPixels(\"x\"), this.getAttribute(\"y2\").getPixels(\"y\"))\n        ];\n    }\n    path(ctx) {\n        var [{ x: x0, y: y0 }, { x: x1, y: y1 }] = this.getPoints();\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n            ctx.lineTo(x1, y1);\n        }\n        return new BoundingBox(x0, y0, x1, y1);\n    }\n    getMarkers() {\n        var [p0, p1] = this.getPoints();\n        var a = p0.angleTo(p1);\n        return [\n            [\n                p0,\n                a\n            ],\n            [\n                p1,\n                a\n            ]\n        ];\n    }\n}\nclass PolylineElement extends PathElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"polyline\";\n        this.points = [];\n        this.points = Point.parsePath(this.getAttribute(\"points\").getString());\n    }\n    path(ctx) {\n        var { points } = this;\n        var [{ x: x0, y: y0 }] = points;\n        var boundingBox = new BoundingBox(x0, y0);\n        if (ctx) {\n            ctx.beginPath();\n            ctx.moveTo(x0, y0);\n        }\n        points.forEach((_ref)=>{\n            var { x, y } = _ref;\n            boundingBox.addPoint(x, y);\n            if (ctx) {\n                ctx.lineTo(x, y);\n            }\n        });\n        return boundingBox;\n    }\n    getMarkers() {\n        var { points } = this;\n        var lastIndex = points.length - 1;\n        var markers = [];\n        points.forEach((point, i)=>{\n            if (i === lastIndex) {\n                return;\n            }\n            markers.push([\n                point,\n                point.angleTo(points[i + 1])\n            ]);\n        });\n        if (markers.length > 0) {\n            markers.push([\n                points[points.length - 1],\n                markers[markers.length - 1][1]\n            ]);\n        }\n        return markers;\n    }\n}\nclass PolygonElement extends PolylineElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"polygon\";\n    }\n    path(ctx) {\n        var boundingBox = super.path(ctx);\n        var [{ x, y }] = this.points;\n        if (ctx) {\n            ctx.lineTo(x, y);\n            ctx.closePath();\n        }\n        return boundingBox;\n    }\n}\nclass PatternElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"pattern\";\n    }\n    createPattern(ctx, _, parentOpacityProp) {\n        var width = this.getStyle(\"width\").getPixels(\"x\", true);\n        var height = this.getStyle(\"height\").getPixels(\"y\", true); // render me using a temporary svg element\n        var patternSvg = new SVGElement(this.document, null);\n        patternSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n        patternSvg.attributes.width = new Property(this.document, \"width\", \"\".concat(width, \"px\"));\n        patternSvg.attributes.height = new Property(this.document, \"height\", \"\".concat(height, \"px\"));\n        patternSvg.attributes.transform = new Property(this.document, \"transform\", this.getAttribute(\"patternTransform\").getValue());\n        patternSvg.children = this.children;\n        var patternCanvas = this.document.createCanvas(width, height);\n        var patternCtx = patternCanvas.getContext(\"2d\");\n        var xAttr = this.getAttribute(\"x\");\n        var yAttr = this.getAttribute(\"y\");\n        if (xAttr.hasValue() && yAttr.hasValue()) {\n            patternCtx.translate(xAttr.getPixels(\"x\", true), yAttr.getPixels(\"y\", true));\n        }\n        if (parentOpacityProp.hasValue()) {\n            this.styles[\"fill-opacity\"] = parentOpacityProp;\n        } else {\n            Reflect.deleteProperty(this.styles, \"fill-opacity\");\n        } // render 3x3 grid so when we transform there's no white space on edges\n        for(var x = -1; x <= 1; x++){\n            for(var y = -1; y <= 1; y++){\n                patternCtx.save();\n                patternSvg.attributes.x = new Property(this.document, \"x\", x * patternCanvas.width);\n                patternSvg.attributes.y = new Property(this.document, \"y\", y * patternCanvas.height);\n                patternSvg.render(patternCtx);\n                patternCtx.restore();\n            }\n        }\n        var pattern = ctx.createPattern(patternCanvas, \"repeat\");\n        return pattern;\n    }\n}\nclass MarkerElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"marker\";\n    }\n    render(ctx, point, angle) {\n        if (!point) {\n            return;\n        }\n        var { x, y } = point;\n        var orient = this.getAttribute(\"orient\").getString(\"auto\");\n        var markerUnits = this.getAttribute(\"markerUnits\").getString(\"strokeWidth\");\n        ctx.translate(x, y);\n        if (orient === \"auto\") {\n            ctx.rotate(angle);\n        }\n        if (markerUnits === \"strokeWidth\") {\n            ctx.scale(ctx.lineWidth, ctx.lineWidth);\n        }\n        ctx.save(); // render me using a temporary svg element\n        var markerSvg = new SVGElement(this.document, null);\n        markerSvg.type = this.type;\n        markerSvg.attributes.viewBox = new Property(this.document, \"viewBox\", this.getAttribute(\"viewBox\").getValue());\n        markerSvg.attributes.refX = new Property(this.document, \"refX\", this.getAttribute(\"refX\").getValue());\n        markerSvg.attributes.refY = new Property(this.document, \"refY\", this.getAttribute(\"refY\").getValue());\n        markerSvg.attributes.width = new Property(this.document, \"width\", this.getAttribute(\"markerWidth\").getValue());\n        markerSvg.attributes.height = new Property(this.document, \"height\", this.getAttribute(\"markerHeight\").getValue());\n        markerSvg.attributes.overflow = new Property(this.document, \"overflow\", this.getAttribute(\"overflow\").getValue());\n        markerSvg.attributes.fill = new Property(this.document, \"fill\", this.getAttribute(\"fill\").getColor(\"black\"));\n        markerSvg.attributes.stroke = new Property(this.document, \"stroke\", this.getAttribute(\"stroke\").getValue(\"none\"));\n        markerSvg.children = this.children;\n        markerSvg.render(ctx);\n        ctx.restore();\n        if (markerUnits === \"strokeWidth\") {\n            ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);\n        }\n        if (orient === \"auto\") {\n            ctx.rotate(-angle);\n        }\n        ctx.translate(-x, -y);\n    }\n}\nclass DefsElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"defs\";\n    }\n    render() {}\n}\nclass GElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"g\";\n    }\n    getBoundingBox(ctx) {\n        var boundingBox = new BoundingBox();\n        this.children.forEach((child)=>{\n            boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n        });\n        return boundingBox;\n    }\n}\nclass GradientElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.attributesToInherit = [\n            \"gradientUnits\"\n        ];\n        this.stops = [];\n        var { stops, children } = this;\n        children.forEach((child)=>{\n            if (child.type === \"stop\") {\n                stops.push(child);\n            }\n        });\n    }\n    getGradientUnits() {\n        return this.getAttribute(\"gradientUnits\").getString(\"objectBoundingBox\");\n    }\n    createGradient(ctx, element, parentOpacityProp) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias, consistent-this\n        var stopsContainer = this;\n        if (this.getHrefAttribute().hasValue()) {\n            stopsContainer = this.getHrefAttribute().getDefinition();\n            this.inheritStopContainer(stopsContainer);\n        }\n        var { stops } = stopsContainer;\n        var gradient = this.getGradient(ctx, element);\n        if (!gradient) {\n            return this.addParentOpacity(parentOpacityProp, stops[stops.length - 1].color);\n        }\n        stops.forEach((stop)=>{\n            gradient.addColorStop(stop.offset, this.addParentOpacity(parentOpacityProp, stop.color));\n        });\n        if (this.getAttribute(\"gradientTransform\").hasValue()) {\n            // render as transformed pattern on temporary canvas\n            var { document: document1 } = this;\n            var { MAX_VIRTUAL_PIXELS, viewPort } = document1.screen;\n            var [rootView] = viewPort.viewPorts;\n            var rect = new RectElement(document1, null);\n            rect.attributes.x = new Property(document1, \"x\", -MAX_VIRTUAL_PIXELS / 3.0);\n            rect.attributes.y = new Property(document1, \"y\", -MAX_VIRTUAL_PIXELS / 3.0);\n            rect.attributes.width = new Property(document1, \"width\", MAX_VIRTUAL_PIXELS);\n            rect.attributes.height = new Property(document1, \"height\", MAX_VIRTUAL_PIXELS);\n            var group = new GElement(document1, null);\n            group.attributes.transform = new Property(document1, \"transform\", this.getAttribute(\"gradientTransform\").getValue());\n            group.children = [\n                rect\n            ];\n            var patternSvg = new SVGElement(document1, null);\n            patternSvg.attributes.x = new Property(document1, \"x\", 0);\n            patternSvg.attributes.y = new Property(document1, \"y\", 0);\n            patternSvg.attributes.width = new Property(document1, \"width\", rootView.width);\n            patternSvg.attributes.height = new Property(document1, \"height\", rootView.height);\n            patternSvg.children = [\n                group\n            ];\n            var patternCanvas = document1.createCanvas(rootView.width, rootView.height);\n            var patternCtx = patternCanvas.getContext(\"2d\");\n            patternCtx.fillStyle = gradient;\n            patternSvg.render(patternCtx);\n            return patternCtx.createPattern(patternCanvas, \"no-repeat\");\n        }\n        return gradient;\n    }\n    inheritStopContainer(stopsContainer) {\n        this.attributesToInherit.forEach((attributeToInherit)=>{\n            if (!this.getAttribute(attributeToInherit).hasValue() && stopsContainer.getAttribute(attributeToInherit).hasValue()) {\n                this.getAttribute(attributeToInherit, true).setValue(stopsContainer.getAttribute(attributeToInherit).getValue());\n            }\n        });\n    }\n    addParentOpacity(parentOpacityProp, color) {\n        if (parentOpacityProp.hasValue()) {\n            var colorProp = new Property(this.document, \"color\", color);\n            return colorProp.addOpacity(parentOpacityProp).getColor();\n        }\n        return color;\n    }\n}\nclass LinearGradientElement extends GradientElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"linearGradient\";\n        this.attributesToInherit.push(\"x1\", \"y1\", \"x2\", \"y2\");\n    }\n    getGradient(ctx, element) {\n        var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n        var boundingBox = isBoundingBoxUnits ? element.getBoundingBox(ctx) : null;\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute(\"x1\").hasValue() && !this.getAttribute(\"y1\").hasValue() && !this.getAttribute(\"x2\").hasValue() && !this.getAttribute(\"y2\").hasValue()) {\n            this.getAttribute(\"x1\", true).setValue(0);\n            this.getAttribute(\"y1\", true).setValue(0);\n            this.getAttribute(\"x2\", true).setValue(1);\n            this.getAttribute(\"y2\", true).setValue(0);\n        }\n        var x1 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x1\").getNumber() : this.getAttribute(\"x1\").getPixels(\"x\");\n        var y1 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y1\").getNumber() : this.getAttribute(\"y1\").getPixels(\"y\");\n        var x2 = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"x2\").getNumber() : this.getAttribute(\"x2\").getPixels(\"x\");\n        var y2 = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"y2\").getNumber() : this.getAttribute(\"y2\").getPixels(\"y\");\n        if (x1 === x2 && y1 === y2) {\n            return null;\n        }\n        return ctx.createLinearGradient(x1, y1, x2, y2);\n    }\n}\nclass RadialGradientElement extends GradientElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"radialGradient\";\n        this.attributesToInherit.push(\"cx\", \"cy\", \"r\", \"fx\", \"fy\", \"fr\");\n    }\n    getGradient(ctx, element) {\n        var isBoundingBoxUnits = this.getGradientUnits() === \"objectBoundingBox\";\n        var boundingBox = element.getBoundingBox(ctx);\n        if (isBoundingBoxUnits && !boundingBox) {\n            return null;\n        }\n        if (!this.getAttribute(\"cx\").hasValue()) {\n            this.getAttribute(\"cx\", true).setValue(\"50%\");\n        }\n        if (!this.getAttribute(\"cy\").hasValue()) {\n            this.getAttribute(\"cy\", true).setValue(\"50%\");\n        }\n        if (!this.getAttribute(\"r\").hasValue()) {\n            this.getAttribute(\"r\", true).setValue(\"50%\");\n        }\n        var cx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"cx\").getNumber() : this.getAttribute(\"cx\").getPixels(\"x\");\n        var cy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"cy\").getNumber() : this.getAttribute(\"cy\").getPixels(\"y\");\n        var fx = cx;\n        var fy = cy;\n        if (this.getAttribute(\"fx\").hasValue()) {\n            fx = isBoundingBoxUnits ? boundingBox.x + boundingBox.width * this.getAttribute(\"fx\").getNumber() : this.getAttribute(\"fx\").getPixels(\"x\");\n        }\n        if (this.getAttribute(\"fy\").hasValue()) {\n            fy = isBoundingBoxUnits ? boundingBox.y + boundingBox.height * this.getAttribute(\"fy\").getNumber() : this.getAttribute(\"fy\").getPixels(\"y\");\n        }\n        var r = isBoundingBoxUnits ? (boundingBox.width + boundingBox.height) / 2.0 * this.getAttribute(\"r\").getNumber() : this.getAttribute(\"r\").getPixels();\n        var fr = this.getAttribute(\"fr\").getPixels();\n        return ctx.createRadialGradient(fx, fy, fr, cx, cy, r);\n    }\n}\nclass StopElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"stop\";\n        var offset = Math.max(0, Math.min(1, this.getAttribute(\"offset\").getNumber()));\n        var stopOpacity = this.getStyle(\"stop-opacity\");\n        var stopColor = this.getStyle(\"stop-color\", true);\n        if (stopColor.getString() === \"\") {\n            stopColor.setValue(\"#000\");\n        }\n        if (stopOpacity.hasValue()) {\n            stopColor = stopColor.addOpacity(stopOpacity);\n        }\n        this.offset = offset;\n        this.color = stopColor.getColor();\n    }\n}\nclass AnimateElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"animate\";\n        this.duration = 0;\n        this.initialValue = null;\n        this.initialUnits = \"\";\n        this.removed = false;\n        this.frozen = false;\n        document1.screen.animations.push(this);\n        this.begin = this.getAttribute(\"begin\").getMilliseconds();\n        this.maxDuration = this.begin + this.getAttribute(\"dur\").getMilliseconds();\n        this.from = this.getAttribute(\"from\");\n        this.to = this.getAttribute(\"to\");\n        this.values = new Property(document1, \"values\", null);\n        var valuesAttr = this.getAttribute(\"values\");\n        if (valuesAttr.hasValue()) {\n            this.values.setValue(valuesAttr.getString().split(\";\"));\n        }\n    }\n    getProperty() {\n        var attributeType = this.getAttribute(\"attributeType\").getString();\n        var attributeName = this.getAttribute(\"attributeName\").getString();\n        if (attributeType === \"CSS\") {\n            return this.parent.getStyle(attributeName, true);\n        }\n        return this.parent.getAttribute(attributeName, true);\n    }\n    calcValue() {\n        var { initialUnits } = this;\n        var { progress, from, to } = this.getProgress(); // tween value linearly\n        var newValue = from.getNumber() + (to.getNumber() - from.getNumber()) * progress;\n        if (initialUnits === \"%\") {\n            newValue *= 100.0; // numValue() returns 0-1 whereas properties are 0-100\n        }\n        return \"\".concat(newValue).concat(initialUnits);\n    }\n    update(delta) {\n        var { parent } = this;\n        var prop = this.getProperty(); // set initial value\n        if (!this.initialValue) {\n            this.initialValue = prop.getString();\n            this.initialUnits = prop.getUnits();\n        } // if we're past the end time\n        if (this.duration > this.maxDuration) {\n            var fill = this.getAttribute(\"fill\").getString(\"remove\"); // loop for indefinitely repeating animations\n            if (this.getAttribute(\"repeatCount\").getString() === \"indefinite\" || this.getAttribute(\"repeatDur\").getString() === \"indefinite\") {\n                this.duration = 0;\n            } else if (fill === \"freeze\" && !this.frozen) {\n                this.frozen = true;\n                parent.animationFrozen = true;\n                parent.animationFrozenValue = prop.getString();\n            } else if (fill === \"remove\" && !this.removed) {\n                this.removed = true;\n                prop.setValue(parent.animationFrozen ? parent.animationFrozenValue : this.initialValue);\n                return true;\n            }\n            return false;\n        }\n        this.duration += delta; // if we're past the begin time\n        var updated = false;\n        if (this.begin < this.duration) {\n            var newValue = this.calcValue(); // tween\n            var typeAttr = this.getAttribute(\"type\");\n            if (typeAttr.hasValue()) {\n                // for transform, etc.\n                var type = typeAttr.getString();\n                newValue = \"\".concat(type, \"(\").concat(newValue, \")\");\n            }\n            prop.setValue(newValue);\n            updated = true;\n        }\n        return updated;\n    }\n    getProgress() {\n        var { document: document1, values } = this;\n        var result = {\n            progress: (this.duration - this.begin) / (this.maxDuration - this.begin)\n        };\n        if (values.hasValue()) {\n            var p = result.progress * (values.getValue().length - 1);\n            var lb = Math.floor(p);\n            var ub = Math.ceil(p);\n            result.from = new Property(document1, \"from\", parseFloat(values.getValue()[lb]));\n            result.to = new Property(document1, \"to\", parseFloat(values.getValue()[ub]));\n            result.progress = (p - lb) / (ub - lb);\n        } else {\n            result.from = this.from;\n            result.to = this.to;\n        }\n        return result;\n    }\n}\nclass AnimateColorElement extends AnimateElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"animateColor\";\n    }\n    calcValue() {\n        var { progress, from, to } = this.getProgress();\n        var colorFrom = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(from.getColor());\n        var colorTo = new rgbcolor__WEBPACK_IMPORTED_MODULE_13__(to.getColor());\n        if (colorFrom.ok && colorTo.ok) {\n            // tween color linearly\n            var r = colorFrom.r + (colorTo.r - colorFrom.r) * progress;\n            var g = colorFrom.g + (colorTo.g - colorFrom.g) * progress;\n            var b = colorFrom.b + (colorTo.b - colorFrom.b) * progress; // ? alpha\n            return \"rgb(\".concat(Math.floor(r), \", \").concat(Math.floor(g), \", \").concat(Math.floor(b), \")\");\n        }\n        return this.getAttribute(\"from\").getColor();\n    }\n}\nclass AnimateTransformElement extends AnimateElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"animateTransform\";\n    }\n    calcValue() {\n        var { progress, from, to } = this.getProgress(); // tween value linearly\n        var transformFrom = toNumbers(from.getString());\n        var transformTo = toNumbers(to.getString());\n        var newValue = transformFrom.map((from, i)=>{\n            var to = transformTo[i];\n            return from + (to - from) * progress;\n        }).join(\" \");\n        return newValue;\n    }\n}\nclass FontElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"font\";\n        this.glyphs = Object.create(null);\n        this.horizAdvX = this.getAttribute(\"horiz-adv-x\").getNumber();\n        var { definitions } = document1;\n        var { children } = this;\n        for (var child of children){\n            switch(child.type){\n                case \"font-face\":\n                    {\n                        this.fontFace = child;\n                        var fontFamilyStyle = child.getStyle(\"font-family\");\n                        if (fontFamilyStyle.hasValue()) {\n                            definitions[fontFamilyStyle.getString()] = this;\n                        }\n                        break;\n                    }\n                case \"missing-glyph\":\n                    this.missingGlyph = child;\n                    break;\n                case \"glyph\":\n                    {\n                        var glyph = child;\n                        if (glyph.arabicForm) {\n                            this.isRTL = true;\n                            this.isArabic = true;\n                            if (typeof this.glyphs[glyph.unicode] === \"undefined\") {\n                                this.glyphs[glyph.unicode] = Object.create(null);\n                            }\n                            this.glyphs[glyph.unicode][glyph.arabicForm] = glyph;\n                        } else {\n                            this.glyphs[glyph.unicode] = glyph;\n                        }\n                        break;\n                    }\n            }\n        }\n    }\n    render() {}\n}\nclass FontFaceElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"font-face\";\n        this.ascent = this.getAttribute(\"ascent\").getNumber();\n        this.descent = this.getAttribute(\"descent\").getNumber();\n        this.unitsPerEm = this.getAttribute(\"units-per-em\").getNumber();\n    }\n}\nclass MissingGlyphElement extends PathElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"missing-glyph\";\n        this.horizAdvX = 0;\n    }\n}\nclass TRefElement extends TextElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"tref\";\n    }\n    getText() {\n        var element = this.getHrefAttribute().getDefinition();\n        if (element) {\n            var firstChild = element.children[0];\n            if (firstChild) {\n                return firstChild.getText();\n            }\n        }\n        return \"\";\n    }\n}\nclass AElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"a\";\n        var { childNodes } = node;\n        var firstChild = childNodes[0];\n        var hasText = childNodes.length > 0 && Array.from(childNodes).every((node)=>node.nodeType === 3);\n        this.hasText = hasText;\n        this.text = hasText ? this.getTextFromNode(firstChild) : \"\";\n    }\n    getText() {\n        return this.text;\n    }\n    renderChildren(ctx) {\n        if (this.hasText) {\n            // render as text element\n            super.renderChildren(ctx);\n            var { document: document1, x, y } = this;\n            var { mouse } = document1.screen;\n            var fontSize = new Property(document1, \"fontSize\", Font.parse(document1.ctx.font).fontSize); // Do not calc bounding box if mouse is not working.\n            if (mouse.isWorking()) {\n                mouse.checkBoundingBox(this, new BoundingBox(x, y - fontSize.getPixels(\"y\"), x + this.measureText(ctx), y));\n            }\n        } else if (this.children.length > 0) {\n            // render as temporary group\n            var g = new GElement(this.document, null);\n            g.children = this.children;\n            g.parent = this;\n            g.render(ctx);\n        }\n    }\n    onClick() {\n        var { window: window1 } = this.document;\n        if (window1) {\n            window1.open(this.getHrefAttribute().getString());\n        }\n    }\n    onMouseMove() {\n        var ctx = this.document.ctx;\n        ctx.canvas.style.cursor = \"pointer\";\n    }\n}\nfunction ownKeys$2(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$2(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$2(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nclass TextPathElement extends TextElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"textPath\";\n        this.textWidth = 0;\n        this.textHeight = 0;\n        this.pathLength = -1;\n        this.glyphInfo = null;\n        this.letterSpacingCache = [];\n        this.measuresCache = new Map([\n            [\n                \"\",\n                0\n            ]\n        ]);\n        var pathElement = this.getHrefAttribute().getDefinition();\n        this.text = this.getTextFromNode();\n        this.dataArray = this.parsePathData(pathElement);\n    }\n    getText() {\n        return this.text;\n    }\n    path(ctx) {\n        var { dataArray } = this;\n        if (ctx) {\n            ctx.beginPath();\n        }\n        dataArray.forEach((_ref)=>{\n            var { type, points } = _ref;\n            switch(type){\n                case PathParser.LINE_TO:\n                    if (ctx) {\n                        ctx.lineTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.MOVE_TO:\n                    if (ctx) {\n                        ctx.moveTo(points[0], points[1]);\n                    }\n                    break;\n                case PathParser.CURVE_TO:\n                    if (ctx) {\n                        ctx.bezierCurveTo(points[0], points[1], points[2], points[3], points[4], points[5]);\n                    }\n                    break;\n                case PathParser.QUAD_TO:\n                    if (ctx) {\n                        ctx.quadraticCurveTo(points[0], points[1], points[2], points[3]);\n                    }\n                    break;\n                case PathParser.ARC:\n                    {\n                        var [cx, cy, rx, ry, theta, dTheta, psi, fs] = points;\n                        var r = rx > ry ? rx : ry;\n                        var scaleX = rx > ry ? 1 : rx / ry;\n                        var scaleY = rx > ry ? ry / rx : 1;\n                        if (ctx) {\n                            ctx.translate(cx, cy);\n                            ctx.rotate(psi);\n                            ctx.scale(scaleX, scaleY);\n                            ctx.arc(0, 0, r, theta, theta + dTheta, Boolean(1 - fs));\n                            ctx.scale(1 / scaleX, 1 / scaleY);\n                            ctx.rotate(-psi);\n                            ctx.translate(-cx, -cy);\n                        }\n                        break;\n                    }\n                case PathParser.CLOSE_PATH:\n                    if (ctx) {\n                        ctx.closePath();\n                    }\n                    break;\n            }\n        });\n    }\n    renderChildren(ctx) {\n        this.setTextData(ctx);\n        ctx.save();\n        var textDecoration = this.parent.getStyle(\"text-decoration\").getString();\n        var fontSize = this.getFontSize();\n        var { glyphInfo } = this;\n        var fill = ctx.fillStyle;\n        if (textDecoration === \"underline\") {\n            ctx.beginPath();\n        }\n        glyphInfo.forEach((glyph, i)=>{\n            var { p0, p1, rotation, text: partialText } = glyph;\n            ctx.save();\n            ctx.translate(p0.x, p0.y);\n            ctx.rotate(rotation);\n            if (ctx.fillStyle) {\n                ctx.fillText(partialText, 0, 0);\n            }\n            if (ctx.strokeStyle) {\n                ctx.strokeText(partialText, 0, 0);\n            }\n            ctx.restore();\n            if (textDecoration === \"underline\") {\n                if (i === 0) {\n                    ctx.moveTo(p0.x, p0.y + fontSize / 8);\n                }\n                ctx.lineTo(p1.x, p1.y + fontSize / 5);\n            } // // To assist with debugging visually, uncomment following\n        //\n        // ctx.beginPath();\n        // if (i % 2)\n        // \tctx.strokeStyle = 'red';\n        // else\n        // \tctx.strokeStyle = 'green';\n        // ctx.moveTo(p0.x, p0.y);\n        // ctx.lineTo(p1.x, p1.y);\n        // ctx.stroke();\n        // ctx.closePath();\n        });\n        if (textDecoration === \"underline\") {\n            ctx.lineWidth = fontSize / 20;\n            ctx.strokeStyle = fill;\n            ctx.stroke();\n            ctx.closePath();\n        }\n        ctx.restore();\n    }\n    getLetterSpacingAt() {\n        var idx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        return this.letterSpacingCache[idx] || 0;\n    }\n    findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, inputOffset, dy, c, charI) {\n        var offset = inputOffset;\n        var glyphWidth = this.measureText(ctx, c);\n        if (c === \" \" && anchor === \"justify\" && textFullWidth < fullPathWidth) {\n            glyphWidth += (fullPathWidth - textFullWidth) / spacesNumber;\n        }\n        if (charI > -1) {\n            offset += this.getLetterSpacingAt(charI);\n        }\n        var splineStep = this.textHeight / 20;\n        var p0 = this.getEquidistantPointOnPath(offset, splineStep, 0);\n        var p1 = this.getEquidistantPointOnPath(offset + glyphWidth, splineStep, 0);\n        var segment = {\n            p0,\n            p1\n        };\n        var rotation = p0 && p1 ? Math.atan2(p1.y - p0.y, p1.x - p0.x) : 0;\n        if (dy) {\n            var dyX = Math.cos(Math.PI / 2 + rotation) * dy;\n            var dyY = Math.cos(-rotation) * dy;\n            segment.p0 = _objectSpread$2(_objectSpread$2({}, p0), {}, {\n                x: p0.x + dyX,\n                y: p0.y + dyY\n            });\n            segment.p1 = _objectSpread$2(_objectSpread$2({}, p1), {}, {\n                x: p1.x + dyX,\n                y: p1.y + dyY\n            });\n        }\n        offset += glyphWidth;\n        return {\n            offset,\n            segment,\n            rotation\n        };\n    }\n    measureText(ctx, text) {\n        var { measuresCache } = this;\n        var targetText = text || this.getText();\n        if (measuresCache.has(targetText)) {\n            return measuresCache.get(targetText);\n        }\n        var measure = this.measureTargetText(ctx, targetText);\n        measuresCache.set(targetText, measure);\n        return measure;\n    }\n    // If some font will be loaded after this method call, <textPath> will not be rendered correctly.\n    // You need to call this method manually to update glyphs cache.\n    setTextData(ctx) {\n        if (this.glyphInfo) {\n            return;\n        }\n        var renderText = this.getText();\n        var chars = renderText.split(\"\");\n        var spacesNumber = renderText.split(\" \").length - 1;\n        var dx = this.parent.getAttribute(\"dx\").split().map((_)=>_.getPixels(\"x\"));\n        var dy = this.parent.getAttribute(\"dy\").getPixels(\"y\");\n        var anchor = this.parent.getStyle(\"text-anchor\").getString(\"start\");\n        var thisSpacing = this.getStyle(\"letter-spacing\");\n        var parentSpacing = this.parent.getStyle(\"letter-spacing\");\n        var letterSpacing = 0;\n        if (!thisSpacing.hasValue() || thisSpacing.getValue() === \"inherit\") {\n            letterSpacing = parentSpacing.getPixels();\n        } else if (thisSpacing.hasValue()) {\n            if (thisSpacing.getValue() !== \"initial\" && thisSpacing.getValue() !== \"unset\") {\n                letterSpacing = thisSpacing.getPixels();\n            }\n        } // fill letter-spacing cache\n        var letterSpacingCache = [];\n        var textLen = renderText.length;\n        this.letterSpacingCache = letterSpacingCache;\n        for(var i = 0; i < textLen; i++){\n            letterSpacingCache.push(typeof dx[i] !== \"undefined\" ? dx[i] : letterSpacing);\n        }\n        var dxSum = letterSpacingCache.reduce((acc, cur, i)=>i === 0 ? 0 : acc + cur || 0, 0);\n        var textWidth = this.measureText(ctx);\n        var textFullWidth = Math.max(textWidth + dxSum, 0);\n        this.textWidth = textWidth;\n        this.textHeight = this.getFontSize();\n        this.glyphInfo = [];\n        var fullPathWidth = this.getPathLength();\n        var startOffset = this.getStyle(\"startOffset\").getNumber(0) * fullPathWidth;\n        var offset = 0;\n        if (anchor === \"middle\" || anchor === \"center\") {\n            offset = -textFullWidth / 2;\n        }\n        if (anchor === \"end\" || anchor === \"right\") {\n            offset = -textFullWidth;\n        }\n        offset += startOffset;\n        chars.forEach((char, i)=>{\n            // Find such segment what distance between p0 and p1 is approx. width of glyph\n            var { offset: nextOffset, segment, rotation } = this.findSegmentToFitChar(ctx, anchor, textFullWidth, fullPathWidth, spacesNumber, offset, dy, char, i);\n            offset = nextOffset;\n            if (!segment.p0 || !segment.p1) {\n                return;\n            } // const width = this.getLineLength(\n            // \tsegment.p0.x,\n            // \tsegment.p0.y,\n            // \tsegment.p1.x,\n            // \tsegment.p1.y\n            // );\n            // Note: Since glyphs are rendered one at a time, any kerning pair data built into the font will not be used.\n            // Can foresee having a rough pair table built in that the developer can override as needed.\n            // Or use \"dx\" attribute of the <text> node as a naive replacement\n            // const kern = 0;\n            // placeholder for future implementation\n            // const midpoint = this.getPointOnLine(\n            // \tkern + width / 2.0,\n            // \tsegment.p0.x, segment.p0.y, segment.p1.x, segment.p1.y\n            // );\n            this.glyphInfo.push({\n                // transposeX: midpoint.x,\n                // transposeY: midpoint.y,\n                text: chars[i],\n                p0: segment.p0,\n                p1: segment.p1,\n                rotation\n            });\n        });\n    }\n    parsePathData(path) {\n        this.pathLength = -1; // reset path length\n        if (!path) {\n            return [];\n        }\n        var pathCommands = [];\n        var { pathParser } = path;\n        pathParser.reset(); // convert l, H, h, V, and v to L\n        while(!pathParser.isEnd()){\n            var { current } = pathParser;\n            var startX = current ? current.x : 0;\n            var startY = current ? current.y : 0;\n            var command = pathParser.next();\n            var nextCommandType = command.type;\n            var points = [];\n            switch(command.type){\n                case PathParser.MOVE_TO:\n                    this.pathM(pathParser, points);\n                    break;\n                case PathParser.LINE_TO:\n                    nextCommandType = this.pathL(pathParser, points);\n                    break;\n                case PathParser.HORIZ_LINE_TO:\n                    nextCommandType = this.pathH(pathParser, points);\n                    break;\n                case PathParser.VERT_LINE_TO:\n                    nextCommandType = this.pathV(pathParser, points);\n                    break;\n                case PathParser.CURVE_TO:\n                    this.pathC(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_CURVE_TO:\n                    nextCommandType = this.pathS(pathParser, points);\n                    break;\n                case PathParser.QUAD_TO:\n                    this.pathQ(pathParser, points);\n                    break;\n                case PathParser.SMOOTH_QUAD_TO:\n                    nextCommandType = this.pathT(pathParser, points);\n                    break;\n                case PathParser.ARC:\n                    points = this.pathA(pathParser);\n                    break;\n                case PathParser.CLOSE_PATH:\n                    PathElement.pathZ(pathParser);\n                    break;\n            }\n            if (command.type !== PathParser.CLOSE_PATH) {\n                pathCommands.push({\n                    type: nextCommandType,\n                    points,\n                    start: {\n                        x: startX,\n                        y: startY\n                    },\n                    pathLength: this.calcLength(startX, startY, nextCommandType, points)\n                });\n            } else {\n                pathCommands.push({\n                    type: PathParser.CLOSE_PATH,\n                    points: [],\n                    pathLength: 0\n                });\n            }\n        }\n        return pathCommands;\n    }\n    pathM(pathParser, points) {\n        var { x, y } = PathElement.pathM(pathParser).point;\n        points.push(x, y);\n    }\n    pathL(pathParser, points) {\n        var { x, y } = PathElement.pathL(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathH(pathParser, points) {\n        var { x, y } = PathElement.pathH(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathV(pathParser, points) {\n        var { x, y } = PathElement.pathV(pathParser).point;\n        points.push(x, y);\n        return PathParser.LINE_TO;\n    }\n    pathC(pathParser, points) {\n        var { point, controlPoint, currentPoint } = PathElement.pathC(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathS(pathParser, points) {\n        var { point, controlPoint, currentPoint } = PathElement.pathS(pathParser);\n        points.push(point.x, point.y, controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.CURVE_TO;\n    }\n    pathQ(pathParser, points) {\n        var { controlPoint, currentPoint } = PathElement.pathQ(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n    }\n    pathT(pathParser, points) {\n        var { controlPoint, currentPoint } = PathElement.pathT(pathParser);\n        points.push(controlPoint.x, controlPoint.y, currentPoint.x, currentPoint.y);\n        return PathParser.QUAD_TO;\n    }\n    pathA(pathParser) {\n        var { rX, rY, sweepFlag, xAxisRotation, centp, a1, ad } = PathElement.pathA(pathParser);\n        if (sweepFlag === 0 && ad > 0) {\n            ad -= 2 * Math.PI;\n        }\n        if (sweepFlag === 1 && ad < 0) {\n            ad += 2 * Math.PI;\n        }\n        return [\n            centp.x,\n            centp.y,\n            rX,\n            rY,\n            a1,\n            ad,\n            xAxisRotation,\n            sweepFlag\n        ];\n    }\n    calcLength(x, y, commandType, points) {\n        var len = 0;\n        var p1 = null;\n        var p2 = null;\n        var t = 0;\n        switch(commandType){\n            case PathParser.LINE_TO:\n                return this.getLineLength(x, y, points[0], points[1]);\n            case PathParser.CURVE_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0.0;\n                p1 = this.getPointOnCubicBezier(0, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnCubicBezier(t, x, y, points[0], points[1], points[2], points[3], points[4], points[5]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.QUAD_TO:\n                // Approximates by breaking curve into 100 line segments\n                len = 0.0;\n                p1 = this.getPointOnQuadraticBezier(0, x, y, points[0], points[1], points[2], points[3]);\n                for(t = 0.01; t <= 1; t += 0.01){\n                    p2 = this.getPointOnQuadraticBezier(t, x, y, points[0], points[1], points[2], points[3]);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    p1 = p2;\n                }\n                return len;\n            case PathParser.ARC:\n                {\n                    // Approximates by breaking curve into line segments\n                    len = 0.0;\n                    var start = points[4]; // 4 = theta\n                    var dTheta = points[5]; // 5 = dTheta\n                    var end = points[4] + dTheta;\n                    var inc = Math.PI / 180.0; // 1 degree resolution\n                    if (Math.abs(start - end) < inc) {\n                        inc = Math.abs(start - end);\n                    } // Note: for purpose of calculating arc length, not going to worry about rotating X-axis by angle psi\n                    p1 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], start, 0);\n                    if (dTheta < 0) {\n                        // clockwise\n                        for(t = start - inc; t > end; t -= inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    } else {\n                        // counter-clockwise\n                        for(t = start + inc; t < end; t += inc){\n                            p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], t, 0);\n                            len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                            p1 = p2;\n                        }\n                    }\n                    p2 = this.getPointOnEllipticalArc(points[0], points[1], points[2], points[3], end, 0);\n                    len += this.getLineLength(p1.x, p1.y, p2.x, p2.y);\n                    return len;\n                }\n        }\n        return 0;\n    }\n    getPointOnLine(dist, p1x, p1y, p2x, p2y) {\n        var fromX = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : p1x;\n        var fromY = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : p1y;\n        var m = (p2y - p1y) / (p2x - p1x + PSEUDO_ZERO);\n        var run = Math.sqrt(dist * dist / (1 + m * m));\n        if (p2x < p1x) {\n            run *= -1;\n        }\n        var rise = m * run;\n        var pt = null;\n        if (p2x === p1x) {\n            // vertical line\n            pt = {\n                x: fromX,\n                y: fromY + rise\n            };\n        } else if ((fromY - p1y) / (fromX - p1x + PSEUDO_ZERO) === m) {\n            pt = {\n                x: fromX + run,\n                y: fromY + rise\n            };\n        } else {\n            var ix = 0;\n            var iy = 0;\n            var len = this.getLineLength(p1x, p1y, p2x, p2y);\n            if (len < PSEUDO_ZERO) {\n                return null;\n            }\n            var u = (fromX - p1x) * (p2x - p1x) + (fromY - p1y) * (p2y - p1y);\n            u /= len * len;\n            ix = p1x + u * (p2x - p1x);\n            iy = p1y + u * (p2y - p1y);\n            var pRise = this.getLineLength(fromX, fromY, ix, iy);\n            var pRun = Math.sqrt(dist * dist - pRise * pRise);\n            run = Math.sqrt(pRun * pRun / (1 + m * m));\n            if (p2x < p1x) {\n                run *= -1;\n            }\n            rise = m * run;\n            pt = {\n                x: ix + run,\n                y: iy + rise\n            };\n        }\n        return pt;\n    }\n    getPointOnPath(distance) {\n        var fullLen = this.getPathLength();\n        var cumulativePathLength = 0;\n        var p = null;\n        if (distance < -0.00005 || distance - 0.00005 > fullLen) {\n            return null;\n        }\n        var { dataArray } = this;\n        for (var command of dataArray){\n            if (command && (command.pathLength < 0.00005 || cumulativePathLength + command.pathLength + 0.00005 < distance)) {\n                cumulativePathLength += command.pathLength;\n                continue;\n            }\n            var delta = distance - cumulativePathLength;\n            var currentT = 0;\n            switch(command.type){\n                case PathParser.LINE_TO:\n                    p = this.getPointOnLine(delta, command.start.x, command.start.y, command.points[0], command.points[1], command.start.x, command.start.y);\n                    break;\n                case PathParser.ARC:\n                    {\n                        var start = command.points[4]; // 4 = theta\n                        var dTheta = command.points[5]; // 5 = dTheta\n                        var end = command.points[4] + dTheta;\n                        currentT = start + delta / command.pathLength * dTheta;\n                        if (dTheta < 0 && currentT < end || dTheta >= 0 && currentT > end) {\n                            break;\n                        }\n                        p = this.getPointOnEllipticalArc(command.points[0], command.points[1], command.points[2], command.points[3], currentT, command.points[6]);\n                        break;\n                    }\n                case PathParser.CURVE_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnCubicBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3], command.points[4], command.points[5]);\n                    break;\n                case PathParser.QUAD_TO:\n                    currentT = delta / command.pathLength;\n                    if (currentT > 1) {\n                        currentT = 1;\n                    }\n                    p = this.getPointOnQuadraticBezier(currentT, command.start.x, command.start.y, command.points[0], command.points[1], command.points[2], command.points[3]);\n                    break;\n            }\n            if (p) {\n                return p;\n            }\n            break;\n        }\n        return null;\n    }\n    getLineLength(x1, y1, x2, y2) {\n        return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n    }\n    getPathLength() {\n        if (this.pathLength === -1) {\n            this.pathLength = this.dataArray.reduce((length, command)=>command.pathLength > 0 ? length + command.pathLength : length, 0);\n        }\n        return this.pathLength;\n    }\n    getPointOnCubicBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {\n        var x = p4x * CB1(pct) + p3x * CB2(pct) + p2x * CB3(pct) + p1x * CB4(pct);\n        var y = p4y * CB1(pct) + p3y * CB2(pct) + p2y * CB3(pct) + p1y * CB4(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnQuadraticBezier(pct, p1x, p1y, p2x, p2y, p3x, p3y) {\n        var x = p3x * QB1(pct) + p2x * QB2(pct) + p1x * QB3(pct);\n        var y = p3y * QB1(pct) + p2y * QB2(pct) + p1y * QB3(pct);\n        return {\n            x,\n            y\n        };\n    }\n    getPointOnEllipticalArc(cx, cy, rx, ry, theta, psi) {\n        var cosPsi = Math.cos(psi);\n        var sinPsi = Math.sin(psi);\n        var pt = {\n            x: rx * Math.cos(theta),\n            y: ry * Math.sin(theta)\n        };\n        return {\n            x: cx + (pt.x * cosPsi - pt.y * sinPsi),\n            y: cy + (pt.x * sinPsi + pt.y * cosPsi)\n        };\n    }\n    buildEquidistantCache(inputStep, inputPrecision) {\n        var fullLen = this.getPathLength();\n        var precision = inputPrecision || 0.25; // accuracy vs performance\n        var step = inputStep || fullLen / 100;\n        if (!this.equidistantCache || this.equidistantCache.step !== step || this.equidistantCache.precision !== precision) {\n            // Prepare cache\n            this.equidistantCache = {\n                step,\n                precision,\n                points: []\n            }; // Calculate points\n            var s = 0;\n            for(var l = 0; l <= fullLen; l += precision){\n                var p0 = this.getPointOnPath(l);\n                var p1 = this.getPointOnPath(l + precision);\n                if (!p0 || !p1) {\n                    continue;\n                }\n                s += this.getLineLength(p0.x, p0.y, p1.x, p1.y);\n                if (s >= step) {\n                    this.equidistantCache.points.push({\n                        x: p0.x,\n                        y: p0.y,\n                        distance: l\n                    });\n                    s -= step;\n                }\n            }\n        }\n    }\n    getEquidistantPointOnPath(targetDistance, step, precision) {\n        this.buildEquidistantCache(step, precision);\n        if (targetDistance < 0 || targetDistance - this.getPathLength() > 0.00005) {\n            return null;\n        }\n        var idx = Math.round(targetDistance / this.getPathLength() * (this.equidistantCache.points.length - 1));\n        return this.equidistantCache.points[idx] || null;\n    }\n}\nvar dataUriRegex = /^\\s*data:(([^/,;]+\\/[^/,;]+)(?:;([^,;=]+=[^,;=]+))?)?(?:;(base64))?,(.*)$/i;\nclass ImageElement extends RenderedElement {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"image\";\n        this.loaded = false;\n        var href = this.getHrefAttribute().getString();\n        if (!href) {\n            return;\n        }\n        var isSvg = href.endsWith(\".svg\") || /^\\s*data:image\\/svg\\+xml/i.test(href);\n        document1.images.push(this);\n        if (!isSvg) {\n            void this.loadImage(href);\n        } else {\n            void this.loadSvg(href);\n        }\n        this.isSvg = isSvg;\n    }\n    loadImage(href) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            try {\n                var image = yield _this.document.createImage(href);\n                _this.image = image;\n            } catch (err) {\n                console.error('Error while loading image \"'.concat(href, '\":'), err);\n            }\n            _this.loaded = true;\n        })();\n    }\n    loadSvg(href) {\n        var _this2 = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var match = dataUriRegex.exec(href);\n            if (match) {\n                var data = match[5];\n                if (match[4] === \"base64\") {\n                    _this2.image = atob(data);\n                } else {\n                    _this2.image = decodeURIComponent(data);\n                }\n            } else {\n                try {\n                    var response = yield _this2.document.fetch(href);\n                    var svg = yield response.text();\n                    _this2.image = svg;\n                } catch (err) {\n                    console.error('Error while loading image \"'.concat(href, '\":'), err);\n                }\n            }\n            _this2.loaded = true;\n        })();\n    }\n    renderChildren(ctx) {\n        var { document: document1, image, loaded } = this;\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        if (!loaded || !image || !width || !height) {\n            return;\n        }\n        ctx.save();\n        ctx.translate(x, y);\n        if (this.isSvg) {\n            var subDocument = document1.canvg.forkString(ctx, this.image, {\n                ignoreMouse: true,\n                ignoreAnimation: true,\n                ignoreDimensions: true,\n                ignoreClear: true,\n                offsetX: 0,\n                offsetY: 0,\n                scaleWidth: width,\n                scaleHeight: height\n            });\n            subDocument.document.documentElement.parent = this;\n            void subDocument.render();\n        } else {\n            var _image = this.image;\n            document1.setViewBox({\n                ctx,\n                aspectRatio: this.getAttribute(\"preserveAspectRatio\").getString(),\n                width,\n                desiredWidth: _image.width,\n                height,\n                desiredHeight: _image.height\n            });\n            if (this.loaded) {\n                if (typeof _image.complete === \"undefined\" || _image.complete) {\n                    ctx.drawImage(_image, 0, 0);\n                }\n            }\n        }\n        ctx.restore();\n    }\n    getBoundingBox() {\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        return new BoundingBox(x, y, x + width, y + height);\n    }\n}\nclass SymbolElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"symbol\";\n    }\n    render(_) {}\n}\nclass SVGFontLoader {\n    constructor(document1){\n        this.document = document1;\n        this.loaded = false;\n        document1.fonts.push(this);\n    }\n    load(fontFamily, url) {\n        var _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            try {\n                var { document: document1 } = _this;\n                var svgDocument = yield document1.canvg.parser.load(url);\n                var fonts = svgDocument.getElementsByTagName(\"font\");\n                Array.from(fonts).forEach((fontNode)=>{\n                    var font = document1.createElement(fontNode);\n                    document1.definitions[fontFamily] = font;\n                });\n            } catch (err) {\n                console.error('Error while loading font \"'.concat(url, '\":'), err);\n            }\n            _this.loaded = true;\n        })();\n    }\n}\nclass StyleElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"style\";\n        var css = compressSpaces(Array.from(node.childNodes) // NEED TEST\n        .map((_)=>_.textContent).join(\"\").replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, \"\") // remove comments\n        .replace(/@import.*;/g, \"\") // remove imports\n        );\n        var cssDefs = css.split(\"}\");\n        cssDefs.forEach((_)=>{\n            var def = _.trim();\n            if (!def) {\n                return;\n            }\n            var cssParts = def.split(\"{\");\n            var cssClasses = cssParts[0].split(\",\");\n            var cssProps = cssParts[1].split(\";\");\n            cssClasses.forEach((_)=>{\n                var cssClass = _.trim();\n                if (!cssClass) {\n                    return;\n                }\n                var props = document1.styles[cssClass] || {};\n                cssProps.forEach((cssProp)=>{\n                    var prop = cssProp.indexOf(\":\");\n                    var name = cssProp.substr(0, prop).trim();\n                    var value = cssProp.substr(prop + 1, cssProp.length - prop).trim();\n                    if (name && value) {\n                        props[name] = new Property(document1, name, value);\n                    }\n                });\n                document1.styles[cssClass] = props;\n                document1.stylesSpecificity[cssClass] = getSelectorSpecificity(cssClass);\n                if (cssClass === \"@font-face\") {\n                    //  && !nodeEnv\n                    var fontFamily = props[\"font-family\"].getString().replace(/\"|'/g, \"\");\n                    var srcs = props.src.getString().split(\",\");\n                    srcs.forEach((src)=>{\n                        if (src.indexOf('format(\"svg\")') > 0) {\n                            var url = parseExternalUrl(src);\n                            if (url) {\n                                void new SVGFontLoader(document1).load(fontFamily, url);\n                            }\n                        }\n                    });\n                }\n            });\n        });\n    }\n}\nStyleElement.parseExternalUrl = parseExternalUrl;\nclass UseElement extends RenderedElement {\n    constructor(){\n        super(...arguments);\n        this.type = \"use\";\n    }\n    setContext(ctx) {\n        super.setContext(ctx);\n        var xAttr = this.getAttribute(\"x\");\n        var yAttr = this.getAttribute(\"y\");\n        if (xAttr.hasValue()) {\n            ctx.translate(xAttr.getPixels(\"x\"), 0);\n        }\n        if (yAttr.hasValue()) {\n            ctx.translate(0, yAttr.getPixels(\"y\"));\n        }\n    }\n    path(ctx) {\n        var { element } = this;\n        if (element) {\n            element.path(ctx);\n        }\n    }\n    renderChildren(ctx) {\n        var { document: document1, element } = this;\n        if (element) {\n            var tempSvg = element;\n            if (element.type === \"symbol\") {\n                // render me using a temporary svg element in symbol cases (http://www.w3.org/TR/SVG/struct.html#UseElement)\n                tempSvg = new SVGElement(document1, null);\n                tempSvg.attributes.viewBox = new Property(document1, \"viewBox\", element.getAttribute(\"viewBox\").getString());\n                tempSvg.attributes.preserveAspectRatio = new Property(document1, \"preserveAspectRatio\", element.getAttribute(\"preserveAspectRatio\").getString());\n                tempSvg.attributes.overflow = new Property(document1, \"overflow\", element.getAttribute(\"overflow\").getString());\n                tempSvg.children = element.children; // element is still the parent of the children\n                element.styles.opacity = new Property(document1, \"opacity\", this.calculateOpacity());\n            }\n            if (tempSvg.type === \"svg\") {\n                var widthStyle = this.getStyle(\"width\", false, true);\n                var heightStyle = this.getStyle(\"height\", false, true); // if symbol or svg, inherit width/height from me\n                if (widthStyle.hasValue()) {\n                    tempSvg.attributes.width = new Property(document1, \"width\", widthStyle.getString());\n                }\n                if (heightStyle.hasValue()) {\n                    tempSvg.attributes.height = new Property(document1, \"height\", heightStyle.getString());\n                }\n            }\n            var oldParent = tempSvg.parent;\n            tempSvg.parent = this;\n            tempSvg.render(ctx);\n            tempSvg.parent = oldParent;\n        }\n    }\n    getBoundingBox(ctx) {\n        var { element } = this;\n        if (element) {\n            return element.getBoundingBox(ctx);\n        }\n        return null;\n    }\n    elementTransform() {\n        var { document: document1, element } = this;\n        return Transform.fromElement(document1, element);\n    }\n    get element() {\n        if (!this.cachedElement) {\n            this.cachedElement = this.getHrefAttribute().getDefinition();\n        }\n        return this.cachedElement;\n    }\n}\nfunction imGet(img, x, y, width, _height, rgba) {\n    return img[y * width * 4 + x * 4 + rgba];\n}\nfunction imSet(img, x, y, width, _height, rgba, val) {\n    img[y * width * 4 + x * 4 + rgba] = val;\n}\nfunction m(matrix, i, v) {\n    var mi = matrix[i];\n    return mi * v;\n}\nfunction c(a, m1, m2, m3) {\n    return m1 + Math.cos(a) * m2 + Math.sin(a) * m3;\n}\nclass FeColorMatrixElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feColorMatrix\";\n        var matrix = toNumbers(this.getAttribute(\"values\").getString());\n        switch(this.getAttribute(\"type\").getString(\"matrix\")){\n            // http://www.w3.org/TR/SVG/filters.html#feColorMatrixElement\n            case \"saturate\":\n                {\n                    var s = matrix[0];\n                    /* eslint-disable array-element-newline */ matrix = [\n                        0.213 + 0.787 * s,\n                        0.715 - 0.715 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 + 0.285 * s,\n                        0.072 - 0.072 * s,\n                        0,\n                        0,\n                        0.213 - 0.213 * s,\n                        0.715 - 0.715 * s,\n                        0.072 + 0.928 * s,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"hueRotate\":\n                {\n                    var a = matrix[0] * Math.PI / 180.0;\n                    /* eslint-disable array-element-newline */ matrix = [\n                        c(a, 0.213, 0.787, -0.213),\n                        c(a, 0.715, -0.715, -0.715),\n                        c(a, 0.072, -0.072, 0.928),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, 0.143),\n                        c(a, 0.715, 0.285, 0.140),\n                        c(a, 0.072, -0.072, -0.283),\n                        0,\n                        0,\n                        c(a, 0.213, -0.213, -0.787),\n                        c(a, 0.715, -0.715, 0.715),\n                        c(a, 0.072, 0.928, 0.072),\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1,\n                        0,\n                        0,\n                        0,\n                        0,\n                        0,\n                        1\n                    ];\n                    break;\n                }\n            case \"luminanceToAlpha\":\n                /* eslint-disable array-element-newline */ matrix = [\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0.2125,\n                    0.7154,\n                    0.0721,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    0,\n                    1\n                ];\n                break;\n        }\n        this.matrix = matrix;\n        this.includeOpacity = this.getAttribute(\"includeOpacity\").hasValue();\n    }\n    apply(ctx, _x, _y, width, height) {\n        // assuming x==0 && y==0 for now\n        var { includeOpacity, matrix } = this;\n        var srcData = ctx.getImageData(0, 0, width, height);\n        for(var y = 0; y < height; y++){\n            for(var x = 0; x < width; x++){\n                var r = imGet(srcData.data, x, y, width, height, 0);\n                var g = imGet(srcData.data, x, y, width, height, 1);\n                var b = imGet(srcData.data, x, y, width, height, 2);\n                var a = imGet(srcData.data, x, y, width, height, 3);\n                var nr = m(matrix, 0, r) + m(matrix, 1, g) + m(matrix, 2, b) + m(matrix, 3, a) + m(matrix, 4, 1);\n                var ng = m(matrix, 5, r) + m(matrix, 6, g) + m(matrix, 7, b) + m(matrix, 8, a) + m(matrix, 9, 1);\n                var nb = m(matrix, 10, r) + m(matrix, 11, g) + m(matrix, 12, b) + m(matrix, 13, a) + m(matrix, 14, 1);\n                var na = m(matrix, 15, r) + m(matrix, 16, g) + m(matrix, 17, b) + m(matrix, 18, a) + m(matrix, 19, 1);\n                if (includeOpacity) {\n                    nr = 0;\n                    ng = 0;\n                    nb = 0;\n                    na *= a / 255;\n                }\n                imSet(srcData.data, x, y, width, height, 0, nr);\n                imSet(srcData.data, x, y, width, height, 1, ng);\n                imSet(srcData.data, x, y, width, height, 2, nb);\n                imSet(srcData.data, x, y, width, height, 3, na);\n            }\n        }\n        ctx.clearRect(0, 0, width, height);\n        ctx.putImageData(srcData, 0, 0);\n    }\n}\nclass MaskElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"mask\";\n    }\n    apply(ctx, element) {\n        var { document: document1 } = this; // render as temp svg\n        var x = this.getAttribute(\"x\").getPixels(\"x\");\n        var y = this.getAttribute(\"y\").getPixels(\"y\");\n        var width = this.getStyle(\"width\").getPixels(\"x\");\n        var height = this.getStyle(\"height\").getPixels(\"y\");\n        if (!width && !height) {\n            var boundingBox = new BoundingBox();\n            this.children.forEach((child)=>{\n                boundingBox.addBoundingBox(child.getBoundingBox(ctx));\n            });\n            x = Math.floor(boundingBox.x1);\n            y = Math.floor(boundingBox.y1);\n            width = Math.floor(boundingBox.width);\n            height = Math.floor(boundingBox.height);\n        }\n        var ignoredStyles = this.removeStyles(element, MaskElement.ignoreStyles);\n        var maskCanvas = document1.createCanvas(x + width, y + height);\n        var maskCtx = maskCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(maskCtx);\n        this.renderChildren(maskCtx); // convert mask to alpha with a fake node\n        // TODO: refactor out apply from feColorMatrix\n        new FeColorMatrixElement(document1, {\n            nodeType: 1,\n            childNodes: [],\n            attributes: [\n                {\n                    nodeName: \"type\",\n                    value: \"luminanceToAlpha\"\n                },\n                {\n                    nodeName: \"includeOpacity\",\n                    value: \"true\"\n                }\n            ]\n        }).apply(maskCtx, 0, 0, x + width, y + height);\n        var tmpCanvas = document1.createCanvas(x + width, y + height);\n        var tmpCtx = tmpCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(tmpCtx);\n        element.render(tmpCtx);\n        tmpCtx.globalCompositeOperation = \"destination-in\";\n        tmpCtx.fillStyle = maskCtx.createPattern(maskCanvas, \"no-repeat\");\n        tmpCtx.fillRect(0, 0, x + width, y + height);\n        ctx.fillStyle = tmpCtx.createPattern(tmpCanvas, \"no-repeat\");\n        ctx.fillRect(0, 0, x + width, y + height); // reassign mask\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {}\n}\nMaskElement.ignoreStyles = [\n    \"mask\",\n    \"transform\",\n    \"clip-path\"\n];\nvar noop = ()=>{};\nclass ClipPathElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"clipPath\";\n    }\n    apply(ctx) {\n        var { document: document1 } = this;\n        var contextProto = Reflect.getPrototypeOf(ctx);\n        var { beginPath, closePath } = ctx;\n        if (contextProto) {\n            contextProto.beginPath = noop;\n            contextProto.closePath = noop;\n        }\n        Reflect.apply(beginPath, ctx, []);\n        this.children.forEach((child)=>{\n            if (typeof child.path === \"undefined\") {\n                return;\n            }\n            var transform = typeof child.elementTransform !== \"undefined\" ? child.elementTransform() : null; // handle <use />\n            if (!transform) {\n                transform = Transform.fromElement(document1, child);\n            }\n            if (transform) {\n                transform.apply(ctx);\n            }\n            child.path(ctx);\n            if (contextProto) {\n                contextProto.closePath = closePath;\n            }\n            if (transform) {\n                transform.unapply(ctx);\n            }\n        });\n        Reflect.apply(closePath, ctx, []);\n        ctx.clip();\n        if (contextProto) {\n            contextProto.beginPath = beginPath;\n            contextProto.closePath = closePath;\n        }\n    }\n    render(_) {}\n}\nclass FilterElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"filter\";\n    }\n    apply(ctx, element) {\n        // render as temp svg\n        var { document: document1, children } = this;\n        var boundingBox = element.getBoundingBox(ctx);\n        if (!boundingBox) {\n            return;\n        }\n        var px = 0;\n        var py = 0;\n        children.forEach((child)=>{\n            var efd = child.extraFilterDistance || 0;\n            px = Math.max(px, efd);\n            py = Math.max(py, efd);\n        });\n        var width = Math.floor(boundingBox.width);\n        var height = Math.floor(boundingBox.height);\n        var tmpCanvasWidth = width + 2 * px;\n        var tmpCanvasHeight = height + 2 * py;\n        if (tmpCanvasWidth < 1 || tmpCanvasHeight < 1) {\n            return;\n        }\n        var x = Math.floor(boundingBox.x);\n        var y = Math.floor(boundingBox.y);\n        var ignoredStyles = this.removeStyles(element, FilterElement.ignoreStyles);\n        var tmpCanvas = document1.createCanvas(tmpCanvasWidth, tmpCanvasHeight);\n        var tmpCtx = tmpCanvas.getContext(\"2d\");\n        document1.screen.setDefaults(tmpCtx);\n        tmpCtx.translate(-x + px, -y + py);\n        element.render(tmpCtx); // apply filters\n        children.forEach((child)=>{\n            if (typeof child.apply === \"function\") {\n                child.apply(tmpCtx, 0, 0, tmpCanvasWidth, tmpCanvasHeight);\n            }\n        }); // render on me\n        ctx.drawImage(tmpCanvas, 0, 0, tmpCanvasWidth, tmpCanvasHeight, x - px, y - py, tmpCanvasWidth, tmpCanvasHeight);\n        this.restoreStyles(element, ignoredStyles);\n    }\n    render(_) {}\n}\nFilterElement.ignoreStyles = [\n    \"filter\",\n    \"transform\",\n    \"clip-path\"\n];\nclass FeDropShadowElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feDropShadow\";\n        this.addStylesFromStyleDefinition();\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeMorphologyElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"feMorphology\";\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeCompositeElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"feComposite\";\n    }\n    apply(_, _x, _y, _width, _height) {}\n}\nclass FeGaussianBlurElement extends Element {\n    constructor(document1, node, captureTextNodes){\n        super(document1, node, captureTextNodes);\n        this.type = \"feGaussianBlur\";\n        this.blurRadius = Math.floor(this.getAttribute(\"stdDeviation\").getNumber());\n        this.extraFilterDistance = this.blurRadius;\n    }\n    apply(ctx, x, y, width, height) {\n        var { document: document1, blurRadius } = this;\n        var body = document1.window ? document1.window.document.body : null;\n        var canvas = ctx.canvas; // StackBlur requires canvas be on document\n        canvas.id = document1.getUniqueId();\n        if (body) {\n            canvas.style.display = \"none\";\n            body.appendChild(canvas);\n        }\n        (0,stackblur_canvas__WEBPACK_IMPORTED_MODULE_19__.canvasRGBA)(canvas, x, y, width, height, blurRadius);\n        if (body) {\n            body.removeChild(canvas);\n        }\n    }\n}\nclass TitleElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"title\";\n    }\n}\nclass DescElement extends Element {\n    constructor(){\n        super(...arguments);\n        this.type = \"desc\";\n    }\n}\nvar elements = {\n    \"svg\": SVGElement,\n    \"rect\": RectElement,\n    \"circle\": CircleElement,\n    \"ellipse\": EllipseElement,\n    \"line\": LineElement,\n    \"polyline\": PolylineElement,\n    \"polygon\": PolygonElement,\n    \"path\": PathElement,\n    \"pattern\": PatternElement,\n    \"marker\": MarkerElement,\n    \"defs\": DefsElement,\n    \"linearGradient\": LinearGradientElement,\n    \"radialGradient\": RadialGradientElement,\n    \"stop\": StopElement,\n    \"animate\": AnimateElement,\n    \"animateColor\": AnimateColorElement,\n    \"animateTransform\": AnimateTransformElement,\n    \"font\": FontElement,\n    \"font-face\": FontFaceElement,\n    \"missing-glyph\": MissingGlyphElement,\n    \"glyph\": GlyphElement,\n    \"text\": TextElement,\n    \"tspan\": TSpanElement,\n    \"tref\": TRefElement,\n    \"a\": AElement,\n    \"textPath\": TextPathElement,\n    \"image\": ImageElement,\n    \"g\": GElement,\n    \"symbol\": SymbolElement,\n    \"style\": StyleElement,\n    \"use\": UseElement,\n    \"mask\": MaskElement,\n    \"clipPath\": ClipPathElement,\n    \"filter\": FilterElement,\n    \"feDropShadow\": FeDropShadowElement,\n    \"feMorphology\": FeMorphologyElement,\n    \"feComposite\": FeCompositeElement,\n    \"feColorMatrix\": FeColorMatrixElement,\n    \"feGaussianBlur\": FeGaussianBlurElement,\n    \"title\": TitleElement,\n    \"desc\": DescElement\n};\nfunction ownKeys$1(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread$1(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys$1(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys$1(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\nfunction createCanvas(width, height) {\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n}\nfunction createImage(_x) {\n    return _createImage.apply(this, arguments);\n}\nfunction _createImage() {\n    _createImage = _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*(src) {\n        var anonymousCrossOrigin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n        var image = document.createElement(\"img\");\n        if (anonymousCrossOrigin) {\n            image.crossOrigin = \"Anonymous\";\n        }\n        return new Promise((resolve, reject)=>{\n            image.onload = ()=>{\n                resolve(image);\n            };\n            image.onerror = (_event, _source, _lineno, _colno, error)=>{\n                reject(error);\n            };\n            image.src = src;\n        });\n    });\n    return _createImage.apply(this, arguments);\n}\nclass Document {\n    constructor(canvg){\n        var { rootEmSize = 12, emSize = 12, createCanvas = Document.createCanvas, createImage = Document.createImage, anonymousCrossOrigin } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        this.canvg = canvg;\n        this.definitions = Object.create(null);\n        this.styles = Object.create(null);\n        this.stylesSpecificity = Object.create(null);\n        this.images = [];\n        this.fonts = [];\n        this.emSizeStack = [];\n        this.uniqueId = 0;\n        this.screen = canvg.screen;\n        this.rootEmSize = rootEmSize;\n        this.emSize = emSize;\n        this.createCanvas = createCanvas;\n        this.createImage = this.bindCreateImage(createImage, anonymousCrossOrigin);\n        this.screen.wait(this.isImagesLoaded.bind(this));\n        this.screen.wait(this.isFontsLoaded.bind(this));\n    }\n    bindCreateImage(createImage, anonymousCrossOrigin) {\n        if (typeof anonymousCrossOrigin === \"boolean\") {\n            return (source, forceAnonymousCrossOrigin)=>createImage(source, typeof forceAnonymousCrossOrigin === \"boolean\" ? forceAnonymousCrossOrigin : anonymousCrossOrigin);\n        }\n        return createImage;\n    }\n    get window() {\n        return this.screen.window;\n    }\n    get fetch() {\n        return this.screen.fetch;\n    }\n    get ctx() {\n        return this.screen.ctx;\n    }\n    get emSize() {\n        var { emSizeStack } = this;\n        return emSizeStack[emSizeStack.length - 1];\n    }\n    set emSize(value) {\n        var { emSizeStack } = this;\n        emSizeStack.push(value);\n    }\n    popEmSize() {\n        var { emSizeStack } = this;\n        emSizeStack.pop();\n    }\n    getUniqueId() {\n        return \"canvg\".concat(++this.uniqueId);\n    }\n    isImagesLoaded() {\n        return this.images.every((_)=>_.loaded);\n    }\n    isFontsLoaded() {\n        return this.fonts.every((_)=>_.loaded);\n    }\n    createDocumentElement(document1) {\n        var documentElement = this.createElement(document1.documentElement);\n        documentElement.root = true;\n        documentElement.addStylesFromStyleDefinition();\n        this.documentElement = documentElement;\n        return documentElement;\n    }\n    createElement(node) {\n        var elementType = node.nodeName.replace(/^[^:]+:/, \"\");\n        var ElementType = Document.elementTypes[elementType];\n        if (typeof ElementType !== \"undefined\") {\n            return new ElementType(this, node);\n        }\n        return new UnknownElement(this, node);\n    }\n    createTextNode(node) {\n        return new TextNode(this, node);\n    }\n    setViewBox(config) {\n        this.screen.setViewBox(_objectSpread$1({\n            document: this\n        }, config));\n    }\n}\nDocument.createCanvas = createCanvas;\nDocument.createImage = createImage;\nDocument.elementTypes = elements;\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        if (enumerableOnly) {\n            symbols = symbols.filter(function(sym) {\n                return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n            });\n        }\n        keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = arguments[i] != null ? arguments[i] : {};\n        if (i % 2) {\n            ownKeys(Object(source), true).forEach(function(key) {\n                _babel_runtime_helpers_defineProperty__WEBPACK_IMPORTED_MODULE_7__(target, key, source[key]);\n            });\n        } else if (Object.getOwnPropertyDescriptors) {\n            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n        } else {\n            ownKeys(Object(source)).forEach(function(key) {\n                Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n            });\n        }\n    }\n    return target;\n}\n/**\r\n * SVG renderer on canvas.\r\n */ class Canvg {\n    /**\r\n   * Main constructor.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG Document.\r\n   * @param options - Rendering options.\r\n   */ constructor(ctx, svg){\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        this.parser = new Parser(options);\n        this.screen = new Screen(ctx, options);\n        this.options = options;\n        var document1 = new Document(this, options);\n        var documentElement = document1.createDocumentElement(svg);\n        this.document = document1;\n        this.documentElement = documentElement;\n    }\n    /**\r\n   * Create Canvg instance from SVG source string or URL.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string or URL.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ static from(ctx, svg) {\n        var _arguments = arguments;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var options = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : {};\n            var parser = new Parser(options);\n            var svgDocument = yield parser.parse(svg);\n            return new Canvg(ctx, svgDocument, options);\n        })();\n    }\n    /**\r\n   * Create Canvg instance from SVG source string.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ static fromString(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        var parser = new Parser(options);\n        var svgDocument = parser.parseFromString(svg);\n        return new Canvg(ctx, svgDocument, options);\n    }\n    /**\r\n   * Create new Canvg instance with inherited options.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string or URL.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ fork(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return Canvg.from(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n    }\n    /**\r\n   * Create new Canvg instance with inherited options.\r\n   * @param ctx - Rendering context.\r\n   * @param svg - SVG source string.\r\n   * @param options - Rendering options.\r\n   * @returns Canvg instance.\r\n   */ forkString(ctx, svg) {\n        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        return Canvg.fromString(ctx, svg, _objectSpread(_objectSpread({}, this.options), options));\n    }\n    /**\r\n   * Document is ready promise.\r\n   * @returns Ready promise.\r\n   */ ready() {\n        return this.screen.ready();\n    }\n    /**\r\n   * Document is ready value.\r\n   * @returns Is ready or not.\r\n   */ isReady() {\n        return this.screen.isReady();\n    }\n    /**\r\n   * Render only first frame, ignoring animations and mouse.\r\n   * @param options - Rendering options.\r\n   */ render() {\n        var _arguments2 = arguments, _this = this;\n        return _babel_runtime_helpers_asyncToGenerator__WEBPACK_IMPORTED_MODULE_1__(function*() {\n            var options = _arguments2.length > 0 && _arguments2[0] !== undefined ? _arguments2[0] : {};\n            _this.start(_objectSpread({\n                enableRedraw: true,\n                ignoreAnimation: true,\n                ignoreMouse: true\n            }, options));\n            yield _this.ready();\n            _this.stop();\n        })();\n    }\n    /**\r\n   * Start rendering.\r\n   * @param options - Render options.\r\n   */ start() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var { documentElement, screen, options: baseOptions } = this;\n        screen.start(documentElement, _objectSpread(_objectSpread({\n            enableRedraw: true\n        }, baseOptions), options));\n    }\n    /**\r\n   * Stop rendering.\r\n   */ stop() {\n        this.screen.stop();\n    }\n    /**\r\n   * Resize SVG to fit in given size.\r\n   * @param width\r\n   * @param height\r\n   * @param preserveAspectRatio\r\n   */ resize(width) {\n        var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : width;\n        var preserveAspectRatio = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n        this.documentElement.resize(width, height, preserveAspectRatio);\n    }\n}\n //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZXMuanMiLCJzb3VyY2VzIjpbXSwic291cmNlc0NvbnRlbnQiOltdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmcvbGliL2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBdUM7QUFDaUM7QUFDNUI7QUFDRTtBQUNJO0FBQ0o7QUFDVztBQUNXO0FBQ3hCO0FBQ0k7QUFDSjtBQUNKO0FBQ0c7QUFDWDtBQUNjO0FBQ0M7QUFDRjtBQUNGO0FBQ0s7QUFDRjtBQUU5Qzs7Ozs7Q0FLQyxHQUNELFNBQVNNO0lBQ1AsSUFBSSxFQUNGQyxXQUFXQyxpQkFBaUIsRUFDN0IsR0FBR0MsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztJQUN6RSxJQUFJRyxTQUFTO1FBQ1hDLFFBQVE7UUFDUkMsaUJBQWlCO1FBQ2pCQyxhQUFhO1FBQ2JSLFdBQVdDO1FBRVhRLGNBQWFDLEtBQUssRUFBRUMsTUFBTTtZQUN4QixPQUFPLElBQUlDLGdCQUFnQkYsT0FBT0M7UUFDcEM7UUFFQUUsYUFBWUMsR0FBRztZQUNiLE9BQU9yQixvRUFBaUJBLENBQUM7Z0JBQ3ZCLElBQUlzQixXQUFXLE1BQU1DLE1BQU1GO2dCQUMzQixJQUFJRyxPQUFPLE1BQU1GLFNBQVNFLElBQUk7Z0JBQzlCLElBQUlDLE1BQU0sTUFBTUMsa0JBQWtCRjtnQkFDbEMsT0FBT0M7WUFDVDtRQUNGO0lBRUY7SUFFQSxJQUFJLE9BQU9sQixjQUFjLGVBQWUsT0FBT0Msc0JBQXNCLGFBQWE7UUFDaEZtQixRQUFRQyxjQUFjLENBQUNoQixRQUFRO0lBQ2pDO0lBRUEsT0FBT0E7QUFDVDtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTaUIsS0FBS0MsSUFBSTtJQUNoQixJQUFJLEVBQ0Z2QixXQUFBQSxVQUFTLEVBQ1R3QixNQUFNLEVBQ05SLE9BQUFBLE1BQUssRUFDTixHQUFHTztJQUNKLE9BQU87UUFDTGpCLFFBQVE7UUFDUkMsaUJBQWlCO1FBQ2pCQyxhQUFhO1FBQ2JSLFdBQUFBO1FBQ0FnQixPQUFBQTtRQUNBUCxjQUFjZSxPQUFPZixZQUFZO1FBQ2pDSSxhQUFhVyxPQUFPQyxTQUFTO0lBQy9CO0FBQ0Y7QUFFQSxJQUFJQyxRQUFRLFdBQVcsR0FBRUMsT0FBT0MsTUFBTSxDQUFDO0lBQ3RDQyxXQUFXO0lBQ1g5QixXQUFXQTtJQUNYdUIsTUFBTUE7QUFDUDtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTUSxlQUFlQyxHQUFHO0lBQ3pCLE9BQU9BLElBQUlDLE9BQU8sQ0FBQyxtQkFBbUI7QUFDeEM7QUFDQTs7OztDQUlDLEdBRUQsU0FBU0MsU0FBU0YsR0FBRztJQUNuQixPQUFPQSxJQUFJQyxPQUFPLENBQUMsYUFBYTtBQUNsQztBQUNBOzs7O0NBSUMsR0FFRCxTQUFTRSxVQUFVSCxHQUFHO0lBQ3BCLE9BQU9BLElBQUlDLE9BQU8sQ0FBQyxhQUFhO0FBQ2xDO0FBQ0E7Ozs7Q0FJQyxHQUVELFNBQVNHLFVBQVVKLEdBQUc7SUFDcEIsSUFBSUssVUFBVSxDQUFDTCxPQUFPLEVBQUMsRUFBR00sS0FBSyxDQUFDLHlEQUF5RCxFQUFFO0lBQzNGLE9BQU9ELFFBQVFFLEdBQUcsQ0FBQ0M7QUFDckIsRUFBRSxxQkFBcUI7QUFFdkIsSUFBSUMsZUFBZTtBQUNuQjs7OztDQUlDLEdBRUQsU0FBU0MsdUJBQXVCQyxJQUFJO0lBQ2xDLElBQUlGLGFBQWFHLElBQUksQ0FBQ0QsT0FBTztRQUMzQixPQUFPQSxLQUFLRSxXQUFXO0lBQ3pCO0lBRUEsT0FBT0Y7QUFDVDtBQUNBOzs7O0NBSUMsR0FFRCxTQUFTRyxpQkFBaUIvQixHQUFHO0lBQzNCLHlDQUF5QztJQUN6QyxtREFBbUQ7SUFDbkQseURBQXlEO0lBQ3pELDZDQUE2QztJQUM3QyxJQUFJZ0MsV0FBVyx5Q0FBeUNDLElBQUksQ0FBQ2pDLFFBQVEsRUFBRTtJQUN2RSxPQUFPZ0MsUUFBUSxDQUFDLEVBQUUsSUFBSUEsUUFBUSxDQUFDLEVBQUUsSUFBSUEsUUFBUSxDQUFDLEVBQUU7QUFDbEQ7QUFDQTs7OztDQUlDLEdBRUQsU0FBU0UsZUFBZUMsS0FBSztJQUMzQixJQUFJLENBQUNBLE1BQU1DLFVBQVUsQ0FBQyxRQUFRO1FBQzVCLE9BQU9EO0lBQ1Q7SUFFQSxJQUFJRSxXQUFXO0lBQ2YsSUFBSUMsa0JBQWtCSCxNQUFNakIsT0FBTyxDQUFDLGdCQUFnQixDQUFDcUIsS0FBS0MsVUFBWUgsY0FBY0csVUFBVUMsT0FBT0MsS0FBS0MsS0FBSyxDQUFDbEIsV0FBV2MsU0FBU0E7SUFDcEksT0FBT0Q7QUFDVDtBQUVBLHNHQUFzRztBQUN0RyxJQUFJTSxpQkFBaUI7QUFDckIsSUFBSUMsVUFBVTtBQUNkLElBQUlDLGFBQWE7QUFDakIsSUFBSUMscUJBQXFCO0FBQ3pCLElBQUlDLCtCQUErQjtBQUNuQyxJQUFJQyxtQkFBbUI7QUFDdkIsSUFBSUMsZUFBZTtBQUVuQixTQUFTQyxrQkFBa0JDLFFBQVEsRUFBRUMsS0FBSztJQUN4QyxJQUFJL0IsVUFBVStCLE1BQU1wQixJQUFJLENBQUNtQjtJQUV6QixJQUFJLENBQUM5QixTQUFTO1FBQ1osT0FBTztZQUFDOEI7WUFBVTtTQUFFO0lBQ3RCO0lBRUEsT0FBTztRQUFDQSxTQUFTbEMsT0FBTyxDQUFDbUMsT0FBTztRQUFNL0IsUUFBUWpDLE1BQU07S0FBQztBQUN2RDtBQUNBOzs7O0NBSUMsR0FHRCxTQUFTaUUsdUJBQXVCRixRQUFRO0lBQ3RDLElBQUlHLGNBQWM7UUFBQztRQUFHO1FBQUc7S0FBRTtJQUMzQixJQUFJQyxrQkFBa0JKLFNBQVNsQyxPQUFPLENBQUMsb0JBQW9CLFlBQVlBLE9BQU8sQ0FBQyxjQUFjO0lBQzdGLElBQUl1QyxRQUFRO0lBQ1osQ0FBQ0QsaUJBQWlCQyxNQUFNLEdBQUdOLGtCQUFrQkssaUJBQWlCWjtJQUM5RFcsV0FBVyxDQUFDLEVBQUUsSUFBSUU7SUFDbEIsQ0FBQ0QsaUJBQWlCQyxNQUFNLEdBQUdOLGtCQUFrQkssaUJBQWlCWDtJQUM5RFUsV0FBVyxDQUFDLEVBQUUsSUFBSUU7SUFDbEIsQ0FBQ0QsaUJBQWlCQyxNQUFNLEdBQUdOLGtCQUFrQkssaUJBQWlCVjtJQUM5RFMsV0FBVyxDQUFDLEVBQUUsSUFBSUU7SUFDbEIsQ0FBQ0QsaUJBQWlCQyxNQUFNLEdBQUdOLGtCQUFrQkssaUJBQWlCVDtJQUM5RFEsV0FBVyxDQUFDLEVBQUUsSUFBSUU7SUFDbEIsQ0FBQ0QsaUJBQWlCQyxNQUFNLEdBQUdOLGtCQUFrQkssaUJBQWlCUjtJQUM5RE8sV0FBVyxDQUFDLEVBQUUsSUFBSUU7SUFDbEIsQ0FBQ0QsaUJBQWlCQyxNQUFNLEdBQUdOLGtCQUFrQkssaUJBQWlCUDtJQUM5RE0sV0FBVyxDQUFDLEVBQUUsSUFBSUU7SUFDbEJELGtCQUFrQkEsZ0JBQWdCdEMsT0FBTyxDQUFDLGFBQWEsS0FBS0EsT0FBTyxDQUFDLFNBQVM7SUFDN0UsQ0FBQ3NDLGlCQUFpQkMsTUFBTSxHQUFHTixrQkFBa0JLLGlCQUFpQk4sZUFBZSx3Q0FBd0M7SUFFckhLLFdBQVcsQ0FBQyxFQUFFLElBQUlFO0lBQ2xCLE9BQU9GLFlBQVlHLElBQUksQ0FBQztBQUMxQjtBQUVBLElBQUlDLGNBQWM7QUFDbEI7Ozs7Q0FJQyxHQUVELFNBQVNDLGdCQUFnQkMsQ0FBQztJQUN4QixPQUFPbkIsS0FBS29CLElBQUksQ0FBQ3BCLEtBQUtxQixHQUFHLENBQUNGLENBQUMsQ0FBQyxFQUFFLEVBQUUsS0FBS25CLEtBQUtxQixHQUFHLENBQUNGLENBQUMsQ0FBQyxFQUFFLEVBQUU7QUFDdEQ7QUFDQTs7Ozs7Q0FLQyxHQUVELFNBQVNHLGFBQWFDLENBQUMsRUFBRUosQ0FBQztJQUN4QixPQUFPLENBQUNJLENBQUMsQ0FBQyxFQUFFLEdBQUdKLENBQUMsQ0FBQyxFQUFFLEdBQUdJLENBQUMsQ0FBQyxFQUFFLEdBQUdKLENBQUMsQ0FBQyxFQUFFLElBQUtELENBQUFBLGdCQUFnQkssS0FBS0wsZ0JBQWdCQyxFQUFDO0FBQzlFO0FBQ0E7Ozs7O0NBS0MsR0FFRCxTQUFTSyxhQUFhRCxDQUFDLEVBQUVKLENBQUM7SUFDeEIsT0FBTyxDQUFDSSxDQUFDLENBQUMsRUFBRSxHQUFHSixDQUFDLENBQUMsRUFBRSxHQUFHSSxDQUFDLENBQUMsRUFBRSxHQUFHSixDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsSUFBSSxLQUFLbkIsS0FBS3lCLElBQUksQ0FBQ0gsYUFBYUMsR0FBR0o7QUFDMUU7QUFDQSxTQUFTTyxJQUFJQyxDQUFDO0lBQ1osT0FBT0EsSUFBSUEsSUFBSUE7QUFDakI7QUFDQSxTQUFTQyxJQUFJRCxDQUFDO0lBQ1osT0FBTyxJQUFJQSxJQUFJQSxJQUFLLEtBQUlBLENBQUFBO0FBQzFCO0FBQ0EsU0FBU0UsSUFBSUYsQ0FBQztJQUNaLE9BQU8sSUFBSUEsSUFBSyxLQUFJQSxDQUFBQSxJQUFNLEtBQUlBLENBQUFBO0FBQ2hDO0FBQ0EsU0FBU0csSUFBSUgsQ0FBQztJQUNaLE9BQU8sQ0FBQyxJQUFJQSxDQUFBQSxJQUFNLEtBQUlBLENBQUFBLElBQU0sS0FBSUEsQ0FBQUE7QUFDbEM7QUFDQSxTQUFTSSxJQUFJSixDQUFDO0lBQ1osT0FBT0EsSUFBSUE7QUFDYjtBQUNBLFNBQVNLLElBQUlMLENBQUM7SUFDWixPQUFPLElBQUlBLElBQUssS0FBSUEsQ0FBQUE7QUFDdEI7QUFDQSxTQUFTTSxJQUFJTixDQUFDO0lBQ1osT0FBTyxDQUFDLElBQUlBLENBQUFBLElBQU0sS0FBSUEsQ0FBQUE7QUFDeEI7QUFFQSxNQUFNTztJQUNKQyxZQUFZQyxTQUFRLEVBQUVsRCxJQUFJLEVBQUVtRCxLQUFLLENBQUU7UUFDakMsSUFBSSxDQUFDRCxRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ2xELElBQUksR0FBR0E7UUFDWixJQUFJLENBQUNtRCxLQUFLLEdBQUdBO1FBQ2IsSUFBSSxDQUFDQyxpQkFBaUIsR0FBRztJQUMzQjtJQUVBLE9BQU9DLE1BQU1ILFNBQVEsRUFBRTtRQUNyQixPQUFPLElBQUlGLFNBQVNFLFdBQVUsU0FBUztJQUN6QztJQUVBSSxRQUFRO1FBQ04sSUFBSUMsWUFBWS9GLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3BGLElBQUksRUFDRjBGLFVBQUFBLFNBQVEsRUFDUmxELElBQUksRUFDTCxHQUFHLElBQUk7UUFDUixPQUFPWixlQUFlLElBQUksQ0FBQ29FLFNBQVMsSUFBSUMsSUFBSSxHQUFHSCxLQUFLLENBQUNDLFdBQVczRCxHQUFHLENBQUN1RCxDQUFBQSxRQUFTLElBQUlILFNBQVNFLFdBQVVsRCxNQUFNbUQ7SUFDNUc7SUFFQU8sU0FBU0MsV0FBVyxFQUFFO1FBQ3BCLElBQUksRUFDRlIsS0FBSyxFQUNOLEdBQUcsSUFBSTtRQUNSLE9BQU9BLFVBQVUsUUFBUUEsVUFBVSxNQUFPUSxDQUFBQSxlQUFlUixVQUFVLE1BQU0sT0FBT0EsVUFBVTtJQUM1RjtJQUVBUyxTQUFTQyxNQUFNLEVBQUU7UUFDZixJQUFJLEVBQ0ZWLEtBQUssRUFDTixHQUFHLElBQUk7UUFDUixJQUFJVyxTQUFTLE9BQU9YLFVBQVU7UUFFOUIsSUFBSSxDQUFDVyxVQUFVLENBQUNELFFBQVE7WUFDdEIsT0FBT0M7UUFDVDtRQUVBLE9BQU9ELE9BQU81RCxJQUFJLENBQUNrRDtJQUNyQjtJQUVBWSxrQkFBa0I7UUFDaEIsT0FBTyxJQUFJLENBQUNILFFBQVEsQ0FBQztJQUN2QjtJQUVBSSxXQUFXO1FBQ1QsSUFBSSxDQUFDLElBQUksQ0FBQ04sUUFBUSxJQUFJO1lBQ3BCLE9BQU87UUFDVDtRQUVBLElBQUlPLFdBQVcsSUFBSSxDQUFDVCxTQUFTO1FBRTdCLE9BQVE7WUFDTixLQUFLUyxTQUFTQyxRQUFRLENBQUM7WUFDdkIsS0FBSyxXQUFXakUsSUFBSSxDQUFDZ0U7Z0JBQ25CLE9BQU87WUFFVDtnQkFDRSxPQUFPO1FBQ1g7SUFDRjtJQUVBRSxTQUFTaEIsS0FBSyxFQUFFO1FBQ2QsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO1FBQ2IsT0FBTyxJQUFJO0lBQ2I7SUFFQWlCLFNBQVNDLEdBQUcsRUFBRTtRQUNaLElBQUksT0FBT0EsUUFBUSxlQUFlLElBQUksQ0FBQ1gsUUFBUSxJQUFJO1lBQ2pELE9BQU8sSUFBSSxDQUFDUCxLQUFLO1FBQ25CO1FBRUEsT0FBT2tCO0lBQ1Q7SUFFQUMsVUFBVUQsR0FBRyxFQUFFO1FBQ2IsSUFBSSxDQUFDLElBQUksQ0FBQ1gsUUFBUSxJQUFJO1lBQ3BCLElBQUksT0FBT1csUUFBUSxhQUFhO2dCQUM5QixPQUFPO1lBQ1Q7WUFFQSxPQUFPeEUsV0FBV3dFO1FBQ3BCO1FBRUEsSUFBSSxFQUNGbEIsS0FBSyxFQUNOLEdBQUcsSUFBSTtRQUNSLElBQUlvQixJQUFJMUUsV0FBV3NEO1FBRW5CLElBQUksSUFBSSxDQUFDUyxRQUFRLENBQUMsT0FBTztZQUN2QlcsS0FBSztRQUNQO1FBRUEsT0FBT0E7SUFDVDtJQUVBZixVQUFVYSxHQUFHLEVBQUU7UUFDYixJQUFJLE9BQU9BLFFBQVEsZUFBZSxJQUFJLENBQUNYLFFBQVEsSUFBSTtZQUNqRCxPQUFPLE9BQU8sSUFBSSxDQUFDUCxLQUFLLEtBQUssY0FBYyxLQUFLdEMsT0FBTyxJQUFJLENBQUNzQyxLQUFLO1FBQ25FO1FBRUEsT0FBT3RDLE9BQU93RDtJQUNoQjtJQUVBRyxTQUFTSCxHQUFHLEVBQUU7UUFDWixJQUFJOUQsUUFBUSxJQUFJLENBQUNpRCxTQUFTLENBQUNhO1FBRTNCLElBQUksSUFBSSxDQUFDakIsaUJBQWlCLEVBQUU7WUFDMUIsT0FBTzdDO1FBQ1Q7UUFFQSxJQUFJLENBQUM2QyxpQkFBaUIsR0FBRztRQUN6QjdDLFFBQVFELGVBQWVDO1FBQ3ZCLElBQUksQ0FBQzRDLEtBQUssR0FBRzVDO1FBQ2IsT0FBT0E7SUFDVDtJQUVBa0UsU0FBUztRQUNQLE9BQU8sTUFBTSxpQkFBaUI7SUFDaEM7SUFFQUMsU0FBUztRQUNQLE9BQU8sSUFBSSxDQUFDeEIsUUFBUSxDQUFDeUIsVUFBVTtJQUNqQztJQUVBQyxRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMxQixRQUFRLENBQUMyQixNQUFNO0lBQzdCO0lBRUFDLFdBQVc7UUFDVCxPQUFPLElBQUksQ0FBQ3RCLFNBQVMsR0FBR2xFLE9BQU8sQ0FBQyxZQUFZO0lBQzlDO0lBRUF5RixVQUFVQyxnQkFBZ0IsRUFBRTtRQUMxQixJQUFJQyxpQkFBaUJ6SCxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUV6RixJQUFJLENBQUMsSUFBSSxDQUFDa0csUUFBUSxJQUFJO1lBQ3BCLE9BQU87UUFDVDtRQUVBLElBQUksQ0FBQ3dCLE1BQU1DLFdBQVcsR0FBRyxPQUFPSCxxQkFBcUIsWUFBWTtZQUFDdEg7WUFBV3NIO1NBQWlCLEdBQUc7WUFBQ0E7U0FBaUI7UUFDbkgsSUFBSSxFQUNGSSxRQUFRLEVBQ1QsR0FBRyxJQUFJLENBQUNsQyxRQUFRLENBQUNtQyxNQUFNO1FBRXhCLE9BQVE7WUFDTixLQUFLLElBQUksQ0FBQ3pCLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSyxRQUFReEQsS0FBS3dFLEdBQUcsQ0FBQ0YsU0FBU0csV0FBVyxDQUFDLE1BQU1ILFNBQVNHLFdBQVcsQ0FBQztZQUU3RixLQUFLLElBQUksQ0FBQzNCLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSyxRQUFReEQsS0FBSzBFLEdBQUcsQ0FBQ0osU0FBU0csV0FBVyxDQUFDLE1BQU1ILFNBQVNHLFdBQVcsQ0FBQztZQUU3RixLQUFLLElBQUksQ0FBQzNCLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSyxRQUFRYyxTQUFTRyxXQUFXLENBQUM7WUFFekQsS0FBSyxJQUFJLENBQUMzQixRQUFRLENBQUM7Z0JBQ2pCLE9BQU8sSUFBSSxDQUFDVSxTQUFTLEtBQUssUUFBUWMsU0FBU0csV0FBVyxDQUFDO1lBRXpELEtBQUssSUFBSSxDQUFDM0IsUUFBUSxDQUFDO2dCQUNqQixPQUFPLElBQUksQ0FBQ1UsU0FBUyxLQUFLLElBQUksQ0FBQ0ksTUFBTTtZQUV2QyxLQUFLLElBQUksQ0FBQ2QsUUFBUSxDQUFDO2dCQUNqQixPQUFPLElBQUksQ0FBQ1UsU0FBUyxLQUFLLElBQUksQ0FBQ00sS0FBSztZQUV0QyxLQUFLLElBQUksQ0FBQ2hCLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSyxJQUFJLENBQUNNLEtBQUssS0FBSztZQUUzQyxLQUFLLElBQUksQ0FBQ2hCLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVM7WUFFdkIsS0FBSyxJQUFJLENBQUNWLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSyxJQUFJLENBQUNHLE1BQU0sS0FBTSxPQUFNLElBQUc7WUFFdEQsS0FBSyxJQUFJLENBQUNiLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSztZQUU1QixLQUFLLElBQUksQ0FBQ1YsUUFBUSxDQUFDO2dCQUNqQixPQUFPLElBQUksQ0FBQ1UsU0FBUyxLQUFLLElBQUksQ0FBQ0csTUFBTSxLQUFLO1lBRTVDLEtBQUssSUFBSSxDQUFDYixRQUFRLENBQUM7Z0JBQ2pCLE9BQU8sSUFBSSxDQUFDVSxTQUFTLEtBQUssSUFBSSxDQUFDRyxNQUFNLEtBQUs7WUFFNUMsS0FBSyxJQUFJLENBQUNiLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBSyxJQUFJLENBQUNHLE1BQU07WUFFdkMsS0FBSyxJQUFJLENBQUNiLFFBQVEsQ0FBQyxTQUFTdUI7Z0JBQzFCLE9BQU8sSUFBSSxDQUFDYixTQUFTLEtBQUssSUFBSSxDQUFDTSxLQUFLO1lBRXRDLEtBQUssSUFBSSxDQUFDaEIsUUFBUSxDQUFDO2dCQUNqQixPQUFPLElBQUksQ0FBQ1UsU0FBUyxLQUFLYyxTQUFTRyxXQUFXLENBQUNMO1lBRWpEO2dCQUNFO29CQUNFLElBQUlYLElBQUksSUFBSSxDQUFDRCxTQUFTO29CQUV0QixJQUFJVyxrQkFBa0JWLElBQUksS0FBSzt3QkFDN0IsT0FBT0EsSUFBSWEsU0FBU0csV0FBVyxDQUFDTDtvQkFDbEM7b0JBRUEsT0FBT1g7Z0JBQ1Q7UUFDSjtJQUNGO0lBRUFrQixrQkFBa0I7UUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQy9CLFFBQVEsSUFBSTtZQUNwQixPQUFPO1FBQ1Q7UUFFQSxJQUFJLElBQUksQ0FBQ0UsUUFBUSxDQUFDLFFBQVE7WUFDeEIsT0FBTyxJQUFJLENBQUNVLFNBQVM7UUFDdkI7UUFFQSxPQUFPLElBQUksQ0FBQ0EsU0FBUyxLQUFLO0lBQzVCO0lBRUFvQixhQUFhO1FBQ1gsSUFBSSxDQUFDLElBQUksQ0FBQ2hDLFFBQVEsSUFBSTtZQUNwQixPQUFPO1FBQ1Q7UUFFQSxPQUFRO1lBQ04sS0FBSyxJQUFJLENBQUNFLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBTXhELENBQUFBLEtBQUs2RSxFQUFFLEdBQUcsS0FBSTtZQUUzQyxLQUFLLElBQUksQ0FBQy9CLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVMsS0FBTXhELENBQUFBLEtBQUs2RSxFQUFFLEdBQUcsS0FBSTtZQUUzQyxLQUFLLElBQUksQ0FBQy9CLFFBQVEsQ0FBQztnQkFDakIsT0FBTyxJQUFJLENBQUNVLFNBQVM7WUFFdkI7Z0JBQ0UsT0FBTyxJQUFJLENBQUNBLFNBQVMsS0FBTXhELENBQUFBLEtBQUs2RSxFQUFFLEdBQUcsS0FBSTtRQUM3QztJQUNGO0lBRUFDLGdCQUFnQjtRQUNkLElBQUkzQixXQUFXLElBQUksQ0FBQ1QsU0FBUztRQUM3QixJQUFJeEQsT0FBTyxhQUFhSyxJQUFJLENBQUM0RDtRQUU3QixJQUFJakUsTUFBTTtZQUNSQSxPQUFPQSxJQUFJLENBQUMsRUFBRTtRQUNoQjtRQUVBLElBQUksQ0FBQ0EsTUFBTTtZQUNUQSxPQUFPaUU7UUFDVDtRQUVBLE9BQU8sSUFBSSxDQUFDZixRQUFRLENBQUMyQyxXQUFXLENBQUM3RixLQUFLO0lBQ3hDO0lBRUE4Rix1QkFBdUJDLE9BQU8sRUFBRUMsT0FBTyxFQUFFO1FBQ3ZDLElBQUkzQixNQUFNLElBQUksQ0FBQ3VCLGFBQWE7UUFFNUIsSUFBSSxDQUFDdkIsS0FBSztZQUNSLE9BQU87UUFDVCxFQUFFLFdBQVc7UUFHYixJQUFJLE9BQU9BLElBQUk0QixjQUFjLEtBQUssWUFBWTtZQUM1QyxPQUFPNUIsSUFBSTRCLGNBQWMsQ0FBQyxJQUFJLENBQUMvQyxRQUFRLENBQUNnRCxHQUFHLEVBQUVILFNBQVNDO1FBQ3hELEVBQUUsVUFBVTtRQUdaLElBQUksT0FBTzNCLElBQUk4QixhQUFhLEtBQUssWUFBWTtZQUMzQyxJQUFJOUIsSUFBSStCLGdCQUFnQixHQUFHMUMsUUFBUSxJQUFJO2dCQUNyQyxJQUFJMkMsbUJBQW1CaEMsSUFBSWlDLFlBQVksQ0FBQztnQkFDeENqQyxNQUFNQSxJQUFJK0IsZ0JBQWdCLEdBQUdSLGFBQWE7Z0JBRTFDLElBQUlTLGlCQUFpQjNDLFFBQVEsSUFBSTtvQkFDL0JXLElBQUlpQyxZQUFZLENBQUMsb0JBQW9CLE1BQU1uQyxRQUFRLENBQUNrQyxpQkFBaUJsRCxLQUFLO2dCQUM1RTtZQUNGO1lBRUEsT0FBT2tCLElBQUk4QixhQUFhLENBQUMsSUFBSSxDQUFDakQsUUFBUSxDQUFDZ0QsR0FBRyxFQUFFSCxTQUFTQztRQUN2RDtRQUVBLE9BQU87SUFDVDtJQUVBTyxrQkFBa0I7UUFDaEIsSUFBSSxDQUFDLElBQUksQ0FBQzdDLFFBQVEsSUFBSTtZQUNwQixPQUFPO1FBQ1Q7UUFFQSxPQUFPVixTQUFTd0QsbUJBQW1CLENBQUMsSUFBSSxDQUFDaEQsU0FBUyxHQUFHO0lBQ3ZEO0lBRUFpRCxXQUFXVCxPQUFPLEVBQUU7UUFDbEIsSUFBSTdDLFFBQVEsSUFBSSxDQUFDcUIsUUFBUTtRQUN6QixJQUFJa0MsTUFBTXZELE1BQU0xRixNQUFNO1FBQ3RCLElBQUlrSixTQUFTLEdBQUcseURBQXlEO1FBRXpFLElBQUssSUFBSUMsSUFBSSxHQUFHQSxJQUFJRixLQUFLRSxJQUFLO1lBQzVCLElBQUl6RCxLQUFLLENBQUN5RCxFQUFFLEtBQUssS0FBSztnQkFDcEJEO1lBQ0Y7WUFFQSxJQUFJQSxXQUFXLEdBQUc7Z0JBQ2hCO1lBQ0Y7UUFDRjtRQUVBLElBQUlYLFFBQVF0QyxRQUFRLE1BQU0sSUFBSSxDQUFDRSxRQUFRLE1BQU0rQyxXQUFXLEdBQUc7WUFDekQsSUFBSXBHLFFBQVEsSUFBSXJELHNDQUFRQSxDQUFDaUc7WUFFekIsSUFBSTVDLE1BQU1zRyxFQUFFLEVBQUU7Z0JBQ1p0RyxNQUFNdUcsS0FBSyxHQUFHZCxRQUFRMUIsU0FBUztnQkFDL0JuQixRQUFRNUMsTUFBTXdHLE1BQU07WUFDdEI7UUFDRjtRQUVBLE9BQU8sSUFBSS9ELFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUUsSUFBSSxDQUFDbEQsSUFBSSxFQUFFbUQ7SUFDaEQ7QUFFRjtBQUNBSCxTQUFTd0QsbUJBQW1CLEdBQUc7SUFDN0IsWUFBWTtJQUNaLGVBQWU7SUFDZixvQkFBb0I7SUFDcEIsVUFBVTtJQUNWLFdBQVc7SUFDWCxjQUFjO0lBQ2QsbUJBQW1CO0lBQ25CLGVBQWU7SUFDZixjQUFjO0lBQ2QsV0FBVztJQUNYLGdCQUFnQjtBQUNsQjtBQUVBLE1BQU1RO0lBQ0ovRCxhQUFjO1FBQ1osSUFBSSxDQUFDZ0UsU0FBUyxHQUFHLEVBQUU7SUFDckI7SUFFQUMsUUFBUTtRQUNOLElBQUksQ0FBQ0QsU0FBUyxHQUFHLEVBQUU7SUFDckI7SUFFQUUsV0FBV25KLEtBQUssRUFBRUMsTUFBTSxFQUFFO1FBQ3hCLElBQUksQ0FBQ2dKLFNBQVMsQ0FBQ0csSUFBSSxDQUFDO1lBQ2xCcEo7WUFDQUM7UUFDRjtJQUNGO0lBRUFvSixnQkFBZ0I7UUFDZCxJQUFJLENBQUNKLFNBQVMsQ0FBQ0ssR0FBRztJQUNwQjtJQUVBQyxhQUFhO1FBQ1gsSUFBSSxFQUNGTixTQUFTLEVBQ1YsR0FBRyxJQUFJO1FBQ1IsT0FBT0EsU0FBUyxDQUFDQSxVQUFVeEosTUFBTSxHQUFHLEVBQUU7SUFDeEM7SUFFQSxJQUFJTyxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUN1SixVQUFVLEdBQUd2SixLQUFLO0lBQ2hDO0lBRUEsSUFBSUMsU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDc0osVUFBVSxHQUFHdEosTUFBTTtJQUNqQztJQUVBc0gsWUFBWWlDLENBQUMsRUFBRTtRQUNiLElBQUksT0FBT0EsTUFBTSxVQUFVO1lBQ3pCLE9BQU9BO1FBQ1Q7UUFFQSxJQUFJQSxNQUFNLEtBQUs7WUFDYixPQUFPLElBQUksQ0FBQ3hKLEtBQUs7UUFDbkI7UUFFQSxJQUFJd0osTUFBTSxLQUFLO1lBQ2IsT0FBTyxJQUFJLENBQUN2SixNQUFNO1FBQ3BCO1FBRUEsT0FBTzZDLEtBQUtvQixJQUFJLENBQUNwQixLQUFLcUIsR0FBRyxDQUFDLElBQUksQ0FBQ25FLEtBQUssRUFBRSxLQUFLOEMsS0FBS3FCLEdBQUcsQ0FBQyxJQUFJLENBQUNsRSxNQUFNLEVBQUUsTUFBTTZDLEtBQUtvQixJQUFJLENBQUM7SUFDbkY7QUFFRjtBQUVBLE1BQU11RjtJQUNKeEUsWUFBWXlFLENBQUMsRUFBRUMsQ0FBQyxDQUFFO1FBQ2hCLElBQUksQ0FBQ0QsQ0FBQyxHQUFHQTtRQUNULElBQUksQ0FBQ0MsQ0FBQyxHQUFHQTtJQUNYO0lBRUEsT0FBT0MsTUFBTUMsS0FBSyxFQUFFO1FBQ2xCLElBQUlDLGVBQWV0SyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUN2RixJQUFJLENBQUNrSyxJQUFJSSxZQUFZLEVBQUVILElBQUlHLFlBQVksQ0FBQyxHQUFHckksVUFBVW9JO1FBQ3JELE9BQU8sSUFBSUosTUFBTUMsR0FBR0M7SUFDdEI7SUFFQSxPQUFPSSxXQUFXQyxLQUFLLEVBQUU7UUFDdkIsSUFBSUYsZUFBZXRLLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3ZGLElBQUksQ0FBQ2tLLElBQUlJLFlBQVksRUFBRUgsSUFBSUQsQ0FBQyxDQUFDLEdBQUdqSSxVQUFVdUk7UUFDMUMsT0FBTyxJQUFJUCxNQUFNQyxHQUFHQztJQUN0QjtJQUVBLE9BQU9NLFVBQVVDLElBQUksRUFBRTtRQUNyQixJQUFJQyxTQUFTMUksVUFBVXlJO1FBQ3ZCLElBQUl4QixNQUFNeUIsT0FBTzFLLE1BQU07UUFDdkIsSUFBSTJLLGFBQWEsRUFBRTtRQUVuQixJQUFLLElBQUl4QixJQUFJLEdBQUdBLElBQUlGLEtBQUtFLEtBQUssRUFBRztZQUMvQndCLFdBQVdoQixJQUFJLENBQUMsSUFBSUssTUFBTVUsTUFBTSxDQUFDdkIsRUFBRSxFQUFFdUIsTUFBTSxDQUFDdkIsSUFBSSxFQUFFO1FBQ3BEO1FBRUEsT0FBT3dCO0lBQ1Q7SUFFQUMsUUFBUVIsS0FBSyxFQUFFO1FBQ2IsT0FBTy9HLEtBQUt3SCxLQUFLLENBQUNULE1BQU1GLENBQUMsR0FBRyxJQUFJLENBQUNBLENBQUMsRUFBRUUsTUFBTUgsQ0FBQyxHQUFHLElBQUksQ0FBQ0EsQ0FBQztJQUN0RDtJQUVBYSxlQUFlQyxTQUFTLEVBQUU7UUFDeEIsSUFBSSxFQUNGZCxDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHLElBQUk7UUFDUixJQUFJYyxLQUFLZixJQUFJYyxTQUFTLENBQUMsRUFBRSxHQUFHYixJQUFJYSxTQUFTLENBQUMsRUFBRSxHQUFHQSxTQUFTLENBQUMsRUFBRTtRQUMzRCxJQUFJRSxLQUFLaEIsSUFBSWMsU0FBUyxDQUFDLEVBQUUsR0FBR2IsSUFBSWEsU0FBUyxDQUFDLEVBQUUsR0FBR0EsU0FBUyxDQUFDLEVBQUU7UUFDM0QsSUFBSSxDQUFDZCxDQUFDLEdBQUdlO1FBQ1QsSUFBSSxDQUFDZCxDQUFDLEdBQUdlO0lBQ1g7QUFFRjtBQUVBLE1BQU1DO0lBQ0oxRixZQUFZb0MsTUFBTSxDQUFFO1FBQ2xCLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQ3VELE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsTUFBTSxHQUFHLEVBQUU7UUFDaEIsSUFBSSxDQUFDQyxhQUFhLEdBQUcsRUFBRSxFQUFFLG1FQUFtRTtRQUU1RixJQUFJLENBQUNDLE9BQU8sR0FBRyxJQUFJLENBQUNBLE9BQU8sQ0FBQ0MsSUFBSSxDQUFDLElBQUksR0FBRyxtRUFBbUU7UUFFM0csSUFBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSSxDQUFDQSxXQUFXLENBQUNELElBQUksQ0FBQyxJQUFJO0lBQy9DO0lBRUFFLFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQ04sT0FBTztJQUNyQjtJQUVBTyxRQUFRO1FBQ04sSUFBSSxJQUFJLENBQUNQLE9BQU8sRUFBRTtZQUNoQjtRQUNGO1FBRUEsSUFBSSxFQUNGdkQsTUFBTSxFQUNOMEQsT0FBTyxFQUNQRSxXQUFXLEVBQ1osR0FBRyxJQUFJO1FBQ1IsSUFBSW5LLFNBQVN1RyxPQUFPYSxHQUFHLENBQUNwSCxNQUFNO1FBQzlCQSxPQUFPc0ssT0FBTyxHQUFHTDtRQUNqQmpLLE9BQU91SyxXQUFXLEdBQUdKO1FBQ3JCLElBQUksQ0FBQ0wsT0FBTyxHQUFHO0lBQ2pCO0lBRUFVLE9BQU87UUFDTCxJQUFJLENBQUMsSUFBSSxDQUFDVixPQUFPLEVBQUU7WUFDakI7UUFDRjtRQUVBLElBQUk5SixTQUFTLElBQUksQ0FBQ3VHLE1BQU0sQ0FBQ2EsR0FBRyxDQUFDcEgsTUFBTTtRQUNuQyxJQUFJLENBQUM4SixPQUFPLEdBQUc7UUFDZjlKLE9BQU9zSyxPQUFPLEdBQUc7UUFDakJ0SyxPQUFPdUssV0FBVyxHQUFHO0lBQ3ZCO0lBRUFFLFlBQVk7UUFDVixPQUFPLElBQUksQ0FBQ1gsT0FBTyxJQUFJLElBQUksQ0FBQ0MsTUFBTSxDQUFDcEwsTUFBTSxHQUFHO0lBQzlDO0lBRUErTCxZQUFZO1FBQ1YsSUFBSSxDQUFDLElBQUksQ0FBQ1osT0FBTyxFQUFFO1lBQ2pCO1FBQ0Y7UUFFQSxJQUFJLEVBQ0Z2RCxRQUFRbkMsU0FBUSxFQUNoQjJGLE1BQU0sRUFDTkMsYUFBYSxFQUNkLEdBQUcsSUFBSTtRQUNSLElBQUksRUFDRlcsS0FBSyxFQUNOLEdBQUd2RyxVQUFTZ0QsR0FBRyxDQUFDcEgsTUFBTTtRQUV2QixJQUFJMkssT0FBTztZQUNUQSxNQUFNQyxNQUFNLEdBQUc7UUFDakI7UUFFQWIsT0FBT2MsT0FBTyxDQUFDLENBQUM5SyxNQUFNK0g7WUFDcEIsSUFBSSxFQUNGZ0QsR0FBRyxFQUNKLEdBQUcvSztZQUNKLElBQUlrSCxVQUFVK0MsYUFBYSxDQUFDbEMsRUFBRTtZQUU5QixNQUFPYixRQUFTO2dCQUNkNkQsSUFBSTdEO2dCQUNKQSxVQUFVQSxRQUFROEQsTUFBTTtZQUMxQjtRQUNGLElBQUksc0JBQXNCO1FBRTFCLElBQUksQ0FBQ2hCLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLEVBQUU7SUFDekI7SUFFQWdCLFVBQVUvRCxPQUFPLEVBQUVHLEdBQUcsRUFBRTtRQUN0QixJQUFJLENBQUMsSUFBSSxDQUFDMEMsT0FBTyxJQUFJLENBQUMxQyxLQUFLO1lBQ3pCO1FBQ0Y7UUFFQSxJQUFJLEVBQ0YyQyxNQUFNLEVBQ05DLGFBQWEsRUFDZCxHQUFHLElBQUk7UUFDUkQsT0FBT2MsT0FBTyxDQUFDLENBQUNJLE9BQU9uRDtZQUNyQixJQUFJLEVBQ0ZjLENBQUMsRUFDREMsQ0FBQyxFQUNGLEdBQUdvQztZQUVKLElBQUksQ0FBQ2pCLGFBQWEsQ0FBQ2xDLEVBQUUsSUFBSVYsSUFBSThELGFBQWEsSUFBSTlELElBQUk4RCxhQUFhLENBQUN0QyxHQUFHQyxJQUFJO2dCQUNyRW1CLGFBQWEsQ0FBQ2xDLEVBQUUsR0FBR2I7WUFDckI7UUFDRjtJQUNGO0lBRUFrRSxpQkFBaUJsRSxPQUFPLEVBQUVtRSxXQUFXLEVBQUU7UUFDckMsSUFBSSxDQUFDLElBQUksQ0FBQ3RCLE9BQU8sSUFBSSxDQUFDc0IsYUFBYTtZQUNqQztRQUNGO1FBRUEsSUFBSSxFQUNGckIsTUFBTSxFQUNOQyxhQUFhLEVBQ2QsR0FBRyxJQUFJO1FBQ1JELE9BQU9jLE9BQU8sQ0FBQyxDQUFDUSxPQUFPdkQ7WUFDckIsSUFBSSxFQUNGYyxDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHd0M7WUFFSixJQUFJLENBQUNyQixhQUFhLENBQUNsQyxFQUFFLElBQUlzRCxZQUFZRSxZQUFZLENBQUMxQyxHQUFHQyxJQUFJO2dCQUN2RG1CLGFBQWEsQ0FBQ2xDLEVBQUUsR0FBR2I7WUFDckI7UUFDRjtJQUNGO0lBRUFzRSxNQUFNM0MsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDVixJQUFJLEVBQ0YvSixRQUFBQSxPQUFNLEVBQ05zSSxHQUFHLEVBQ0osR0FBRyxJQUFJLENBQUNiLE1BQU07UUFDZixJQUFJd0MsUUFBUSxJQUFJSixNQUFNQyxHQUFHQztRQUN6QixJQUFJNUIsVUFBVUcsSUFBSXBILE1BQU07UUFFeEIsTUFBT2lILFFBQVM7WUFDZDhCLE1BQU1ILENBQUMsSUFBSTNCLFFBQVF1RSxVQUFVO1lBQzdCekMsTUFBTUYsQ0FBQyxJQUFJNUIsUUFBUXdFLFNBQVM7WUFDNUJ4RSxVQUFVQSxRQUFReUUsWUFBWTtRQUNoQztRQUVBLElBQUk1TSxRQUFPNk0sT0FBTyxFQUFFO1lBQ2xCNUMsTUFBTUgsQ0FBQyxJQUFJOUosUUFBTzZNLE9BQU87UUFDM0I7UUFFQSxJQUFJN00sUUFBTzhNLE9BQU8sRUFBRTtZQUNsQjdDLE1BQU1GLENBQUMsSUFBSS9KLFFBQU84TSxPQUFPO1FBQzNCO1FBRUEsT0FBTzdDO0lBQ1Q7SUFFQWtCLFFBQVE0QixLQUFLLEVBQUU7UUFDYixJQUFJLEVBQ0ZqRCxDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHLElBQUksQ0FBQzBDLEtBQUssQ0FBQ00sTUFBTUMsT0FBTyxFQUFFRCxNQUFNRSxPQUFPO1FBQzNDLElBQUksQ0FBQ2hDLE1BQU0sQ0FBQ3pCLElBQUksQ0FBQztZQUNmMEQsTUFBTTtZQUNOcEQ7WUFDQUM7WUFFQWlDLEtBQUltQixXQUFXO2dCQUNiLElBQUlBLFlBQVloQyxPQUFPLEVBQUU7b0JBQ3ZCZ0MsWUFBWWhDLE9BQU87Z0JBQ3JCO1lBQ0Y7UUFFRjtJQUNGO0lBRUFFLFlBQVkwQixLQUFLLEVBQUU7UUFDakIsSUFBSSxFQUNGakQsQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBRyxJQUFJLENBQUMwQyxLQUFLLENBQUNNLE1BQU1DLE9BQU8sRUFBRUQsTUFBTUUsT0FBTztRQUMzQyxJQUFJLENBQUNoQyxNQUFNLENBQUN6QixJQUFJLENBQUM7WUFDZjBELE1BQU07WUFDTnBEO1lBQ0FDO1lBRUFpQyxLQUFJbUIsV0FBVztnQkFDYixJQUFJQSxZQUFZOUIsV0FBVyxFQUFFO29CQUMzQjhCLFlBQVk5QixXQUFXO2dCQUN6QjtZQUNGO1FBRUY7SUFDRjtBQUVGO0FBRUEsSUFBSStCLGdCQUFnQixNQUFrQixHQUFjcE4sQ0FBTUEsR0FBRztBQUM3RCxJQUFJcU4saUJBQWlCLE9BQU8zTSxVQUFVLGNBQWNBLE1BQU0wSyxJQUFJLENBQUN0TCxXQUFXLHdFQUF3RTtHQUNoSjtBQUNGLE1BQU13TjtJQUNKakksWUFBWWlELEdBQUcsQ0FBRTtRQUNmLElBQUksRUFDRjVILE9BQUFBLFNBQVEyTSxjQUFjLEVBQ3RCck4sUUFBQUEsVUFBU29OLGFBQWEsRUFDdkIsR0FBR3hOLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDekUsSUFBSSxDQUFDMEksR0FBRyxHQUFHQTtRQUNYLElBQUksQ0FBQ2lGLFNBQVMsR0FBRztRQUNqQixJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ2xHLFFBQVEsR0FBRyxJQUFJNEI7UUFDcEIsSUFBSSxDQUFDdUUsS0FBSyxHQUFHLElBQUk1QyxNQUFNLElBQUk7UUFDM0IsSUFBSSxDQUFDNkMsVUFBVSxHQUFHLEVBQUU7UUFDcEIsSUFBSSxDQUFDQyxLQUFLLEdBQUcsRUFBRTtRQUNmLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsV0FBVyxHQUFHO1FBQ25CLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ2pPLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNVLEtBQUssR0FBR0E7SUFDZjtJQUVBd04sS0FBS0MsT0FBTyxFQUFFO1FBQ1osSUFBSSxDQUFDTixLQUFLLENBQUNyRSxJQUFJLENBQUMyRTtJQUNsQjtJQUVBQyxRQUFRO1FBQ04sa0VBQWtFO1FBQ2xFLElBQUksQ0FBQyxJQUFJLENBQUNDLFlBQVksRUFBRTtZQUN0QixPQUFPQyxRQUFRQyxPQUFPO1FBQ3hCO1FBRUEsT0FBTyxJQUFJLENBQUNGLFlBQVk7SUFDMUI7SUFFQUcsVUFBVTtRQUNSLElBQUksSUFBSSxDQUFDVCxXQUFXLEVBQUU7WUFDcEIsT0FBTztRQUNUO1FBRUEsSUFBSUEsY0FBYyxJQUFJLENBQUNGLEtBQUssQ0FBQ1ksS0FBSyxDQUFDQyxDQUFBQSxJQUFLQTtRQUV4QyxJQUFJWCxhQUFhO1lBQ2YsSUFBSSxDQUFDRixLQUFLLEdBQUcsRUFBRTtZQUVmLElBQUksSUFBSSxDQUFDYyxZQUFZLEVBQUU7Z0JBQ3JCLElBQUksQ0FBQ0EsWUFBWTtZQUNuQjtRQUNGO1FBRUEsSUFBSSxDQUFDWixXQUFXLEdBQUdBO1FBQ25CLE9BQU9BO0lBQ1Q7SUFFQWEsWUFBWXRHLEdBQUcsRUFBRTtRQUNmLDhCQUE4QjtRQUM5QkEsSUFBSXVHLFdBQVcsR0FBRztRQUNsQnZHLElBQUl3RyxPQUFPLEdBQUc7UUFDZHhHLElBQUl5RyxRQUFRLEdBQUc7UUFDZnpHLElBQUkwRyxVQUFVLEdBQUc7SUFDbkI7SUFFQUMsV0FBV2hPLElBQUksRUFBRTtRQUNmLElBQUksRUFDRnFFLFVBQUFBLFNBQVEsRUFDUmdELEdBQUcsRUFDSDRHLFdBQVcsRUFDWDlPLEtBQUssRUFDTCtPLFlBQVksRUFDWjlPLE1BQU0sRUFDTitPLGFBQWEsRUFDYkMsT0FBTyxDQUFDLEVBQ1JDLE9BQU8sQ0FBQyxFQUNSQyxJQUFJLEVBQ0pDLElBQUksRUFDSkMsT0FBTyxLQUFLLEVBQ1pDLFFBQVEsQ0FBQyxFQUNUQyxRQUFRLENBQUMsRUFDVixHQUFHMU87UUFDSixtRkFBbUY7UUFDbkYsSUFBSTJPLG1CQUFtQnBPLGVBQWUwTixhQUFheE4sT0FBTyxDQUFDLFlBQVksS0FBSyxlQUFlO1FBRTNGLElBQUksQ0FBQ21PLGtCQUFrQkMsdUJBQXVCLEdBQUdGLGlCQUFpQmxLLEtBQUssQ0FBQztRQUN4RSxJQUFJcUssUUFBUUYsb0JBQW9CO1FBQ2hDLElBQUlHLGNBQWNGLDBCQUEwQixRQUFRLGtCQUFrQjtRQUV0RSxJQUFJRyxTQUFTN1AsUUFBUStPO1FBQ3JCLElBQUllLFNBQVM3UCxTQUFTK087UUFDdEIsSUFBSWUsV0FBV2pOLEtBQUt3RSxHQUFHLENBQUN1SSxRQUFRQztRQUNoQyxJQUFJRSxXQUFXbE4sS0FBSzBFLEdBQUcsQ0FBQ3FJLFFBQVFDO1FBQ2hDLElBQUlHLG9CQUFvQmxCO1FBQ3hCLElBQUltQixxQkFBcUJsQjtRQUV6QixJQUFJWSxnQkFBZ0IsUUFBUTtZQUMxQksscUJBQXFCRjtZQUNyQkcsc0JBQXNCSDtRQUN4QjtRQUVBLElBQUlILGdCQUFnQixTQUFTO1lBQzNCSyxxQkFBcUJEO1lBQ3JCRSxzQkFBc0JGO1FBQ3hCO1FBRUEsSUFBSUcsV0FBVyxJQUFJbkwsU0FBU0UsV0FBVSxRQUFRaUs7UUFDOUMsSUFBSWlCLFdBQVcsSUFBSXBMLFNBQVNFLFdBQVUsUUFBUWtLO1FBQzlDLElBQUlpQixVQUFVRixTQUFTekssUUFBUSxNQUFNMEssU0FBUzFLLFFBQVE7UUFFdEQsSUFBSTJLLFNBQVM7WUFDWG5JLElBQUlvSSxTQUFTLENBQUMsQ0FBQ1AsV0FBV0ksU0FBU3BKLFNBQVMsQ0FBQyxNQUFNLENBQUNnSixXQUFXSyxTQUFTckosU0FBUyxDQUFDO1FBQ3BGO1FBRUEsSUFBSXNJLE1BQU07WUFDUixJQUFJa0IsY0FBY1IsV0FBV1Q7WUFDN0IsSUFBSWtCLGNBQWNULFdBQVdSO1lBQzdCckgsSUFBSXVJLFNBQVM7WUFDYnZJLElBQUl3SSxNQUFNLENBQUNILGFBQWFDO1lBQ3hCdEksSUFBSXlJLE1BQU0sQ0FBQzNRLE9BQU93UTtZQUNsQnRJLElBQUl5SSxNQUFNLENBQUMzUSxPQUFPQztZQUNsQmlJLElBQUl5SSxNQUFNLENBQUNKLGFBQWF0UTtZQUN4QmlJLElBQUkwSSxTQUFTO1lBQ2IxSSxJQUFJbUgsSUFBSTtRQUNWO1FBRUEsSUFBSSxDQUFDZ0IsU0FBUztZQUNaLElBQUlRLGFBQWFqQixnQkFBZ0IsVUFBVUcsYUFBYUQ7WUFDeEQsSUFBSWdCLGNBQWNsQixnQkFBZ0IsV0FBV0ksYUFBYUY7WUFDMUQsSUFBSWlCLGFBQWFuQixnQkFBZ0IsVUFBVUcsYUFBYUY7WUFDeEQsSUFBSW1CLGNBQWNwQixnQkFBZ0IsV0FBV0ksYUFBYUg7WUFFMUQsSUFBSUYsTUFBTW5OLFVBQVUsQ0FBQyxXQUFZcU8sQ0FBQUEsY0FBY0MsV0FBVSxHQUFJO2dCQUMzRDVJLElBQUlvSSxTQUFTLENBQUN0USxRQUFRLE1BQU1pUSxvQkFBb0IsS0FBSztZQUN2RDtZQUVBLElBQUlOLE1BQU16SixRQUFRLENBQUMsV0FBWTZLLENBQUFBLGNBQWNDLFdBQVUsR0FBSTtnQkFDekQ5SSxJQUFJb0ksU0FBUyxDQUFDLEdBQUdyUSxTQUFTLE1BQU1pUSxxQkFBcUI7WUFDdkQ7WUFFQSxJQUFJUCxNQUFNbk4sVUFBVSxDQUFDLFdBQVlxTyxDQUFBQSxjQUFjQyxXQUFVLEdBQUk7Z0JBQzNENUksSUFBSW9JLFNBQVMsQ0FBQ3RRLFFBQVFpUSxtQkFBbUI7WUFDM0M7WUFFQSxJQUFJTixNQUFNekosUUFBUSxDQUFDLFdBQVk2SyxDQUFBQSxjQUFjQyxXQUFVLEdBQUk7Z0JBQ3pEOUksSUFBSW9JLFNBQVMsQ0FBQyxHQUFHclEsU0FBU2lRO1lBQzVCO1FBQ0YsRUFBRSxRQUFRO1FBR1YsT0FBUTtZQUNOLEtBQUtQLFVBQVU7Z0JBQ2J6SCxJQUFJOEIsS0FBSyxDQUFDNkYsUUFBUUM7Z0JBQ2xCO1lBRUYsS0FBS0YsZ0JBQWdCO2dCQUNuQjFILElBQUk4QixLQUFLLENBQUMrRixVQUFVQTtnQkFDcEI7WUFFRixLQUFLSCxnQkFBZ0I7Z0JBQ25CMUgsSUFBSThCLEtBQUssQ0FBQ2dHLFVBQVVBO2dCQUNwQjtRQUNKLEVBQUUsWUFBWTtRQUdkOUgsSUFBSW9JLFNBQVMsQ0FBQyxDQUFDckIsTUFBTSxDQUFDQztJQUN4QjtJQUVBL0QsTUFBTXBELE9BQU8sRUFBRTtRQUNiLElBQUksRUFDRmtKLGVBQWUsS0FBSyxFQUNwQm5SLGNBQWMsS0FBSyxFQUNuQkQsa0JBQWtCLEtBQUssRUFDdkJxUixtQkFBbUIsS0FBSyxFQUN4QkMsY0FBYyxLQUFLLEVBQ25CQyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsV0FBVyxFQUNYQyxPQUFPLEVBQ1BDLE9BQU8sRUFDUixHQUFHaFMsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUN6RSxJQUFJLEVBQ0YyTixTQUFTLEVBQ1RJLEtBQUssRUFDTixHQUFHLElBQUk7UUFDUixJQUFJRyxnQkFBZ0IsT0FBT1A7UUFDM0IsSUFBSSxDQUFDTyxhQUFhLEdBQUdBO1FBQ3JCLElBQUksQ0FBQ08sWUFBWSxHQUFHLElBQUlDLFFBQVFDLENBQUFBO1lBQzlCLElBQUksQ0FBQ0ksWUFBWSxHQUFHSjtRQUN0QjtRQUVBLElBQUksSUFBSSxDQUFDQyxPQUFPLElBQUk7WUFDbEIsSUFBSSxDQUFDcUQsTUFBTSxDQUFDMUosU0FBU21KLGtCQUFrQkMsYUFBYUUsWUFBWUMsYUFBYUMsU0FBU0M7UUFDeEY7UUFFQSxJQUFJLENBQUNQLGNBQWM7WUFDakI7UUFDRjtRQUVBLElBQUlTLE1BQU1DLEtBQUtELEdBQUc7UUFDbEIsSUFBSUUsT0FBT0Y7UUFDWCxJQUFJN04sUUFBUTtRQUVaLElBQUlnTyxPQUFPO1lBQ1RILE1BQU1DLEtBQUtELEdBQUc7WUFDZDdOLFFBQVE2TixNQUFNRTtZQUVkLElBQUkvTixTQUFTNkosZUFBZTtnQkFDMUJrRSxPQUFPRixNQUFNN04sUUFBUTZKO2dCQUVyQixJQUFJLElBQUksQ0FBQ29FLFlBQVksQ0FBQ2pTLGlCQUFpQnVSLGNBQWM7b0JBQ25ELElBQUksQ0FBQ0ssTUFBTSxDQUFDMUosU0FBU21KLGtCQUFrQkMsYUFBYUUsWUFBWUMsYUFBYUMsU0FBU0M7b0JBQ3RGakUsTUFBTS9CLFNBQVM7Z0JBQ2pCO1lBQ0Y7WUFFQSxJQUFJLENBQUNxQyxVQUFVLEdBQUc1TyxpQ0FBcUJBLENBQUM0UztRQUMxQztRQUVBLElBQUksQ0FBQy9SLGFBQWE7WUFDaEJ5TixNQUFNcEMsS0FBSztRQUNiO1FBRUEsSUFBSSxDQUFDMEMsVUFBVSxHQUFHNU8saUNBQXFCQSxDQUFDNFM7SUFDMUM7SUFFQXZHLE9BQU87UUFDTCxJQUFJLElBQUksQ0FBQ3VDLFVBQVUsRUFBRTtZQUNuQjVPLHdDQUE0QixDQUFDLElBQUksQ0FBQzRPLFVBQVU7WUFDNUMsSUFBSSxDQUFDQSxVQUFVLEdBQUc7UUFDcEI7UUFFQSxJQUFJLENBQUNOLEtBQUssQ0FBQ2pDLElBQUk7SUFDakI7SUFFQXdHLGFBQWFqUyxlQUFlLEVBQUV1UixXQUFXLEVBQUU7UUFDekMsK0JBQStCO1FBQy9CLElBQUksQ0FBQ3ZSLGlCQUFpQjtZQUNwQixJQUFJLEVBQ0Y2TixhQUFhLEVBQ2QsR0FBRyxJQUFJO1lBQ1IsSUFBSW9FLGVBQWUsSUFBSSxDQUFDdEUsVUFBVSxDQUFDd0UsTUFBTSxDQUFDLENBQUNGLGNBQWNHLFlBQWNBLFVBQVVDLE1BQU0sQ0FBQ3hFLGtCQUFrQm9FLGNBQWM7WUFFeEgsSUFBSUEsY0FBYztnQkFDaEIsT0FBTztZQUNUO1FBQ0YsRUFBRSwyQkFBMkI7UUFHN0IsSUFBSSxPQUFPVixnQkFBZ0IsY0FBY0EsZUFBZTtZQUN0RCxPQUFPO1FBQ1Q7UUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDekQsV0FBVyxJQUFJLElBQUksQ0FBQ1MsT0FBTyxJQUFJO1lBQ3ZDLE9BQU87UUFDVCxFQUFFLGlDQUFpQztRQUduQyxJQUFJLElBQUksQ0FBQ2IsS0FBSyxDQUFDaEMsU0FBUyxJQUFJO1lBQzFCLE9BQU87UUFDVDtRQUVBLE9BQU87SUFDVDtJQUVBa0csT0FBTzFKLE9BQU8sRUFBRW1KLGdCQUFnQixFQUFFQyxXQUFXLEVBQUVFLFVBQVUsRUFBRUMsV0FBVyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUN4RixJQUFJLEVBQ0ZuRSxZQUFZLEVBQ1pDLGFBQWEsRUFDYmxHLFFBQVEsRUFDUmMsR0FBRyxFQUNIMEYsYUFBYSxFQUNkLEdBQUcsSUFBSTtRQUNSLElBQUk5TSxTQUFTb0gsSUFBSXBILE1BQU07UUFDdkJzRyxTQUFTOEIsS0FBSztRQUVkLElBQUlwSSxPQUFPZCxLQUFLLElBQUljLE9BQU9iLE1BQU0sRUFBRTtZQUNqQ21ILFNBQVMrQixVQUFVLENBQUNySSxPQUFPZCxLQUFLLEVBQUVjLE9BQU9iLE1BQU07UUFDakQsT0FBTztZQUNMbUgsU0FBUytCLFVBQVUsQ0FBQ2tFLGNBQWNDO1FBQ3BDO1FBRUEsSUFBSTZFLGFBQWFwSyxRQUFRcUssUUFBUSxDQUFDO1FBQ2xDLElBQUlDLGNBQWN0SyxRQUFRcUssUUFBUSxDQUFDO1FBRW5DLElBQUksQ0FBQ2xCLG9CQUFxQnRELENBQUFBLGlCQUFpQixPQUFPeUQsZUFBZSxZQUFZLE9BQU9DLGdCQUFnQixRQUFPLEdBQUk7WUFDN0csa0JBQWtCO1lBQ2xCLElBQUlhLFdBQVd6TSxRQUFRLElBQUk7Z0JBQ3pCNUUsT0FBT2QsS0FBSyxHQUFHbVMsV0FBV3BMLFNBQVMsQ0FBQztnQkFFcEMsSUFBSWpHLE9BQU8ySyxLQUFLLEVBQUU7b0JBQ2hCM0ssT0FBTzJLLEtBQUssQ0FBQ3pMLEtBQUssR0FBRyxHQUFHc1MsTUFBTSxDQUFDeFIsT0FBT2QsS0FBSyxFQUFFO2dCQUMvQztZQUNGO1lBRUEsSUFBSXFTLFlBQVkzTSxRQUFRLElBQUk7Z0JBQzFCNUUsT0FBT2IsTUFBTSxHQUFHb1MsWUFBWXRMLFNBQVMsQ0FBQztnQkFFdEMsSUFBSWpHLE9BQU8ySyxLQUFLLEVBQUU7b0JBQ2hCM0ssT0FBTzJLLEtBQUssQ0FBQ3hMLE1BQU0sR0FBRyxHQUFHcVMsTUFBTSxDQUFDeFIsT0FBT2IsTUFBTSxFQUFFO2dCQUNqRDtZQUNGO1FBQ0Y7UUFFQSxJQUFJc1MsU0FBU3pSLE9BQU8wUixXQUFXLElBQUkxUixPQUFPZCxLQUFLO1FBQy9DLElBQUl5UyxVQUFVM1IsT0FBTzRSLFlBQVksSUFBSTVSLE9BQU9iLE1BQU07UUFFbEQsSUFBSWlSLG9CQUFvQmlCLFdBQVd6TSxRQUFRLE1BQU0yTSxZQUFZM00sUUFBUSxJQUFJO1lBQ3ZFNk0sU0FBU0osV0FBV3BMLFNBQVMsQ0FBQztZQUM5QjBMLFVBQVVKLFlBQVl0TCxTQUFTLENBQUM7UUFDbEM7UUFFQUssU0FBUytCLFVBQVUsQ0FBQ29KLFFBQVFFO1FBRTVCLElBQUksT0FBT2xCLFlBQVksVUFBVTtZQUMvQnhKLFFBQVFPLFlBQVksQ0FBQyxLQUFLLE1BQU1uQyxRQUFRLENBQUNvTDtRQUMzQztRQUVBLElBQUksT0FBT0MsWUFBWSxVQUFVO1lBQy9CekosUUFBUU8sWUFBWSxDQUFDLEtBQUssTUFBTW5DLFFBQVEsQ0FBQ3FMO1FBQzNDO1FBRUEsSUFBSSxPQUFPSCxlQUFlLFlBQVksT0FBT0MsZ0JBQWdCLFVBQVU7WUFDckUsSUFBSXFCLFVBQVVsUixVQUFVc0csUUFBUU8sWUFBWSxDQUFDLFdBQVc5QyxTQUFTO1lBQ2pFLElBQUlvTixTQUFTO1lBQ2IsSUFBSUMsU0FBUztZQUViLElBQUksT0FBT3hCLGVBQWUsVUFBVTtnQkFDbEMsSUFBSXlCLGNBQWMvSyxRQUFRcUssUUFBUSxDQUFDO2dCQUVuQyxJQUFJVSxZQUFZcE4sUUFBUSxJQUFJO29CQUMxQmtOLFNBQVNFLFlBQVkvTCxTQUFTLENBQUMsT0FBT3NLO2dCQUN4QyxPQUFPLElBQUksQ0FBQzBCLE1BQU1KLE9BQU8sQ0FBQyxFQUFFLEdBQUc7b0JBQzdCQyxTQUFTRCxPQUFPLENBQUMsRUFBRSxHQUFHdEI7Z0JBQ3hCO1lBQ0Y7WUFFQSxJQUFJLE9BQU9DLGdCQUFnQixVQUFVO2dCQUNuQyxJQUFJMEIsZUFBZWpMLFFBQVFxSyxRQUFRLENBQUM7Z0JBRXBDLElBQUlZLGFBQWF0TixRQUFRLElBQUk7b0JBQzNCbU4sU0FBU0csYUFBYWpNLFNBQVMsQ0FBQyxPQUFPdUs7Z0JBQ3pDLE9BQU8sSUFBSSxDQUFDeUIsTUFBTUosT0FBTyxDQUFDLEVBQUUsR0FBRztvQkFDN0JFLFNBQVNGLE9BQU8sQ0FBQyxFQUFFLEdBQUdyQjtnQkFDeEI7WUFDRjtZQUVBLElBQUksQ0FBQ3NCLFFBQVE7Z0JBQ1hBLFNBQVNDO1lBQ1g7WUFFQSxJQUFJLENBQUNBLFFBQVE7Z0JBQ1hBLFNBQVNEO1lBQ1g7WUFFQTdLLFFBQVFPLFlBQVksQ0FBQyxTQUFTLE1BQU1uQyxRQUFRLENBQUNrTDtZQUM3Q3RKLFFBQVFPLFlBQVksQ0FBQyxVQUFVLE1BQU1uQyxRQUFRLENBQUNtTDtZQUM5QyxJQUFJMkIsaUJBQWlCbEwsUUFBUXFLLFFBQVEsQ0FBQyxhQUFhLE1BQU07WUFDekRhLGVBQWU5TSxRQUFRLENBQUMsR0FBR21NLE1BQU0sQ0FBQ1csZUFBZXpOLFNBQVMsSUFBSSxXQUFXOE0sTUFBTSxDQUFDLE1BQU1NLFFBQVEsTUFBTU4sTUFBTSxDQUFDLE1BQU1PLFFBQVE7UUFDM0gsRUFBRSxtQkFBbUI7UUFHckIsSUFBSSxDQUFDMUIsYUFBYTtZQUNoQmpKLElBQUlnTCxTQUFTLENBQUMsR0FBRyxHQUFHWCxRQUFRRTtRQUM5QjtRQUVBMUssUUFBUTBKLE1BQU0sQ0FBQ3ZKO1FBRWYsSUFBSTBGLGVBQWU7WUFDakIsSUFBSSxDQUFDQSxhQUFhLEdBQUc7UUFDdkI7SUFDRjtBQUVGO0FBQ0FWLE9BQU9GLGFBQWEsR0FBR0E7QUFDdkJFLE9BQU9pRyxZQUFZLEdBQUdsRztBQUV0QixJQUFJLEVBQ0ZrRyxZQUFZLEVBQ2IsR0FBR2pHO0FBQ0osSUFBSWtHLG1CQUFtQixPQUFPOVQsY0FBYyxjQUFjQSxZQUFZO0FBQ3RFLE1BQU0rVDtJQUNKcE8sYUFBYztRQUNaLElBQUksRUFDRjNFLE9BQUFBLFNBQVE2UyxZQUFZLEVBQ3BCN1QsV0FBQUEsYUFBWThULGdCQUFnQixFQUM3QixHQUFHNVQsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUN6RSxJQUFJLENBQUNjLEtBQUssR0FBR0E7UUFDYixJQUFJLENBQUNoQixTQUFTLEdBQUdBO0lBQ25CO0lBRUFzSyxNQUFNMEosUUFBUSxFQUFFO1FBQ2QsSUFBSUMsUUFBUSxJQUFJO1FBRWhCLE9BQU94VSxvRUFBaUJBLENBQUM7WUFDdkIsSUFBSXVVLFNBQVM5USxVQUFVLENBQUMsTUFBTTtnQkFDNUIsT0FBTytRLE1BQU1DLGVBQWUsQ0FBQ0Y7WUFDL0I7WUFFQSxPQUFPQyxNQUFNRSxJQUFJLENBQUNIO1FBQ3BCO0lBQ0Y7SUFFQUUsZ0JBQWdCRSxHQUFHLEVBQUU7UUFDbkIsSUFBSUMsU0FBUyxJQUFJLElBQUksQ0FBQ3JVLFNBQVM7UUFFL0IsSUFBSTtZQUNGLE9BQU8sSUFBSSxDQUFDc1UsYUFBYSxDQUFDRCxPQUFPSCxlQUFlLENBQUNFLEtBQUs7UUFDeEQsRUFBRSxPQUFPRyxLQUFLO1lBQ1osT0FBTyxJQUFJLENBQUNELGFBQWEsQ0FBQ0QsT0FBT0gsZUFBZSxDQUFDRSxLQUFLO1FBQ3hEO0lBQ0Y7SUFFQUUsY0FBYzFPLFNBQVEsRUFBRTtRQUN0QixJQUFJNE8sY0FBYzVPLFVBQVM2TyxvQkFBb0IsQ0FBQyxjQUFjLENBQUMsRUFBRTtRQUVqRSxJQUFJRCxhQUFhO1lBQ2YsTUFBTSxJQUFJRSxNQUFNRixZQUFZRyxXQUFXO1FBQ3pDO1FBRUEsT0FBTy9PO0lBQ1Q7SUFFQXVPLEtBQUtyVCxHQUFHLEVBQUU7UUFDUixJQUFJOFQsU0FBUyxJQUFJO1FBRWpCLE9BQU9uVixvRUFBaUJBLENBQUM7WUFDdkIsSUFBSXNCLFdBQVcsTUFBTTZULE9BQU81VCxLQUFLLENBQUNGO1lBQ2xDLElBQUlzVCxNQUFNLE1BQU1yVCxTQUFTOFQsSUFBSTtZQUM3QixPQUFPRCxPQUFPVixlQUFlLENBQUNFO1FBQ2hDO0lBQ0Y7QUFFRjtBQUVBLE1BQU1VO0lBQ0puUCxZQUFZcUosQ0FBQyxFQUFFekUsS0FBSyxDQUFFO1FBQ3BCLElBQUksQ0FBQ2lELElBQUksR0FBRztRQUNaLElBQUksQ0FBQ2pELEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0EsS0FBSyxHQUFHSixNQUFNRyxLQUFLLENBQUNDO0lBQzNCO0lBRUF3SyxNQUFNbk0sR0FBRyxFQUFFO1FBQ1QsSUFBSSxFQUNGd0IsQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBRyxJQUFJLENBQUNFLEtBQUs7UUFDZDNCLElBQUlvSSxTQUFTLENBQUM1RyxLQUFLLEtBQUtDLEtBQUs7SUFDL0I7SUFFQTJLLFFBQVFwTSxHQUFHLEVBQUU7UUFDWCxJQUFJLEVBQ0Z3QixDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHLElBQUksQ0FBQ0UsS0FBSztRQUNkM0IsSUFBSW9JLFNBQVMsQ0FBQyxDQUFDLE1BQU01RyxLQUFLLEtBQUssQ0FBQyxNQUFNQyxLQUFLO0lBQzdDO0lBRUE0SyxhQUFhMUssS0FBSyxFQUFFO1FBQ2xCLElBQUksRUFDRkgsQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBRyxJQUFJLENBQUNFLEtBQUs7UUFDZEEsTUFBTVUsY0FBYyxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBR2IsS0FBSztZQUFLQyxLQUFLO1NBQUk7SUFDdkQ7QUFFRjtBQUVBLE1BQU02SztJQUNKdlAsWUFBWUMsU0FBUSxFQUFFdVAsTUFBTSxFQUFFQyxlQUFlLENBQUU7UUFDN0MsSUFBSSxDQUFDNUgsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDNkgsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsRUFBRSxHQUFHO1FBQ1YsSUFBSSxDQUFDQyxFQUFFLEdBQUc7UUFDVixJQUFJQyxVQUFVdlQsVUFBVWdUO1FBQ3hCLElBQUksQ0FBQ0UsS0FBSyxHQUFHLElBQUkzUCxTQUFTRSxXQUFVLFNBQVM4UCxPQUFPLENBQUMsRUFBRTtRQUN2RCxJQUFJLENBQUNKLE9BQU8sR0FBR0YsZUFBZSxDQUFDLEVBQUU7UUFDakMsSUFBSSxDQUFDRyxPQUFPLEdBQUdILGVBQWUsQ0FBQyxFQUFFO1FBQ2pDLElBQUksQ0FBQ0ksRUFBRSxHQUFHRSxPQUFPLENBQUMsRUFBRSxJQUFJO1FBQ3hCLElBQUksQ0FBQ0QsRUFBRSxHQUFHQyxPQUFPLENBQUMsRUFBRSxJQUFJO0lBQzFCO0lBRUFYLE1BQU1uTSxHQUFHLEVBQUU7UUFDVCxJQUFJLEVBQ0Y0TSxFQUFFLEVBQ0ZDLEVBQUUsRUFDRkgsT0FBTyxFQUNQQyxPQUFPLEVBQ1BGLEtBQUssRUFDTixHQUFHLElBQUk7UUFDUixJQUFJTSxLQUFLSCxLQUFLRixRQUFRN04sU0FBUyxDQUFDO1FBQ2hDLElBQUltTyxLQUFLSCxLQUFLRixRQUFROU4sU0FBUyxDQUFDO1FBQ2hDbUIsSUFBSW9JLFNBQVMsQ0FBQzJFLElBQUlDO1FBQ2xCaE4sSUFBSXVNLE1BQU0sQ0FBQ0UsTUFBTWpOLFVBQVU7UUFDM0JRLElBQUlvSSxTQUFTLENBQUMsQ0FBQzJFLElBQUksQ0FBQ0M7SUFDdEI7SUFFQVosUUFBUXBNLEdBQUcsRUFBRTtRQUNYLElBQUksRUFDRjRNLEVBQUUsRUFDRkMsRUFBRSxFQUNGSCxPQUFPLEVBQ1BDLE9BQU8sRUFDUEYsS0FBSyxFQUNOLEdBQUcsSUFBSTtRQUNSLElBQUlNLEtBQUtILEtBQUtGLFFBQVE3TixTQUFTLENBQUM7UUFDaEMsSUFBSW1PLEtBQUtILEtBQUtGLFFBQVE5TixTQUFTLENBQUM7UUFDaENtQixJQUFJb0ksU0FBUyxDQUFDMkUsSUFBSUM7UUFDbEJoTixJQUFJdU0sTUFBTSxDQUFDLENBQUMsTUFBTUUsTUFBTWpOLFVBQVU7UUFDbENRLElBQUlvSSxTQUFTLENBQUMsQ0FBQzJFLElBQUksQ0FBQ0M7SUFDdEI7SUFFQVgsYUFBYTFLLEtBQUssRUFBRTtRQUNsQixJQUFJLEVBQ0ZpTCxFQUFFLEVBQ0ZDLEVBQUUsRUFDRkosS0FBSyxFQUNOLEdBQUcsSUFBSTtRQUNSLElBQUlRLE1BQU1SLE1BQU1qTixVQUFVO1FBQzFCbUMsTUFBTVUsY0FBYyxDQUFDO1lBQUM7WUFBRztZQUFHO1lBQUc7WUFBR3VLLE1BQU07WUFBS0MsTUFBTSxJQUFJLFdBQVc7U0FDakU7UUFDRGxMLE1BQU1VLGNBQWMsQ0FBQztZQUFDekgsS0FBS3NTLEdBQUcsQ0FBQ0Q7WUFBTXJTLEtBQUt1UyxHQUFHLENBQUNGO1lBQU0sQ0FBQ3JTLEtBQUt1UyxHQUFHLENBQUNGO1lBQU1yUyxLQUFLc1MsR0FBRyxDQUFDRDtZQUFNO1lBQUc7U0FBRTtRQUN4RnRMLE1BQU1VLGNBQWMsQ0FBQztZQUFDO1lBQUc7WUFBRztZQUFHO1lBQUcsQ0FBQ3VLLE1BQU07WUFBSyxDQUFDQyxNQUFNLElBQUksWUFBWTtTQUNwRTtJQUNIO0FBRUY7QUFFQSxNQUFNTztJQUNKclEsWUFBWXFKLENBQUMsRUFBRXRFLEtBQUssRUFBRTBLLGVBQWUsQ0FBRTtRQUNyQyxJQUFJLENBQUM1SCxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUM5QyxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUM0SyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLE9BQU8sR0FBRztRQUNmLElBQUlVLFlBQVk5TCxNQUFNTSxVQUFVLENBQUNDLFFBQVEsNkJBQTZCO1FBRXRFLElBQUl1TCxVQUFVN0wsQ0FBQyxLQUFLLEtBQUs2TCxVQUFVNUwsQ0FBQyxLQUFLLEdBQUc7WUFDMUM0TCxVQUFVN0wsQ0FBQyxHQUFHM0Y7WUFDZHdSLFVBQVU1TCxDQUFDLEdBQUc1RjtRQUNoQjtRQUVBLElBQUksQ0FBQ2lHLEtBQUssR0FBR3VMO1FBQ2IsSUFBSSxDQUFDWCxPQUFPLEdBQUdGLGVBQWUsQ0FBQyxFQUFFO1FBQ2pDLElBQUksQ0FBQ0csT0FBTyxHQUFHSCxlQUFlLENBQUMsRUFBRTtJQUNuQztJQUVBTCxNQUFNbk0sR0FBRyxFQUFFO1FBQ1QsSUFBSSxFQUNGOEIsT0FBTyxFQUNMTixDQUFDLEVBQ0RDLENBQUMsRUFDRixFQUNEaUwsT0FBTyxFQUNQQyxPQUFPLEVBQ1IsR0FBRyxJQUFJO1FBQ1IsSUFBSUksS0FBS0wsUUFBUTdOLFNBQVMsQ0FBQztRQUMzQixJQUFJbU8sS0FBS0wsUUFBUTlOLFNBQVMsQ0FBQztRQUMzQm1CLElBQUlvSSxTQUFTLENBQUMyRSxJQUFJQztRQUNsQmhOLElBQUk4QixLQUFLLENBQUNOLEdBQUdDLEtBQUtEO1FBQ2xCeEIsSUFBSW9JLFNBQVMsQ0FBQyxDQUFDMkUsSUFBSSxDQUFDQztJQUN0QjtJQUVBWixRQUFRcE0sR0FBRyxFQUFFO1FBQ1gsSUFBSSxFQUNGOEIsT0FBTyxFQUNMTixDQUFDLEVBQ0RDLENBQUMsRUFDRixFQUNEaUwsT0FBTyxFQUNQQyxPQUFPLEVBQ1IsR0FBRyxJQUFJO1FBQ1IsSUFBSUksS0FBS0wsUUFBUTdOLFNBQVMsQ0FBQztRQUMzQixJQUFJbU8sS0FBS0wsUUFBUTlOLFNBQVMsQ0FBQztRQUMzQm1CLElBQUlvSSxTQUFTLENBQUMyRSxJQUFJQztRQUNsQmhOLElBQUk4QixLQUFLLENBQUMsTUFBTU4sR0FBRyxNQUFNQyxLQUFLRDtRQUM5QnhCLElBQUlvSSxTQUFTLENBQUMsQ0FBQzJFLElBQUksQ0FBQ0M7SUFDdEI7SUFFQVgsYUFBYTFLLEtBQUssRUFBRTtRQUNsQixJQUFJLEVBQ0ZILENBQUMsRUFDREMsQ0FBQyxFQUNGLEdBQUcsSUFBSSxDQUFDSyxLQUFLO1FBQ2RILE1BQU1VLGNBQWMsQ0FBQztZQUFDYixLQUFLO1lBQUs7WUFBRztZQUFHQyxLQUFLO1lBQUs7WUFBRztTQUFFO0lBQ3ZEO0FBRUY7QUFFQSxNQUFNNkw7SUFDSnZRLFlBQVlxSixDQUFDLEVBQUVtSCxNQUFNLEVBQUVmLGVBQWUsQ0FBRTtRQUN0QyxJQUFJLENBQUM1SCxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUMySSxNQUFNLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUNiLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDWSxNQUFNLEdBQUdoVSxVQUFVZ1U7UUFDeEIsSUFBSSxDQUFDYixPQUFPLEdBQUdGLGVBQWUsQ0FBQyxFQUFFO1FBQ2pDLElBQUksQ0FBQ0csT0FBTyxHQUFHSCxlQUFlLENBQUMsRUFBRTtJQUNuQztJQUVBTCxNQUFNbk0sR0FBRyxFQUFFO1FBQ1QsSUFBSSxFQUNGME0sT0FBTyxFQUNQQyxPQUFPLEVBQ1BZLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJUixLQUFLTCxRQUFRN04sU0FBUyxDQUFDO1FBQzNCLElBQUltTyxLQUFLTCxRQUFROU4sU0FBUyxDQUFDO1FBQzNCbUIsSUFBSW9JLFNBQVMsQ0FBQzJFLElBQUlDO1FBQ2xCaE4sSUFBSXNDLFNBQVMsQ0FBQ2lMLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFO1FBQzlFdk4sSUFBSW9JLFNBQVMsQ0FBQyxDQUFDMkUsSUFBSSxDQUFDQztJQUN0QjtJQUVBWixRQUFRcE0sR0FBRyxFQUFFO1FBQ1gsSUFBSSxFQUNGME0sT0FBTyxFQUNQQyxPQUFPLEVBQ1BZLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJQyxJQUFJRCxNQUFNLENBQUMsRUFBRTtRQUNqQixJQUFJRSxJQUFJRixNQUFNLENBQUMsRUFBRTtRQUNqQixJQUFJRyxJQUFJSCxNQUFNLENBQUMsRUFBRTtRQUNqQixJQUFJak0sSUFBSWlNLE1BQU0sQ0FBQyxFQUFFO1FBQ2pCLElBQUlJLElBQUlKLE1BQU0sQ0FBQyxFQUFFO1FBQ2pCLElBQUlLLElBQUlMLE1BQU0sQ0FBQyxFQUFFO1FBQ2pCLElBQUlNLElBQUk7UUFDUixJQUFJQyxJQUFJO1FBQ1IsSUFBSXBOLElBQUk7UUFDUixJQUFJcU4sTUFBTSxJQUFLUCxDQUFBQSxJQUFLRyxDQUFBQSxJQUFJak4sSUFBSWtOLElBQUlFLENBQUFBLElBQUtMLElBQUtuTSxDQUFBQSxJQUFJWixJQUFJa04sSUFBSUMsQ0FBQUEsSUFBS0gsSUFBS3BNLENBQUFBLElBQUl3TSxJQUFJSCxJQUFJRSxDQUFBQSxDQUFDO1FBQzdFLElBQUlkLEtBQUtMLFFBQVE3TixTQUFTLENBQUM7UUFDM0IsSUFBSW1PLEtBQUtMLFFBQVE5TixTQUFTLENBQUM7UUFDM0JtQixJQUFJb0ksU0FBUyxDQUFDMkUsSUFBSUM7UUFDbEJoTixJQUFJc0MsU0FBUyxDQUFDeUwsTUFBT0osQ0FBQUEsSUFBSWpOLElBQUlrTixJQUFJRSxDQUFBQSxHQUFJQyxNQUFPSCxDQUFBQSxJQUFJQyxJQUFJdk0sSUFBSVosQ0FBQUEsR0FBSXFOLE1BQU9MLENBQUFBLElBQUlJLElBQUlMLElBQUkvTSxDQUFBQSxHQUFJcU4sTUFBT1AsQ0FBQUEsSUFBSTlNLElBQUlnTixJQUFJRyxDQUFBQSxHQUFJRSxNQUFPTixDQUFBQSxJQUFJRyxJQUFJRixJQUFJQyxDQUFBQSxHQUFJSSxNQUFPTCxDQUFBQSxJQUFJcE0sSUFBSWtNLElBQUlJLENBQUFBO1FBQ3BKNU4sSUFBSW9JLFNBQVMsQ0FBQyxDQUFDMkUsSUFBSSxDQUFDQztJQUN0QjtJQUVBWCxhQUFhMUssS0FBSyxFQUFFO1FBQ2xCQSxNQUFNVSxjQUFjLENBQUMsSUFBSSxDQUFDa0wsTUFBTTtJQUNsQztBQUVGO0FBRUEsTUFBTVMsYUFBYVY7SUFDakJ2USxZQUFZQyxTQUFRLEVBQUVpUixJQUFJLEVBQUV6QixlQUFlLENBQUU7UUFDM0MsS0FBSyxDQUFDeFAsV0FBVWlSLE1BQU16QjtRQUN0QixJQUFJLENBQUM1SCxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUM2SCxLQUFLLEdBQUc7UUFDYixJQUFJLENBQUNBLEtBQUssR0FBRyxJQUFJM1AsU0FBU0UsV0FBVSxTQUFTaVI7SUFDL0M7QUFFRjtBQUVBLE1BQU1DLGNBQWNGO0lBQ2xCalIsWUFBWUMsU0FBUSxFQUFFaVIsSUFBSSxFQUFFekIsZUFBZSxDQUFFO1FBQzNDLEtBQUssQ0FBQ3hQLFdBQVVpUixNQUFNekI7UUFDdEIsSUFBSSxDQUFDNUgsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDMkksTUFBTSxHQUFHO1lBQUM7WUFBRztZQUFHM1MsS0FBS3VULEdBQUcsQ0FBQyxJQUFJLENBQUMxQixLQUFLLENBQUNqTixVQUFVO1lBQUs7WUFBRztZQUFHO1NBQUU7SUFDbEU7QUFFRjtBQUVBLE1BQU00TyxjQUFjSjtJQUNsQmpSLFlBQVlDLFNBQVEsRUFBRWlSLElBQUksRUFBRXpCLGVBQWUsQ0FBRTtRQUMzQyxLQUFLLENBQUN4UCxXQUFVaVIsTUFBTXpCO1FBQ3RCLElBQUksQ0FBQzVILElBQUksR0FBRztRQUNaLElBQUksQ0FBQzJJLE1BQU0sR0FBRztZQUFDO1lBQUczUyxLQUFLdVQsR0FBRyxDQUFDLElBQUksQ0FBQzFCLEtBQUssQ0FBQ2pOLFVBQVU7WUFBSztZQUFHO1lBQUc7WUFBRztTQUFFO0lBQ2xFO0FBRUY7QUFFQSxTQUFTNk8sZ0JBQWdCL0wsU0FBUztJQUNoQyxPQUFPcEosZUFBZW9KLFdBQVcvRSxJQUFJLEdBQUduRSxPQUFPLENBQUMsaUJBQWlCLFFBQVFBLE9BQU8sQ0FBQyxnQkFBZ0IsTUFBTWdFLEtBQUssQ0FBQztBQUMvRztBQUVBLFNBQVNrUixlQUFlaE0sU0FBUztJQUMvQixJQUFJLENBQUNzQyxNQUFNM0gsTUFBTSxHQUFHcUYsVUFBVWxGLEtBQUssQ0FBQztJQUNwQyxPQUFPO1FBQUN3SCxLQUFLckgsSUFBSTtRQUFJTixNQUFNTSxJQUFJLEdBQUduRSxPQUFPLENBQUMsS0FBSztLQUFJO0FBQ3JEO0FBRUEsTUFBTW1WO0lBQ0p4UixZQUFZQyxTQUFRLEVBQUVzRixTQUFTLEVBQUVrSyxlQUFlLENBQUU7UUFDaEQsSUFBSSxDQUFDeFAsUUFBUSxHQUFHQTtRQUNoQixJQUFJLENBQUN3UixVQUFVLEdBQUcsRUFBRTtRQUNwQixJQUFJQyxPQUFPSixnQkFBZ0IvTDtRQUMzQm1NLEtBQUtoTCxPQUFPLENBQUNuQixDQUFBQTtZQUNYLElBQUlBLGNBQWMsUUFBUTtnQkFDeEI7WUFDRjtZQUVBLElBQUksQ0FBQ3NDLE1BQU0zSCxNQUFNLEdBQUdxUixlQUFlaE07WUFDbkMsSUFBSW9NLGdCQUFnQkgsVUFBVUksY0FBYyxDQUFDL0osS0FBSztZQUVsRCxJQUFJLE9BQU84SixrQkFBa0IsYUFBYTtnQkFDeEMsSUFBSSxDQUFDRixVQUFVLENBQUN0TixJQUFJLENBQUMsSUFBSXdOLGNBQWMsSUFBSSxDQUFDMVIsUUFBUSxFQUFFQyxPQUFPdVA7WUFDL0Q7UUFDRjtJQUNGO0lBRUEsT0FBT29DLFlBQVk1UixTQUFRLEVBQUU2QyxPQUFPLEVBQUU7UUFDcEMsSUFBSWtMLGlCQUFpQmxMLFFBQVFxSyxRQUFRLENBQUMsYUFBYSxPQUFPO1FBQzFELElBQUksQ0FBQzJFLDBCQUEwQkMsMkJBQTJCRCx3QkFBd0IsQ0FBQyxHQUFHaFAsUUFBUXFLLFFBQVEsQ0FBQyxvQkFBb0IsT0FBTyxNQUFNOU0sS0FBSztRQUM3SSxJQUFJb1Asa0JBQWtCO1lBQUNxQztZQUEwQkM7U0FBeUI7UUFFMUUsSUFBSS9ELGVBQWV2TixRQUFRLElBQUk7WUFDN0IsT0FBTyxJQUFJK1EsVUFBVXZSLFdBQVUrTixlQUFlek4sU0FBUyxJQUFJa1A7UUFDN0Q7UUFFQSxPQUFPO0lBQ1Q7SUFFQUwsTUFBTW5NLEdBQUcsRUFBRTtRQUNULElBQUksRUFDRndPLFVBQVUsRUFDWCxHQUFHLElBQUk7UUFDUixJQUFJaE8sTUFBTWdPLFdBQVdqWCxNQUFNO1FBRTNCLElBQUssSUFBSW1KLElBQUksR0FBR0EsSUFBSUYsS0FBS0UsSUFBSztZQUM1QjhOLFVBQVUsQ0FBQzlOLEVBQUUsQ0FBQ3lMLEtBQUssQ0FBQ25NO1FBQ3RCO0lBQ0Y7SUFFQW9NLFFBQVFwTSxHQUFHLEVBQUU7UUFDWCxJQUFJLEVBQ0Z3TyxVQUFVLEVBQ1gsR0FBRyxJQUFJO1FBQ1IsSUFBSWhPLE1BQU1nTyxXQUFXalgsTUFBTTtRQUUzQixJQUFLLElBQUltSixJQUFJRixNQUFNLEdBQUdFLEtBQUssR0FBR0EsSUFBSztZQUNqQzhOLFVBQVUsQ0FBQzlOLEVBQUUsQ0FBQzBMLE9BQU8sQ0FBQ3BNO1FBQ3hCO0lBQ0Y7SUFHQXFNLGFBQWExSyxLQUFLLEVBQUU7UUFDbEIsSUFBSSxFQUNGNk0sVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUloTyxNQUFNZ08sV0FBV2pYLE1BQU07UUFFM0IsSUFBSyxJQUFJbUosSUFBSSxHQUFHQSxJQUFJRixLQUFLRSxJQUFLO1lBQzVCOE4sVUFBVSxDQUFDOU4sRUFBRSxDQUFDMkwsWUFBWSxDQUFDMUs7UUFDN0I7SUFDRjtBQUVGO0FBQ0E0TSxVQUFVSSxjQUFjLEdBQUc7SUFDekJ2RyxXQUFXOEQ7SUFDWEssUUFBUUQ7SUFDUnhLLE9BQU9zTDtJQUNQRyxRQUFRRDtJQUNSeUIsT0FBT2I7SUFDUGMsT0FBT1o7QUFDVDtBQUVBLE1BQU1hO0lBQ0psUyxZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLENBQUU7UUFDMUIsSUFBSXdXLG1CQUFtQjVYLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQzNGLElBQUksQ0FBQzBGLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDdEUsSUFBSSxHQUFHQTtRQUNaLElBQUksQ0FBQ3dXLGdCQUFnQixHQUFHQTtRQUN4QixJQUFJLENBQUNDLFVBQVUsR0FBR3BXLE9BQU9xVyxNQUFNLENBQUM7UUFDaEMsSUFBSSxDQUFDQyxNQUFNLEdBQUd0VyxPQUFPcVcsTUFBTSxDQUFDO1FBQzVCLElBQUksQ0FBQ0UsaUJBQWlCLEdBQUd2VyxPQUFPcVcsTUFBTSxDQUFDO1FBQ3ZDLElBQUksQ0FBQ0csZUFBZSxHQUFHO1FBQ3ZCLElBQUksQ0FBQ0Msb0JBQW9CLEdBQUc7UUFDNUIsSUFBSSxDQUFDN0wsTUFBTSxHQUFHO1FBQ2QsSUFBSSxDQUFDOEwsUUFBUSxHQUFHLEVBQUU7UUFFbEIsSUFBSSxDQUFDL1csUUFBUUEsS0FBS2dYLFFBQVEsS0FBSyxHQUFHO1lBQ2hDLGVBQWU7WUFDZjtRQUNGLEVBQUUsaUJBQWlCO1FBR25CQyxNQUFNQyxJQUFJLENBQUNsWCxLQUFLeVcsVUFBVSxFQUFFMUwsT0FBTyxDQUFDb00sQ0FBQUE7WUFDbEMsSUFBSUMsV0FBV2pXLHVCQUF1QmdXLFVBQVVDLFFBQVE7WUFDeEQsSUFBSSxDQUFDWCxVQUFVLENBQUNXLFNBQVMsR0FBRyxJQUFJaFQsU0FBU0UsV0FBVThTLFVBQVVELFVBQVU1UyxLQUFLO1FBQzlFO1FBQ0EsSUFBSSxDQUFDOFMsNEJBQTRCLElBQUksb0JBQW9CO1FBRXpELElBQUksSUFBSSxDQUFDM1AsWUFBWSxDQUFDLFNBQVM1QyxRQUFRLElBQUk7WUFDekMsSUFBSTZSLFNBQVMsSUFBSSxDQUFDalAsWUFBWSxDQUFDLFNBQVM5QyxTQUFTLEdBQUdGLEtBQUssQ0FBQyxLQUFLMUQsR0FBRyxDQUFDME0sQ0FBQUEsSUFBS0EsRUFBRTdJLElBQUk7WUFDOUU4UixPQUFPNUwsT0FBTyxDQUFDRixDQUFBQTtnQkFDYixJQUFJLENBQUNBLE9BQU87b0JBQ1Y7Z0JBQ0Y7Z0JBRUEsSUFBSSxDQUFDekosTUFBTW1ELE1BQU0sR0FBR3NHLE1BQU1uRyxLQUFLLENBQUMsS0FBSzFELEdBQUcsQ0FBQzBNLENBQUFBLElBQUtBLEVBQUU3SSxJQUFJO2dCQUNwRCxJQUFJLENBQUM4UixNQUFNLENBQUN2VixLQUFLLEdBQUcsSUFBSWdELFNBQVNFLFdBQVVsRCxNQUFNbUQ7WUFDbkQ7UUFDRjtRQUVBLElBQUksRUFDRjBDLFdBQVcsRUFDWixHQUFHM0M7UUFDSixJQUFJZ1QsS0FBSyxJQUFJLENBQUM1UCxZQUFZLENBQUMsT0FBTyxTQUFTO1FBRTNDLElBQUk0UCxHQUFHeFMsUUFBUSxJQUFJO1lBQ2pCLElBQUksQ0FBQ21DLFdBQVcsQ0FBQ3FRLEdBQUcxUyxTQUFTLEdBQUcsRUFBRTtnQkFDaENxQyxXQUFXLENBQUNxUSxHQUFHMVMsU0FBUyxHQUFHLEdBQUcsSUFBSTtZQUNwQztRQUNGO1FBRUFxUyxNQUFNQyxJQUFJLENBQUNsWCxLQUFLdVgsVUFBVSxFQUFFeE0sT0FBTyxDQUFDeU0sQ0FBQUE7WUFDbEMsSUFBSUEsVUFBVVIsUUFBUSxLQUFLLEdBQUc7Z0JBQzVCLElBQUksQ0FBQ1MsUUFBUSxDQUFDRCxZQUFZLGVBQWU7WUFDM0MsT0FBTyxJQUFJaEIsb0JBQXFCZ0IsQ0FBQUEsVUFBVVIsUUFBUSxLQUFLLEtBQUtRLFVBQVVSLFFBQVEsS0FBSyxJQUFJO2dCQUNyRixJQUFJVSxXQUFXcFQsVUFBU3FULGNBQWMsQ0FBQ0g7Z0JBRXZDLElBQUlFLFNBQVNFLE9BQU8sR0FBRy9ZLE1BQU0sR0FBRyxHQUFHO29CQUNqQyxJQUFJLENBQUM0WSxRQUFRLENBQUNDLFdBQVcsWUFBWTtnQkFDdkM7WUFDRjtRQUNGO0lBQ0Y7SUFFQWhRLGFBQWF0RyxJQUFJLEVBQUU7UUFDakIsSUFBSXlXLG9CQUFvQmpaLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQzVGLElBQUlrWixPQUFPLElBQUksQ0FBQ3JCLFVBQVUsQ0FBQ3JWLEtBQUs7UUFFaEMsSUFBSSxDQUFDMFcsUUFBUUQsbUJBQW1CO1lBQzlCLElBQUlFLFFBQVEsSUFBSTNULFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUVsRCxNQUFNO1lBRTlDLElBQUksQ0FBQ3FWLFVBQVUsQ0FBQ3JWLEtBQUssR0FBRzJXO1lBQ3hCLE9BQU9BO1FBQ1Q7UUFFQSxPQUFPRCxRQUFRMVQsU0FBU0ssS0FBSyxDQUFDLElBQUksQ0FBQ0gsUUFBUTtJQUM3QztJQUVBa0QsbUJBQW1CO1FBQ2pCLElBQUssSUFBSXdRLE9BQU8sSUFBSSxDQUFDdkIsVUFBVSxDQUFFO1lBQy9CLElBQUl1QixRQUFRLFVBQVVBLElBQUkxUyxRQUFRLENBQUMsVUFBVTtnQkFDM0MsT0FBTyxJQUFJLENBQUNtUixVQUFVLENBQUN1QixJQUFJO1lBQzdCO1FBQ0Y7UUFFQSxPQUFPNVQsU0FBU0ssS0FBSyxDQUFDLElBQUksQ0FBQ0gsUUFBUTtJQUNyQztJQUVBa04sU0FBU3BRLElBQUksRUFBRTtRQUNiLElBQUl5VyxvQkFBb0JqWixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUM1RixJQUFJcVosZ0JBQWdCclosVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDeEYsSUFBSWlNLFFBQVEsSUFBSSxDQUFDOEwsTUFBTSxDQUFDdlYsS0FBSztRQUU3QixJQUFJeUosT0FBTztZQUNULE9BQU9BO1FBQ1Q7UUFFQSxJQUFJaU4sT0FBTyxJQUFJLENBQUNwUSxZQUFZLENBQUN0RztRQUU3QixJQUFJMFcsU0FBUyxRQUFRQSxTQUFTLEtBQUssS0FBS0EsS0FBS2hULFFBQVEsSUFBSTtZQUN2RCxJQUFJLENBQUM2UixNQUFNLENBQUN2VixLQUFLLEdBQUcwVyxNQUFNLHlCQUF5QjtZQUVuRCxPQUFPQTtRQUNUO1FBRUEsSUFBSSxDQUFDRyxlQUFlO1lBQ2xCLElBQUksRUFDRmhOLE1BQU0sRUFDUCxHQUFHLElBQUk7WUFFUixJQUFJQSxRQUFRO2dCQUNWLElBQUlpTixjQUFjak4sT0FBT3VHLFFBQVEsQ0FBQ3BRO2dCQUVsQyxJQUFJOFcsZ0JBQWdCLFFBQVFBLGdCQUFnQixLQUFLLEtBQUtBLFlBQVlwVCxRQUFRLElBQUk7b0JBQzVFLE9BQU9vVDtnQkFDVDtZQUNGO1FBQ0Y7UUFFQSxJQUFJTCxtQkFBbUI7WUFDckIsSUFBSU0sU0FBUyxJQUFJL1QsU0FBUyxJQUFJLENBQUNFLFFBQVEsRUFBRWxELE1BQU07WUFFL0MsSUFBSSxDQUFDdVYsTUFBTSxDQUFDdlYsS0FBSyxHQUFHK1c7WUFDcEIsT0FBT0E7UUFDVDtRQUVBLE9BQU90TixTQUFTekcsU0FBU0ssS0FBSyxDQUFDLElBQUksQ0FBQ0gsUUFBUTtJQUM5QztJQUVBdU0sT0FBT3ZKLEdBQUcsRUFBRTtRQUNWLDRCQUE0QjtRQUM1QixpQ0FBaUM7UUFDakMsSUFBSSxJQUFJLENBQUNrSyxRQUFRLENBQUMsV0FBVzVNLFNBQVMsT0FBTyxVQUFVLElBQUksQ0FBQzRNLFFBQVEsQ0FBQyxjQUFjNU0sU0FBUyxPQUFPLFVBQVU7WUFDM0c7UUFDRjtRQUVBMEMsSUFBSThRLElBQUk7UUFFUixJQUFJLElBQUksQ0FBQzVHLFFBQVEsQ0FBQyxRQUFRMU0sUUFBUSxJQUFJO1lBQ3BDLE9BQU87WUFDUCxJQUFJdVQsT0FBTyxJQUFJLENBQUM3RyxRQUFRLENBQUMsUUFBUXhLLGFBQWE7WUFFOUMsSUFBSXFSLE1BQU07Z0JBQ1IsSUFBSSxDQUFDQyxZQUFZLENBQUNoUjtnQkFDbEIrUSxLQUFLNUUsS0FBSyxDQUFDbk0sS0FBSyxJQUFJO1lBQ3RCO1FBQ0YsT0FBTyxJQUFJLElBQUksQ0FBQ2tLLFFBQVEsQ0FBQyxVQUFVaE0sUUFBUSxDQUFDLFlBQVksUUFBUTtZQUM5RCxTQUFTO1lBQ1QsSUFBSStTLFNBQVMsSUFBSSxDQUFDL0csUUFBUSxDQUFDLFVBQVV4SyxhQUFhO1lBRWxELElBQUl1UixRQUFRO2dCQUNWLElBQUksQ0FBQ0QsWUFBWSxDQUFDaFI7Z0JBQ2xCaVIsT0FBTzlFLEtBQUssQ0FBQ25NLEtBQUssSUFBSTtZQUN4QjtRQUNGLE9BQU87WUFDTCxJQUFJLENBQUNrUixVQUFVLENBQUNsUjtZQUNoQixJQUFJLENBQUNtUixjQUFjLENBQUNuUjtZQUNwQixJQUFJLENBQUNvUixZQUFZLENBQUNwUjtRQUNwQjtRQUVBQSxJQUFJcVIsT0FBTztJQUNiO0lBRUFILFdBQVc5SyxDQUFDLEVBQUUsQ0FDZDtJQUVBNEssYUFBYWhSLEdBQUcsRUFBRTtRQUNoQixZQUFZO1FBQ1osSUFBSXNDLFlBQVlpTSxVQUFVSyxXQUFXLENBQUMsSUFBSSxDQUFDNVIsUUFBUSxFQUFFLElBQUk7UUFFekQsSUFBSXNGLFdBQVc7WUFDYkEsVUFBVTZKLEtBQUssQ0FBQ25NO1FBQ2xCLEVBQUUsT0FBTztRQUdULElBQUlzUixvQkFBb0IsSUFBSSxDQUFDcEgsUUFBUSxDQUFDLGFBQWEsT0FBTztRQUUxRCxJQUFJb0gsa0JBQWtCOVQsUUFBUSxJQUFJO1lBQ2hDLElBQUkySixPQUFPbUssa0JBQWtCNVIsYUFBYTtZQUUxQyxJQUFJeUgsTUFBTTtnQkFDUkEsS0FBS2dGLEtBQUssQ0FBQ25NO1lBQ2I7UUFDRjtJQUNGO0lBRUFvUixhQUFhaEwsQ0FBQyxFQUFFLENBQ2hCO0lBRUErSyxlQUFlblIsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQ3lQLFFBQVEsQ0FBQ2hNLE9BQU8sQ0FBQzhOLENBQUFBO1lBQ3BCQSxNQUFNaEksTUFBTSxDQUFDdko7UUFDZjtJQUNGO0lBRUFtUSxTQUFTRCxTQUFTLEVBQUU7UUFDbEIsSUFBSXFCLFFBQVFyQixxQkFBcUJqQixVQUFVaUIsWUFBWSxJQUFJLENBQUNsVCxRQUFRLENBQUN3VSxhQUFhLENBQUN0QjtRQUNuRnFCLE1BQU01TixNQUFNLEdBQUcsSUFBSTtRQUVuQixJQUFJLENBQUNzTCxRQUFRd0MsZ0JBQWdCLENBQUNDLFFBQVEsQ0FBQ0gsTUFBTTNNLElBQUksR0FBRztZQUNsRCxJQUFJLENBQUM2SyxRQUFRLENBQUN2TyxJQUFJLENBQUNxUTtRQUNyQjtJQUNGO0lBRUFJLGdCQUFnQnJXLFFBQVEsRUFBRTtRQUN4QixJQUFJc1c7UUFFSixJQUFJLEVBQ0ZsWixJQUFJLEVBQ0wsR0FBRyxJQUFJO1FBRVIsSUFBSSxPQUFPQSxLQUFLYyxPQUFPLEtBQUssWUFBWTtZQUN0QyxPQUFPZCxLQUFLYyxPQUFPLENBQUM4QjtRQUN0QjtRQUVBLElBQUl1VyxlQUFlLENBQUNELHFCQUFxQmxaLEtBQUswSCxZQUFZLE1BQU0sUUFBUXdSLHVCQUF1QixLQUFLLElBQUksS0FBSyxJQUFJQSxtQkFBbUJFLElBQUksQ0FBQ3BaLE1BQU07UUFFL0ksSUFBSSxDQUFDbVosZ0JBQWdCQSxpQkFBaUIsSUFBSTtZQUN4QyxPQUFPO1FBQ1Q7UUFFQSxPQUFPQSxhQUFhelUsS0FBSyxDQUFDLEtBQUsyVSxJQUFJLENBQUNDLENBQUFBLGFBQWMsSUFBSTVILE1BQU0sQ0FBQzRILGdCQUFnQjFXO0lBQy9FO0lBRUF5VSwrQkFBK0I7UUFDN0IsSUFBSSxFQUNGVixNQUFNLEVBQ05DLGlCQUFpQixFQUNsQixHQUFHLElBQUksQ0FBQ3RTLFFBQVE7UUFFakIsSUFBSyxJQUFJMUIsWUFBWStULE9BQVE7WUFDM0IsSUFBSSxDQUFDL1QsU0FBU2hCLFVBQVUsQ0FBQyxRQUFRLElBQUksQ0FBQ3FYLGVBQWUsQ0FBQ3JXLFdBQVc7Z0JBQy9ELElBQUlpSSxRQUFROEwsTUFBTSxDQUFDL1QsU0FBUztnQkFDNUIsSUFBSUcsY0FBYzZULGlCQUFpQixDQUFDaFUsU0FBUztnQkFFN0MsSUFBSWlJLE9BQU87b0JBQ1QsSUFBSyxJQUFJekosUUFBUXlKLE1BQU87d0JBQ3RCLElBQUkwTyxzQkFBc0IsSUFBSSxDQUFDM0MsaUJBQWlCLENBQUN4VixLQUFLO3dCQUV0RCxJQUFJLE9BQU9tWSx3QkFBd0IsYUFBYTs0QkFDOUNBLHNCQUFzQjt3QkFDeEI7d0JBRUEsSUFBSXhXLGVBQWV3VyxxQkFBcUI7NEJBQ3RDLElBQUksQ0FBQzVDLE1BQU0sQ0FBQ3ZWLEtBQUssR0FBR3lKLEtBQUssQ0FBQ3pKLEtBQUs7NEJBQy9CLElBQUksQ0FBQ3dWLGlCQUFpQixDQUFDeFYsS0FBSyxHQUFHMkI7d0JBQ2pDO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0lBRUF5VyxhQUFhclMsT0FBTyxFQUFFc1MsWUFBWSxFQUFFO1FBQ2xDLElBQUlDLFlBQVlELGFBQWFySSxNQUFNLENBQUMsQ0FBQ3NJLFdBQVd0WTtZQUM5QyxJQUFJdVksWUFBWXhTLFFBQVFxSyxRQUFRLENBQUNwUTtZQUVqQyxJQUFJLENBQUN1WSxVQUFVN1UsUUFBUSxJQUFJO2dCQUN6QixPQUFPNFU7WUFDVDtZQUVBLElBQUluVixRQUFRb1YsVUFBVS9VLFNBQVM7WUFDL0IrVSxVQUFVcFUsUUFBUSxDQUFDO1lBQ25CLE9BQU87bUJBQUltVTtnQkFBVztvQkFBQ3RZO29CQUFNbUQ7aUJBQU07YUFBQztRQUN0QyxHQUFHLEVBQUU7UUFDTCxPQUFPbVY7SUFDVDtJQUVBRSxjQUFjelMsT0FBTyxFQUFFd1AsTUFBTSxFQUFFO1FBQzdCQSxPQUFPNUwsT0FBTyxDQUFDOUssQ0FBQUE7WUFDYixJQUFJLENBQUNtQixNQUFNbUQsTUFBTSxHQUFHdEU7WUFDcEJrSCxRQUFRcUssUUFBUSxDQUFDcFEsTUFBTSxNQUFNbUUsUUFBUSxDQUFDaEI7UUFDeEM7SUFDRjtJQUVBc1YsZUFBZTtRQUNiLElBQUlDO1FBRUosT0FBTyxDQUFDLENBQUNBLGVBQWUsSUFBSSxDQUFDN08sTUFBTSxNQUFNLFFBQVE2TyxpQkFBaUIsS0FBSyxJQUFJLEtBQUssSUFBSUEsYUFBYS9DLFFBQVEsQ0FBQ2dELE9BQU8sQ0FBQyxJQUFJLE9BQU87SUFDL0g7QUFFRjtBQUNBeEQsUUFBUXdDLGdCQUFnQixHQUFHO0lBQUM7Q0FBUTtBQUVwQyxNQUFNaUIsdUJBQXVCekQ7SUFDM0JsUyxZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO0lBQ3hCO0FBRUY7QUFFQSxTQUFTeUQsZUFBZUMsVUFBVTtJQUNoQyxJQUFJQyxVQUFVRCxXQUFXclYsSUFBSTtJQUM3QixPQUFPLFNBQVN4RCxJQUFJLENBQUM4WSxXQUFXQSxVQUFVLElBQUt6SSxNQUFNLENBQUN5SSxTQUFTO0FBQ2pFO0FBRUEsU0FBU0Msa0JBQWtCRixVQUFVO0lBQ25DLE9BQU8sT0FBT0csWUFBWSxjQUFjSCxhQUFhQSxXQUFXclYsSUFBSSxHQUFHSCxLQUFLLENBQUMsS0FBSzFELEdBQUcsQ0FBQ2laLGdCQUFnQi9XLElBQUksQ0FBQztBQUM3RztBQUNBOzs7O0NBSUMsR0FHRCxTQUFTb1gsaUJBQWlCQyxTQUFTO0lBQ2pDLElBQUksQ0FBQ0EsV0FBVztRQUNkLE9BQU87SUFDVDtJQUVBLElBQUlDLGtCQUFrQkQsVUFBVTFWLElBQUksR0FBR3ZELFdBQVc7SUFFbEQsT0FBUWtaO1FBQ04sS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1lBQ0gsT0FBT0E7UUFFVDtZQUNFLElBQUkseUJBQXlCblosSUFBSSxDQUFDbVosa0JBQWtCO2dCQUNsRCxPQUFPQTtZQUNUO1lBRUEsT0FBTztJQUNYO0FBQ0Y7QUFDQTs7OztDQUlDLEdBR0QsU0FBU0Msa0JBQWtCQyxVQUFVO0lBQ25DLElBQUksQ0FBQ0EsWUFBWTtRQUNmLE9BQU87SUFDVDtJQUVBLElBQUlDLG1CQUFtQkQsV0FBVzdWLElBQUksR0FBR3ZELFdBQVc7SUFFcEQsT0FBUXFaO1FBQ04sS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztRQUNMLEtBQUs7UUFDTCxLQUFLO1FBQ0wsS0FBSztZQUNILE9BQU9BO1FBRVQ7WUFDRSxJQUFJLFdBQVd0WixJQUFJLENBQUNzWixtQkFBbUI7Z0JBQ3JDLE9BQU9BO1lBQ1Q7WUFFQSxPQUFPO0lBQ1g7QUFDRjtBQUVBLE1BQU1DO0lBQ0p2VyxZQUFZa1csU0FBUyxFQUFFTSxXQUFXLEVBQUVILFVBQVUsRUFBRUksUUFBUSxFQUFFWixVQUFVLEVBQUVhLE9BQU8sQ0FBRTtRQUM3RSxJQUFJQyxjQUFjRCxVQUFVLE9BQU9BLFlBQVksV0FBV0gsS0FBSzVSLEtBQUssQ0FBQytSLFdBQVdBLFVBQVUsQ0FBQztRQUMzRixJQUFJLENBQUNiLFVBQVUsR0FBR0EsY0FBY2MsWUFBWWQsVUFBVTtRQUN0RCxJQUFJLENBQUNZLFFBQVEsR0FBR0EsWUFBWUUsWUFBWUYsUUFBUTtRQUNoRCxJQUFJLENBQUNQLFNBQVMsR0FBR0EsYUFBYVMsWUFBWVQsU0FBUztRQUNuRCxJQUFJLENBQUNHLFVBQVUsR0FBR0EsY0FBY00sWUFBWU4sVUFBVTtRQUN0RCxJQUFJLENBQUNHLFdBQVcsR0FBR0EsZUFBZUcsWUFBWUgsV0FBVztJQUMzRDtJQUVBLE9BQU83UixRQUFRO1FBQ2IsSUFBSWlTLE9BQU9yYyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUMvRSxJQUFJbWMsVUFBVW5jLFVBQVVDLE1BQU0sR0FBRyxJQUFJRCxTQUFTLENBQUMsRUFBRSxHQUFHRTtRQUNwRCxJQUFJeWIsWUFBWTtRQUNoQixJQUFJTSxjQUFjO1FBQ2xCLElBQUlILGFBQWE7UUFDakIsSUFBSUksV0FBVztRQUNmLElBQUlaLGFBQWE7UUFDakIsSUFBSWdCLFFBQVExYSxlQUFleWEsTUFBTXBXLElBQUksR0FBR0gsS0FBSyxDQUFDO1FBQzlDLElBQUl5VyxNQUFNO1lBQ1JMLFVBQVU7WUFDVlAsV0FBVztZQUNYRyxZQUFZO1lBQ1pHLGFBQWE7UUFDZjtRQUNBSyxNQUFNblEsT0FBTyxDQUFDcVEsQ0FBQUE7WUFDWixPQUFRO2dCQUNOLEtBQUssQ0FBQ0QsSUFBSVosU0FBUyxJQUFJSyxLQUFLakUsTUFBTSxDQUFDcUMsUUFBUSxDQUFDb0M7b0JBQzFDLElBQUlBLFNBQVMsV0FBVzt3QkFDdEJiLFlBQVlhO29CQUNkO29CQUVBRCxJQUFJWixTQUFTLEdBQUc7b0JBQ2hCO2dCQUVGLEtBQUssQ0FBQ1ksSUFBSU4sV0FBVyxJQUFJRCxLQUFLUyxRQUFRLENBQUNyQyxRQUFRLENBQUNvQztvQkFDOUMsSUFBSUEsU0FBUyxXQUFXO3dCQUN0QlAsY0FBY087b0JBQ2hCO29CQUVBRCxJQUFJWixTQUFTLEdBQUc7b0JBQ2hCWSxJQUFJTixXQUFXLEdBQUc7b0JBQ2xCO2dCQUVGLEtBQUssQ0FBQ00sSUFBSVQsVUFBVSxJQUFJRSxLQUFLVSxPQUFPLENBQUN0QyxRQUFRLENBQUNvQztvQkFDNUMsSUFBSUEsU0FBUyxXQUFXO3dCQUN0QlYsYUFBYVU7b0JBQ2Y7b0JBRUFELElBQUlaLFNBQVMsR0FBRztvQkFDaEJZLElBQUlOLFdBQVcsR0FBRztvQkFDbEJNLElBQUlULFVBQVUsR0FBRztvQkFDakI7Z0JBRUYsS0FBSyxDQUFDUyxJQUFJTCxRQUFRO29CQUNoQixJQUFJTSxTQUFTLFdBQVc7d0JBQ3RCLENBQUNOLFNBQVMsR0FBR00sS0FBSzFXLEtBQUssQ0FBQztvQkFDMUI7b0JBRUF5VyxJQUFJWixTQUFTLEdBQUc7b0JBQ2hCWSxJQUFJTixXQUFXLEdBQUc7b0JBQ2xCTSxJQUFJVCxVQUFVLEdBQUc7b0JBQ2pCUyxJQUFJTCxRQUFRLEdBQUc7b0JBQ2Y7Z0JBRUY7b0JBQ0UsSUFBSU0sU0FBUyxXQUFXO3dCQUN0QmxCLGNBQWNrQjtvQkFDaEI7WUFFSjtRQUNGO1FBQ0EsT0FBTyxJQUFJUixLQUFLTCxXQUFXTSxhQUFhSCxZQUFZSSxVQUFVWixZQUFZYTtJQUM1RTtJQUVBUSxXQUFXO1FBQ1QsT0FBTztZQUFDakIsaUJBQWlCLElBQUksQ0FBQ0MsU0FBUztZQUFHLElBQUksQ0FBQ00sV0FBVztZQUFFSixrQkFBa0IsSUFBSSxDQUFDQyxVQUFVO1lBQUcsSUFBSSxDQUFDSSxRQUFRO1lBQzdHVixrQkFBa0IsSUFBSSxDQUFDRixVQUFVO1NBQUUsQ0FBQ2hYLElBQUksQ0FBQyxLQUFLMkIsSUFBSTtJQUNwRDtBQUVGO0FBQ0ErVixLQUFLakUsTUFBTSxHQUFHO0FBQ2RpRSxLQUFLUyxRQUFRLEdBQUc7QUFDaEJULEtBQUtVLE9BQU8sR0FBRztBQUVmLE1BQU1FO0lBQ0puWCxhQUFjO1FBQ1osSUFBSW9YLEtBQUs3YyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRzhjLE9BQU9DLEdBQUc7UUFDdkYsSUFBSUMsS0FBS2hkLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHOGMsT0FBT0MsR0FBRztRQUN2RixJQUFJRSxLQUFLamQsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUc4YyxPQUFPQyxHQUFHO1FBQ3ZGLElBQUlHLEtBQUtsZCxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRzhjLE9BQU9DLEdBQUc7UUFDdkYsSUFBSSxDQUFDRixFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDRyxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDQyxFQUFFLEdBQUdBO1FBQ1YsSUFBSSxDQUFDQyxRQUFRLENBQUNOLElBQUlHO1FBQ2xCLElBQUksQ0FBQ0csUUFBUSxDQUFDRixJQUFJQztJQUNwQjtJQUVBLElBQUloVCxJQUFJO1FBQ04sT0FBTyxJQUFJLENBQUMyUyxFQUFFO0lBQ2hCO0lBRUEsSUFBSTFTLElBQUk7UUFDTixPQUFPLElBQUksQ0FBQzZTLEVBQUU7SUFDaEI7SUFFQSxJQUFJeGMsUUFBUTtRQUNWLE9BQU8sSUFBSSxDQUFDeWMsRUFBRSxHQUFHLElBQUksQ0FBQ0osRUFBRTtJQUMxQjtJQUVBLElBQUlwYyxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUN5YyxFQUFFLEdBQUcsSUFBSSxDQUFDRixFQUFFO0lBQzFCO0lBRUFHLFNBQVNqVCxDQUFDLEVBQUVDLENBQUMsRUFBRTtRQUNiLElBQUksT0FBT0QsTUFBTSxhQUFhO1lBQzVCLElBQUlxSixNQUFNLElBQUksQ0FBQ3NKLEVBQUUsS0FBS3RKLE1BQU0sSUFBSSxDQUFDMEosRUFBRSxHQUFHO2dCQUNwQyxJQUFJLENBQUNKLEVBQUUsR0FBRzNTO2dCQUNWLElBQUksQ0FBQytTLEVBQUUsR0FBRy9TO1lBQ1o7WUFFQSxJQUFJQSxJQUFJLElBQUksQ0FBQzJTLEVBQUUsRUFBRTtnQkFDZixJQUFJLENBQUNBLEVBQUUsR0FBRzNTO1lBQ1o7WUFFQSxJQUFJQSxJQUFJLElBQUksQ0FBQytTLEVBQUUsRUFBRTtnQkFDZixJQUFJLENBQUNBLEVBQUUsR0FBRy9TO1lBQ1o7UUFDRjtRQUVBLElBQUksT0FBT0MsTUFBTSxhQUFhO1lBQzVCLElBQUlvSixNQUFNLElBQUksQ0FBQ3lKLEVBQUUsS0FBS3pKLE1BQU0sSUFBSSxDQUFDMkosRUFBRSxHQUFHO2dCQUNwQyxJQUFJLENBQUNGLEVBQUUsR0FBRzdTO2dCQUNWLElBQUksQ0FBQytTLEVBQUUsR0FBRy9TO1lBQ1o7WUFFQSxJQUFJQSxJQUFJLElBQUksQ0FBQzZTLEVBQUUsRUFBRTtnQkFDZixJQUFJLENBQUNBLEVBQUUsR0FBRzdTO1lBQ1o7WUFFQSxJQUFJQSxJQUFJLElBQUksQ0FBQytTLEVBQUUsRUFBRTtnQkFDZixJQUFJLENBQUNBLEVBQUUsR0FBRy9TO1lBQ1o7UUFDRjtJQUNGO0lBRUFpVCxLQUFLbFQsQ0FBQyxFQUFFO1FBQ04sSUFBSSxDQUFDaVQsUUFBUSxDQUFDalQsR0FBRztJQUNuQjtJQUVBbVQsS0FBS2xULENBQUMsRUFBRTtRQUNOLElBQUksQ0FBQ2dULFFBQVEsQ0FBQyxNQUFNaFQ7SUFDdEI7SUFFQW1ULGVBQWU1USxXQUFXLEVBQUU7UUFDMUIsSUFBSSxDQUFDQSxhQUFhO1lBQ2hCO1FBQ0Y7UUFFQSxJQUFJLEVBQ0ZtUSxFQUFFLEVBQ0ZHLEVBQUUsRUFDRkMsRUFBRSxFQUNGQyxFQUFFLEVBQ0gsR0FBR3hRO1FBQ0osSUFBSSxDQUFDeVEsUUFBUSxDQUFDTixJQUFJRztRQUNsQixJQUFJLENBQUNHLFFBQVEsQ0FBQ0YsSUFBSUM7SUFDcEI7SUFFQUssU0FBU3RZLENBQUMsRUFBRXVZLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRTtRQUMxQixPQUFPcmEsS0FBS3FCLEdBQUcsQ0FBQyxJQUFJTSxHQUFHLEtBQUt1WSxLQUFLLElBQUlsYSxLQUFLcUIsR0FBRyxDQUFDLElBQUlNLEdBQUcsS0FBS0EsSUFBSXdZLEtBQUssSUFBSyxLQUFJeFksQ0FBQUEsSUFBSzNCLEtBQUtxQixHQUFHLENBQUNNLEdBQUcsS0FBS3lZLEtBQUtwYSxLQUFLcUIsR0FBRyxDQUFDTSxHQUFHLEtBQUswWTtJQUMxSDtJQUVBQyxlQUFlQyxJQUFJLEVBQUVMLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRTtRQUNuQyxJQUFJeEgsSUFBSSxJQUFJcUgsS0FBSyxLQUFLQyxLQUFLLElBQUlDO1FBQy9CLElBQUl4SCxJQUFJLENBQUMsSUFBSXNILEtBQUssSUFBSUMsS0FBSyxJQUFJQyxLQUFLLElBQUlDO1FBQ3hDLElBQUl2SCxJQUFJLElBQUlxSCxLQUFLLElBQUlEO1FBRXJCLElBQUl0SCxNQUFNLEdBQUc7WUFDWCxJQUFJQyxNQUFNLEdBQUc7Z0JBQ1g7WUFDRjtZQUVBLElBQUlsUixJQUFJLENBQUNtUixJQUFJRDtZQUViLElBQUksSUFBSWxSLEtBQUtBLElBQUksR0FBRztnQkFDbEIsSUFBSTRZLE1BQU07b0JBQ1IsSUFBSSxDQUFDVCxJQUFJLENBQUMsSUFBSSxDQUFDRyxRQUFRLENBQUN0WSxHQUFHdVksSUFBSUMsSUFBSUMsSUFBSUM7Z0JBQ3pDLE9BQU87b0JBQ0wsSUFBSSxDQUFDTixJQUFJLENBQUMsSUFBSSxDQUFDRSxRQUFRLENBQUN0WSxHQUFHdVksSUFBSUMsSUFBSUMsSUFBSUM7Z0JBQ3pDO1lBQ0Y7WUFFQTtRQUNGO1FBRUEsSUFBSUcsT0FBT3hhLEtBQUtxQixHQUFHLENBQUN3UixHQUFHLEtBQUssSUFBSUMsSUFBSUY7UUFFcEMsSUFBSTRILE9BQU8sR0FBRztZQUNaO1FBQ0Y7UUFFQSxJQUFJQyxLQUFLLENBQUMsQ0FBQzVILElBQUk3UyxLQUFLb0IsSUFBSSxDQUFDb1osS0FBSSxJQUFNLEtBQUk1SCxDQUFBQTtRQUV2QyxJQUFJLElBQUk2SCxNQUFNQSxLQUFLLEdBQUc7WUFDcEIsSUFBSUYsTUFBTTtnQkFDUixJQUFJLENBQUNULElBQUksQ0FBQyxJQUFJLENBQUNHLFFBQVEsQ0FBQ1EsSUFBSVAsSUFBSUMsSUFBSUMsSUFBSUM7WUFDMUMsT0FBTztnQkFDTCxJQUFJLENBQUNOLElBQUksQ0FBQyxJQUFJLENBQUNFLFFBQVEsQ0FBQ1EsSUFBSVAsSUFBSUMsSUFBSUMsSUFBSUM7WUFDMUM7UUFDRjtRQUVBLElBQUlLLEtBQUssQ0FBQyxDQUFDN0gsSUFBSTdTLEtBQUtvQixJQUFJLENBQUNvWixLQUFJLElBQU0sS0FBSTVILENBQUFBO1FBRXZDLElBQUksSUFBSThILE1BQU1BLEtBQUssR0FBRztZQUNwQixJQUFJSCxNQUFNO2dCQUNSLElBQUksQ0FBQ1QsSUFBSSxDQUFDLElBQUksQ0FBQ0csUUFBUSxDQUFDUyxJQUFJUixJQUFJQyxJQUFJQyxJQUFJQztZQUMxQyxPQUFPO2dCQUNMLElBQUksQ0FBQ04sSUFBSSxDQUFDLElBQUksQ0FBQ0UsUUFBUSxDQUFDUyxJQUFJUixJQUFJQyxJQUFJQyxJQUFJQztZQUMxQztRQUNGO0lBQ0Y7SUFHQU0sZUFBZUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUU7UUFDckQsSUFBSSxDQUFDdEIsUUFBUSxDQUFDZSxLQUFLQztRQUNuQixJQUFJLENBQUNoQixRQUFRLENBQUNxQixLQUFLQztRQUNuQixJQUFJLENBQUNiLGNBQWMsQ0FBQyxNQUFNTSxLQUFLRSxLQUFLRSxLQUFLRTtRQUN6QyxJQUFJLENBQUNaLGNBQWMsQ0FBQyxPQUFPTyxLQUFLRSxLQUFLRSxLQUFLRTtJQUM1QztJQUVBQyxrQkFBa0JSLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUU7UUFDOUMsSUFBSUksT0FBT1QsTUFBTSxJQUFJLElBQUtFLENBQUFBLE1BQU1GLEdBQUUsR0FBSSw2QkFBNkI7UUFFbkUsSUFBSVUsT0FBT1QsTUFBTSxJQUFJLElBQUtFLENBQUFBLE1BQU1GLEdBQUUsR0FBSSw2QkFBNkI7UUFFbkUsSUFBSVUsT0FBT0YsT0FBTyxJQUFJLElBQUtMLENBQUFBLE1BQU1KLEdBQUUsR0FBSSw2QkFBNkI7UUFFcEUsSUFBSVksT0FBT0YsT0FBTyxJQUFJLElBQUtMLENBQUFBLE1BQU1KLEdBQUUsR0FBSSw2QkFBNkI7UUFFcEUsSUFBSSxDQUFDRixjQUFjLENBQUNDLEtBQUtDLEtBQUtRLE1BQU1FLE1BQU1ELE1BQU1FLE1BQU1SLEtBQUtDO0lBQzdEO0lBRUEzUixhQUFhMUMsQ0FBQyxFQUFFQyxDQUFDLEVBQUU7UUFDakIsSUFBSSxFQUNGMFMsRUFBRSxFQUNGRyxFQUFFLEVBQ0ZDLEVBQUUsRUFDRkMsRUFBRSxFQUNILEdBQUcsSUFBSTtRQUNSLE9BQU9MLE1BQU0zUyxLQUFLQSxLQUFLK1MsTUFBTUQsTUFBTTdTLEtBQUtBLEtBQUsrUztJQUMvQztBQUVGO0FBRUEsTUFBTTZCLG1CQUFtQnBmLHNEQUFXQTtJQUNsQzhGLFlBQVlpRixJQUFJLENBQUU7UUFDaEIsS0FBSyxDQUFDQSxLQUFLLDBCQUEwQjtTQUNwQzVJLE9BQU8sQ0FBQyxpQkFBaUIsTUFBTSx1QkFBdUI7U0FDdERBLE9BQU8sQ0FBQyx1Q0FBdUM7UUFDaEQsSUFBSSxDQUFDa2QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDclQsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDc1QsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxPQUFPLEdBQUc7UUFDZixJQUFJLENBQUNDLFFBQVEsR0FBRyxJQUFJLENBQUNBLFFBQVE7UUFDN0IsSUFBSSxDQUFDL1YsQ0FBQyxHQUFHLENBQUM7UUFDVixJQUFJLENBQUNnVyxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDelUsTUFBTSxHQUFHLEVBQUU7UUFDaEIsSUFBSSxDQUFDMFUsTUFBTSxHQUFHLEVBQUU7SUFDbEI7SUFFQUMsUUFBUTtRQUNOLElBQUksQ0FBQ2xXLENBQUMsR0FBRyxDQUFDO1FBQ1YsSUFBSSxDQUFDOFYsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDRSxlQUFlLEdBQUc7UUFDdkIsSUFBSSxDQUFDelQsS0FBSyxHQUFHLElBQUkxQixNQUFNLEdBQUc7UUFDMUIsSUFBSSxDQUFDK1UsT0FBTyxHQUFHLElBQUkvVSxNQUFNLEdBQUc7UUFDNUIsSUFBSSxDQUFDZ1YsT0FBTyxHQUFHLElBQUloVixNQUFNLEdBQUc7UUFDNUIsSUFBSSxDQUFDVSxNQUFNLEdBQUcsRUFBRTtRQUNoQixJQUFJLENBQUMwVSxNQUFNLEdBQUcsRUFBRTtJQUNsQjtJQUVBRSxRQUFRO1FBQ04sSUFBSSxFQUNGblcsQ0FBQyxFQUNEK1YsUUFBUSxFQUNULEdBQUcsSUFBSTtRQUNSLE9BQU8vVixLQUFLK1YsU0FBU2xmLE1BQU0sR0FBRztJQUNoQztJQUVBdWYsT0FBTztRQUNMLElBQUlOLFVBQVUsSUFBSSxDQUFDQyxRQUFRLENBQUMsRUFBRSxJQUFJLENBQUMvVixDQUFDLENBQUM7UUFDckMsSUFBSSxDQUFDZ1csZUFBZSxHQUFHLElBQUksQ0FBQ0YsT0FBTztRQUNuQyxJQUFJLENBQUNBLE9BQU8sR0FBR0E7UUFDZixPQUFPQTtJQUNUO0lBRUFPLFdBQVc7UUFDVCxJQUFJQyxRQUFRMWYsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUc7UUFDaEYsSUFBSTJmLFFBQVEzZixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUNoRixJQUFJcUssUUFBUSxJQUFJSixNQUFNLElBQUksQ0FBQ2lWLE9BQU8sQ0FBQ1EsTUFBTSxFQUFFLElBQUksQ0FBQ1IsT0FBTyxDQUFDUyxNQUFNO1FBQzlELE9BQU8sSUFBSSxDQUFDQyxZQUFZLENBQUN2VjtJQUMzQjtJQUVBd1Ysa0JBQWtCSCxLQUFLLEVBQUVDLEtBQUssRUFBRTtRQUM5QixJQUFJdFYsUUFBUSxJQUFJLENBQUNvVixRQUFRLENBQUNDLE9BQU9DO1FBQ2pDLElBQUksQ0FBQ1gsT0FBTyxHQUFHM1U7UUFDZixPQUFPQTtJQUNUO0lBRUF5VixrQkFBa0JKLEtBQUssRUFBRUMsS0FBSyxFQUFFO1FBQzlCLElBQUl0VixRQUFRLElBQUksQ0FBQ29WLFFBQVEsQ0FBQ0MsT0FBT0M7UUFDakMsSUFBSSxDQUFDVixPQUFPLEdBQUc1VTtRQUNmLE9BQU9BO0lBQ1Q7SUFFQTBWLDJCQUEyQjtRQUN6QixJQUFJWCxrQkFBa0IsSUFBSSxDQUFDQSxlQUFlLENBQUM5UixJQUFJO1FBRS9DLElBQUk4UixvQkFBb0J6ZixzREFBV0EsQ0FBQ3FnQixRQUFRLElBQUlaLG9CQUFvQnpmLHNEQUFXQSxDQUFDc2dCLGVBQWUsSUFBSWIsb0JBQW9CemYsc0RBQVdBLENBQUN1Z0IsT0FBTyxJQUFJZCxvQkFBb0J6ZixzREFBV0EsQ0FBQ3dnQixjQUFjLEVBQUU7WUFDNUwsT0FBTyxJQUFJLENBQUNsQixPQUFPO1FBQ3JCLEVBQUUsZ0JBQWdCO1FBR2xCLElBQUksRUFDRkEsU0FBUyxFQUNQL1UsR0FBR29MLEVBQUUsRUFDTG5MLEdBQUdvTCxFQUFFLEVBQ04sRUFDRHlKLFNBQVMsRUFDUDlVLEdBQUdrVyxFQUFFLEVBQ0xqVyxHQUFHa1csRUFBRSxFQUNOLEVBQ0YsR0FBRyxJQUFJO1FBQ1IsSUFBSWhXLFFBQVEsSUFBSUosTUFBTSxJQUFJcUwsS0FBSzhLLElBQUksSUFBSTdLLEtBQUs4SztRQUM1QyxPQUFPaFc7SUFDVDtJQUVBdVYsYUFBYXZWLEtBQUssRUFBRTtRQUNsQixJQUFJLElBQUksQ0FBQzZVLE9BQU8sQ0FBQ29CLFFBQVEsRUFBRTtZQUN6QixJQUFJLEVBQ0ZwVyxDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHLElBQUksQ0FBQzhVLE9BQU87WUFDaEI1VSxNQUFNSCxDQUFDLElBQUlBO1lBQ1hHLE1BQU1GLENBQUMsSUFBSUE7UUFDYjtRQUVBLE9BQU9FO0lBQ1Q7SUFFQWtXLFVBQVVsVyxLQUFLLEVBQUVpTyxJQUFJLEVBQUVrSSxPQUFPLEVBQUU7UUFDOUIsSUFBSSxFQUNGN1YsTUFBTSxFQUNOMFUsTUFBTSxFQUNQLEdBQUcsSUFBSSxFQUFFLDhFQUE4RTtRQUV4RixJQUFJbUIsV0FBV25CLE9BQU9wZixNQUFNLEdBQUcsS0FBSyxDQUFDb2YsTUFBTSxDQUFDQSxPQUFPcGYsTUFBTSxHQUFHLEVBQUUsRUFBRTtZQUM5RG9mLE1BQU0sQ0FBQ0EsT0FBT3BmLE1BQU0sR0FBRyxFQUFFLEdBQUcwSyxNQUFNLENBQUNBLE9BQU8xSyxNQUFNLEdBQUcsRUFBRSxDQUFDNEssT0FBTyxDQUFDMlY7UUFDaEU7UUFFQSxJQUFJLENBQUNDLGNBQWMsQ0FBQ3BXLE9BQU9pTyxPQUFPQSxLQUFLek4sT0FBTyxDQUFDUixTQUFTO0lBQzFEO0lBRUFvVyxlQUFlcFcsS0FBSyxFQUFFOEssS0FBSyxFQUFFO1FBQzNCLElBQUksQ0FBQ3hLLE1BQU0sQ0FBQ2YsSUFBSSxDQUFDUztRQUNqQixJQUFJLENBQUNnVixNQUFNLENBQUN6VixJQUFJLENBQUN1TDtJQUNuQjtJQUVBdUwsa0JBQWtCO1FBQ2hCLE9BQU8sSUFBSSxDQUFDL1YsTUFBTTtJQUNwQjtJQUVBZ1csa0JBQWtCO1FBQ2hCLElBQUksRUFDRnRCLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJblcsTUFBTW1XLE9BQU9wZixNQUFNO1FBRXZCLElBQUssSUFBSW1KLElBQUksR0FBR0EsSUFBSUYsS0FBS0UsSUFBSztZQUM1QixJQUFJLENBQUNpVyxNQUFNLENBQUNqVyxFQUFFLEVBQUU7Z0JBQ2QsSUFBSyxJQUFJd1gsSUFBSXhYLElBQUksR0FBR3dYLElBQUkxWCxLQUFLMFgsSUFBSztvQkFDaEMsSUFBSXZCLE1BQU0sQ0FBQ3VCLEVBQUUsRUFBRTt3QkFDYnZCLE1BQU0sQ0FBQ2pXLEVBQUUsR0FBR2lXLE1BQU0sQ0FBQ3VCLEVBQUU7d0JBQ3JCO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtRQUVBLE9BQU92QjtJQUNUO0FBRUY7QUFFQSxNQUFNd0Isd0JBQXdCbEo7SUFDNUJsUyxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUM4Z0IsbUJBQW1CLEdBQUc7SUFDN0I7SUFFQUMsbUJBQW1CO1FBQ2pCLElBQUl2WSxVQUFVLEtBQUssNkVBQTZFO1FBRWhHLElBQUlELFVBQVUsSUFBSTtRQUVsQixNQUFPQSxRQUFTO1lBQ2QsSUFBSXlZLGVBQWV6WSxRQUFRcUssUUFBUSxDQUFDLFdBQVcsT0FBTyxPQUFPLDZCQUE2QjtZQUUxRixJQUFJb08sYUFBYTlhLFFBQVEsQ0FBQyxPQUFPO2dCQUMvQnNDLFdBQVd3WSxhQUFhbGEsU0FBUztZQUNuQztZQUVBeUIsVUFBVUEsUUFBUThELE1BQU07UUFDMUI7UUFFQSxPQUFPN0Q7SUFDVDtJQUVBb1IsV0FBV2xSLEdBQUcsRUFBRTtRQUNkLElBQUl1WSxjQUFjamhCLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBRXRGLElBQUksQ0FBQ2loQixhQUFhO1lBQ2hCLDJEQUEyRDtZQUMzRCxPQUFPO1lBQ1AsSUFBSUMsZ0JBQWdCLElBQUksQ0FBQ3RPLFFBQVEsQ0FBQztZQUNsQyxJQUFJdU8sdUJBQXVCLElBQUksQ0FBQ3ZPLFFBQVEsQ0FBQztZQUN6QyxJQUFJd08sa0JBQWtCLElBQUksQ0FBQ3hPLFFBQVEsQ0FBQztZQUNwQyxJQUFJeU8sb0JBQW9CLElBQUksQ0FBQ3pPLFFBQVEsQ0FBQztZQUV0QyxJQUFJc08sY0FBYzNhLGVBQWUsSUFBSTtnQkFDbkMsSUFBSSthLFlBQVlKLGNBQWM1WSxzQkFBc0IsQ0FBQyxJQUFJLEVBQUU2WTtnQkFFM0QsSUFBSUcsV0FBVztvQkFDYjVZLElBQUk0WSxTQUFTLEdBQUdBO2dCQUNsQjtZQUNGLE9BQU8sSUFBSUosY0FBY2hiLFFBQVEsSUFBSTtnQkFDbkMsSUFBSWdiLGNBQWNsYixTQUFTLE9BQU8sZ0JBQWdCO29CQUNoRGtiLGNBQWN2YSxRQUFRLENBQUMsSUFBSSxDQUFDaU0sUUFBUSxDQUFDLFNBQVM1TCxRQUFRO2dCQUN4RDtnQkFFQSxJQUFJdWEsYUFBYUwsY0FBY2xhLFFBQVE7Z0JBRXZDLElBQUl1YSxlQUFlLFdBQVc7b0JBQzVCN1ksSUFBSTRZLFNBQVMsR0FBR0MsZUFBZSxTQUFTLGtCQUFrQkE7Z0JBQzVEO1lBQ0Y7WUFFQSxJQUFJSixxQkFBcUJqYixRQUFRLElBQUk7Z0JBQ25DLElBQUlzYixjQUFjLElBQUloYyxTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLFFBQVFnRCxJQUFJNFksU0FBUyxFQUFFclksVUFBVSxDQUFDa1ksc0JBQXNCbmEsUUFBUTtnQkFFOUcwQixJQUFJNFksU0FBUyxHQUFHRTtZQUNsQixFQUFFLFNBQVM7WUFHWCxJQUFJSixnQkFBZ0I3YSxlQUFlLElBQUk7Z0JBQ3JDLElBQUkwSSxjQUFjbVMsZ0JBQWdCOVksc0JBQXNCLENBQUMsSUFBSSxFQUFFK1k7Z0JBRS9ELElBQUlwUyxhQUFhO29CQUNmdkcsSUFBSXVHLFdBQVcsR0FBR0E7Z0JBQ3BCO1lBQ0YsT0FBTyxJQUFJbVMsZ0JBQWdCbGIsUUFBUSxJQUFJO2dCQUNyQyxJQUFJa2IsZ0JBQWdCcGIsU0FBUyxPQUFPLGdCQUFnQjtvQkFDbERvYixnQkFBZ0J6YSxRQUFRLENBQUMsSUFBSSxDQUFDaU0sUUFBUSxDQUFDLFNBQVM1TCxRQUFRO2dCQUMxRDtnQkFFQSxJQUFJeWEsZUFBZUwsZ0JBQWdCcGIsU0FBUztnQkFFNUMsSUFBSXliLGlCQUFpQixXQUFXO29CQUM5Qi9ZLElBQUl1RyxXQUFXLEdBQUd3UyxpQkFBaUIsU0FBUyxrQkFBa0JBO2dCQUNoRTtZQUNGO1lBRUEsSUFBSUosa0JBQWtCbmIsUUFBUSxJQUFJO2dCQUNoQyxJQUFJd2IsZ0JBQWdCLElBQUlsYyxTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLFVBQVVnRCxJQUFJdUcsV0FBVyxFQUFFaEcsVUFBVSxDQUFDb1ksbUJBQW1CcmIsU0FBUztnQkFFbEgwQyxJQUFJdUcsV0FBVyxHQUFHeVM7WUFDcEI7WUFFQSxJQUFJQyx1QkFBdUIsSUFBSSxDQUFDL08sUUFBUSxDQUFDO1lBRXpDLElBQUkrTyxxQkFBcUJ6YixRQUFRLElBQUk7Z0JBQ25DLElBQUkwYixlQUFlRCxxQkFBcUJwYSxTQUFTO2dCQUNqRG1CLElBQUltWixTQUFTLEdBQUcsQ0FBQ0QsZUFBZXJkLFlBQVksZ0RBQWdEO21CQUMxRnFkO1lBQ0o7WUFFQSxJQUFJRSx5QkFBeUIsSUFBSSxDQUFDbFAsUUFBUSxDQUFDO1lBQzNDLElBQUltUCwwQkFBMEIsSUFBSSxDQUFDblAsUUFBUSxDQUFDO1lBQzVDLElBQUlvUCx1QkFBdUIsSUFBSSxDQUFDcFAsUUFBUSxDQUFDLHNCQUFzQixZQUFZO1lBQzNFLDREQUE0RDtZQUU1RCxJQUFJcVAsMkJBQTJCLElBQUksQ0FBQ3JQLFFBQVEsQ0FBQztZQUM3QyxJQUFJc1AsdUJBQXVCLElBQUksQ0FBQ3RQLFFBQVEsQ0FBQztZQUV6QyxJQUFJa1AsdUJBQXVCNWIsUUFBUSxJQUFJO2dCQUNyQ3dDLElBQUl3RyxPQUFPLEdBQUc0Uyx1QkFBdUI5YixTQUFTO1lBQ2hEO1lBRUEsSUFBSStiLHdCQUF3QjdiLFFBQVEsSUFBSTtnQkFDdEN3QyxJQUFJeUcsUUFBUSxHQUFHNFMsd0JBQXdCL2IsU0FBUztZQUNsRDtZQUVBLElBQUlnYyxxQkFBcUI5YixRQUFRLElBQUk7Z0JBQ25Dd0MsSUFBSTBHLFVBQVUsR0FBRzRTLHFCQUFxQmxiLFNBQVM7WUFDakQsRUFBRSxZQUFZO1lBQ2Qsd0NBQXdDO1lBQ3hDLFFBQVE7WUFDUixvREFBb0Q7WUFDcEQsSUFBSTtZQUdKLElBQUltYix5QkFBeUIvYixRQUFRLE1BQU0rYix5QkFBeUJqYyxTQUFTLE9BQU8sUUFBUTtnQkFDMUYsSUFBSW1jLE9BQU9sZ0IsVUFBVWdnQix5QkFBeUJqYyxTQUFTO2dCQUV2RCxJQUFJLE9BQU8wQyxJQUFJMFosV0FBVyxLQUFLLGFBQWE7b0JBQzFDMVosSUFBSTBaLFdBQVcsQ0FBQ0Q7Z0JBQ2xCLE9BQ0UsSUFBSSxPQUFPelosSUFBSTJaLGNBQWMsS0FBSyxhQUFhO29CQUM3QywwQ0FBMEM7b0JBQzFDM1osSUFBSTJaLGNBQWMsR0FBR0Y7Z0JBQ3ZCLE9BQ0UsSUFBSSxPQUFPelosSUFBSTRaLE9BQU8sS0FBSyxlQUFlLENBQUVILENBQUFBLEtBQUtsaUIsTUFBTSxLQUFLLEtBQUtraUIsSUFBSSxDQUFDLEVBQUUsS0FBSyxJQUFJO29CQUMvRSwwQ0FBMEM7b0JBQzFDelosSUFBSTRaLE9BQU8sR0FBR0g7Z0JBQ2hCO2dCQUVKLElBQUlJLFNBQVNMLHFCQUFxQjNhLFNBQVM7Z0JBRTNDLElBQUksT0FBT21CLElBQUk4WixjQUFjLEtBQUssYUFBYTtvQkFDN0M5WixJQUFJOFosY0FBYyxHQUFHRDtnQkFDdkIsT0FDRSxJQUFJLE9BQU83WixJQUFJK1osb0JBQW9CLEtBQUssYUFBYTtvQkFDbkQsMENBQTBDO29CQUMxQy9aLElBQUkrWixvQkFBb0IsR0FBR0Y7Z0JBQzdCLE9BQ0UsSUFBSSxPQUFPN1osSUFBSWdhLGFBQWEsS0FBSyxhQUFhO29CQUM1QywwQ0FBMEM7b0JBQzFDaGEsSUFBSWdhLGFBQWEsR0FBR0g7Z0JBQ3RCO1lBQ047UUFDRixFQUFFLE9BQU87UUFHVCxJQUFJLENBQUN6QixtQkFBbUIsR0FBRztRQUUzQixJQUFJLE9BQU9wWSxJQUFJMlQsSUFBSSxLQUFLLGFBQWE7WUFDbkMsSUFBSXNHLGdCQUFnQixJQUFJLENBQUMvUCxRQUFRLENBQUM7WUFDbEMsSUFBSWdRLHFCQUFxQixJQUFJLENBQUNoUSxRQUFRLENBQUM7WUFDdkMsSUFBSWlRLHVCQUF1QixJQUFJLENBQUNqUSxRQUFRLENBQUM7WUFDekMsSUFBSWtRLHNCQUFzQixJQUFJLENBQUNsUSxRQUFRLENBQUM7WUFDeEMsSUFBSW1RLG9CQUFvQixJQUFJLENBQUNuUSxRQUFRLENBQUM7WUFDdEMsSUFBSW9RLHNCQUFzQixJQUFJLENBQUNwUSxRQUFRLENBQUM7WUFDeEMsSUFBSXlKLE9BQU8sSUFBSUwsS0FBSzRHLG1CQUFtQjVjLFNBQVMsSUFBSTZjLHFCQUFxQjdjLFNBQVMsSUFBSThjLG9CQUFvQjljLFNBQVMsSUFBSStjLGtCQUFrQjdjLFFBQVEsS0FBSyxHQUFHNE0sTUFBTSxDQUFDaVEsa0JBQWtCeGIsU0FBUyxDQUFDLE9BQU8sUUFBUSxJQUFJeWIsb0JBQW9CaGQsU0FBUyxJQUFJZ1csS0FBSzVSLEtBQUssQ0FBQ3VZLGNBQWMzYyxTQUFTLElBQUkwQyxJQUFJMlQsSUFBSTtZQUM5UnVHLG1CQUFtQmpjLFFBQVEsQ0FBQzBWLEtBQUtWLFNBQVM7WUFDMUNrSCxxQkFBcUJsYyxRQUFRLENBQUMwVixLQUFLSixXQUFXO1lBQzlDNkcsb0JBQW9CbmMsUUFBUSxDQUFDMFYsS0FBS1AsVUFBVTtZQUM1Q2lILGtCQUFrQnBjLFFBQVEsQ0FBQzBWLEtBQUtILFFBQVE7WUFDeEM4RyxvQkFBb0JyYyxRQUFRLENBQUMwVixLQUFLZixVQUFVO1lBQzVDNVMsSUFBSTJULElBQUksR0FBR0EsS0FBS00sUUFBUTtZQUV4QixJQUFJb0csa0JBQWtCdmMsUUFBUSxJQUFJO2dCQUNoQyxJQUFJLENBQUNkLFFBQVEsQ0FBQzJCLE1BQU0sR0FBRzBiLGtCQUFrQnhiLFNBQVM7Z0JBQ2xELElBQUksQ0FBQ3VaLG1CQUFtQixHQUFHO1lBQzdCO1FBQ0Y7UUFFQSxJQUFJLENBQUNHLGFBQWE7WUFDaEIsVUFBVTtZQUNWLElBQUksQ0FBQ3ZILFlBQVksQ0FBQ2hSLE1BQU0sVUFBVTtZQUVsQ0EsSUFBSXVhLFdBQVcsR0FBRyxJQUFJLENBQUNsQyxnQkFBZ0I7UUFDekM7SUFDRjtJQUVBakgsYUFBYXBSLEdBQUcsRUFBRTtRQUNoQixLQUFLLENBQUNvUixhQUFhcFI7UUFFbkIsSUFBSSxJQUFJLENBQUNvWSxtQkFBbUIsRUFBRTtZQUM1QixJQUFJLENBQUNwYixRQUFRLENBQUN3ZCxTQUFTO1FBQ3pCO0lBQ0Y7QUFFRjtBQUVBLE1BQU1DLG9CQUFvQnRDO0lBQ3hCcGIsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUM4VixVQUFVLEdBQUc7UUFDbEIsSUFBSSxDQUFDQSxVQUFVLEdBQUcsSUFBSXJFLFdBQVcsSUFBSSxDQUFDalcsWUFBWSxDQUFDLEtBQUs5QyxTQUFTO0lBQ25FO0lBRUEwRSxLQUFLaEMsR0FBRyxFQUFFO1FBQ1IsSUFBSSxFQUNGMGEsVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUkxVyxjQUFjLElBQUlrUTtRQUN0QndHLFdBQVc5RCxLQUFLO1FBRWhCLElBQUk1VyxLQUFLO1lBQ1BBLElBQUl1SSxTQUFTO1FBQ2Y7UUFFQSxNQUFPLENBQUNtUyxXQUFXN0QsS0FBSyxHQUFJO1lBQzFCLE9BQVE2RCxXQUFXNUQsSUFBSSxHQUFHbFMsSUFBSTtnQkFDNUIsS0FBS3lSLFdBQVdzRSxPQUFPO29CQUNyQixJQUFJLENBQUNDLEtBQUssQ0FBQzVhLEtBQUtnRTtvQkFDaEI7Z0JBRUYsS0FBS3FTLFdBQVd3RSxPQUFPO29CQUNyQixJQUFJLENBQUNDLEtBQUssQ0FBQzlhLEtBQUtnRTtvQkFDaEI7Z0JBRUYsS0FBS3FTLFdBQVcwRSxhQUFhO29CQUMzQixJQUFJLENBQUNDLEtBQUssQ0FBQ2hiLEtBQUtnRTtvQkFDaEI7Z0JBRUYsS0FBS3FTLFdBQVc0RSxZQUFZO29CQUMxQixJQUFJLENBQUNDLEtBQUssQ0FBQ2xiLEtBQUtnRTtvQkFDaEI7Z0JBRUYsS0FBS3FTLFdBQVdpQixRQUFRO29CQUN0QixJQUFJLENBQUM2RCxLQUFLLENBQUNuYixLQUFLZ0U7b0JBQ2hCO2dCQUVGLEtBQUtxUyxXQUFXa0IsZUFBZTtvQkFDN0IsSUFBSSxDQUFDNkQsS0FBSyxDQUFDcGIsS0FBS2dFO29CQUNoQjtnQkFFRixLQUFLcVMsV0FBV21CLE9BQU87b0JBQ3JCLElBQUksQ0FBQzZELEtBQUssQ0FBQ3JiLEtBQUtnRTtvQkFDaEI7Z0JBRUYsS0FBS3FTLFdBQVdvQixjQUFjO29CQUM1QixJQUFJLENBQUM2RCxLQUFLLENBQUN0YixLQUFLZ0U7b0JBQ2hCO2dCQUVGLEtBQUtxUyxXQUFXa0YsR0FBRztvQkFDakIsSUFBSSxDQUFDQyxLQUFLLENBQUN4YixLQUFLZ0U7b0JBQ2hCO2dCQUVGLEtBQUtxUyxXQUFXb0YsVUFBVTtvQkFDeEIsSUFBSSxDQUFDQyxLQUFLLENBQUMxYixLQUFLZ0U7b0JBQ2hCO1lBQ0o7UUFDRjtRQUVBLE9BQU9BO0lBQ1Q7SUFFQTJYLGVBQWV2VixDQUFDLEVBQUU7UUFDaEIsT0FBTyxJQUFJLENBQUNwRSxJQUFJO0lBQ2xCO0lBRUE0WixhQUFhO1FBQ1gsSUFBSSxFQUNGbEIsVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUl6WSxTQUFTeVksV0FBVzFDLGVBQWU7UUFDdkMsSUFBSXJCLFNBQVMrRCxXQUFXekMsZUFBZTtRQUN2QyxJQUFJNEQsVUFBVTVaLE9BQU92SSxHQUFHLENBQUMsQ0FBQ2lJLE9BQU9qQixJQUFNO2dCQUFDaUI7Z0JBQU9nVixNQUFNLENBQUNqVyxFQUFFO2FBQUM7UUFDekQsT0FBT21iO0lBQ1Q7SUFFQTFLLGVBQWVuUixHQUFHLEVBQUU7UUFDbEIsSUFBSSxDQUFDZ0MsSUFBSSxDQUFDaEM7UUFDVixJQUFJLENBQUNoRCxRQUFRLENBQUNtQyxNQUFNLENBQUNrRyxLQUFLLENBQUN6QixTQUFTLENBQUMsSUFBSSxFQUFFNUQ7UUFDM0MsSUFBSThiLG9CQUFvQixJQUFJLENBQUM1UixRQUFRLENBQUM7UUFFdEMsSUFBSWxLLElBQUk0WSxTQUFTLEtBQUssSUFBSTtZQUN4QixJQUFJa0Qsa0JBQWtCeGUsU0FBUyxDQUFDLGVBQWUsV0FBVztnQkFDeEQwQyxJQUFJK2IsSUFBSSxDQUFDRCxrQkFBa0J4ZSxTQUFTO1lBQ3RDLE9BQU87Z0JBQ0wwQyxJQUFJK2IsSUFBSTtZQUNWO1FBQ0Y7UUFFQSxJQUFJL2IsSUFBSXVHLFdBQVcsS0FBSyxJQUFJO1lBQzFCLElBQUksSUFBSSxDQUFDbkcsWUFBWSxDQUFDLGlCQUFpQjlDLFNBQVMsT0FBTyxzQkFBc0I7Z0JBQzNFMEMsSUFBSThRLElBQUk7Z0JBQ1I5USxJQUFJZ2MsWUFBWSxDQUFDLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRztnQkFDaENoYyxJQUFJaWMsTUFBTTtnQkFDVmpjLElBQUlxUixPQUFPO1lBQ2IsT0FBTztnQkFDTHJSLElBQUlpYyxNQUFNO1lBQ1o7UUFDRjtRQUVBLElBQUlKLFVBQVUsSUFBSSxDQUFDRCxVQUFVO1FBRTdCLElBQUlDLFNBQVM7WUFDWCxJQUFJSyxtQkFBbUJMLFFBQVF0a0IsTUFBTSxHQUFHO1lBQ3hDLElBQUk0a0IsdUJBQXVCLElBQUksQ0FBQ2pTLFFBQVEsQ0FBQztZQUN6QyxJQUFJa1MscUJBQXFCLElBQUksQ0FBQ2xTLFFBQVEsQ0FBQztZQUN2QyxJQUFJbVMscUJBQXFCLElBQUksQ0FBQ25TLFFBQVEsQ0FBQztZQUV2QyxJQUFJaVMscUJBQXFCdGUsZUFBZSxJQUFJO2dCQUMxQyxJQUFJeWUsU0FBU0gscUJBQXFCemMsYUFBYTtnQkFDL0MsSUFBSSxDQUFDaUMsT0FBTzhLLE1BQU0sR0FBR29QLE9BQU8sQ0FBQyxFQUFFO2dCQUMvQlMsT0FBTy9TLE1BQU0sQ0FBQ3ZKLEtBQUsyQixPQUFPOEs7WUFDNUI7WUFFQSxJQUFJMlAsbUJBQW1CdmUsZUFBZSxJQUFJO2dCQUN4QyxJQUFJMGUsVUFBVUgsbUJBQW1CMWMsYUFBYTtnQkFFOUMsSUFBSyxJQUFJZ0IsSUFBSSxHQUFHQSxJQUFJd2Isa0JBQWtCeGIsSUFBSztvQkFDekMsSUFBSSxDQUFDOGIsUUFBUUMsT0FBTyxHQUFHWixPQUFPLENBQUNuYixFQUFFO29CQUVqQzZiLFFBQVFoVCxNQUFNLENBQUN2SixLQUFLd2MsUUFBUUM7Z0JBQzlCO1lBQ0Y7WUFFQSxJQUFJSixtQkFBbUJ4ZSxlQUFlLElBQUk7Z0JBQ3hDLElBQUk2ZSxXQUFXTCxtQkFBbUIzYyxhQUFhO2dCQUUvQyxJQUFJLENBQUNpZCxTQUFTQyxRQUFRLEdBQUdmLE9BQU8sQ0FBQ0ssaUJBQWlCO2dCQUVsRFEsU0FBU25ULE1BQU0sQ0FBQ3ZKLEtBQUsyYyxTQUFTQztZQUNoQztRQUNGO0lBQ0Y7SUFFQSxPQUFPaEMsTUFBTUYsVUFBVSxFQUFFO1FBQ3ZCLElBQUkvWSxRQUFRK1ksV0FBV3RELGlCQUFpQjtRQUN4Q3NELFdBQVd6WCxLQUFLLEdBQUd5WCxXQUFXbkUsT0FBTztRQUNyQyxPQUFPO1lBQ0w1VTtRQUNGO0lBQ0Y7SUFFQWlaLE1BQU01YSxHQUFHLEVBQUVnRSxXQUFXLEVBQUU7UUFDdEIsSUFBSSxFQUNGMFcsVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUksRUFDRi9ZLEtBQUssRUFDTixHQUFHOFksWUFBWUcsS0FBSyxDQUFDRjtRQUN0QixJQUFJLEVBQ0ZsWixDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHRTtRQUNKK1ksV0FBVzdDLFNBQVMsQ0FBQ2xXO1FBQ3JCcUMsWUFBWXlRLFFBQVEsQ0FBQ2pULEdBQUdDO1FBRXhCLElBQUl6QixLQUFLO1lBQ1BBLElBQUl3SSxNQUFNLENBQUNoSCxHQUFHQztRQUNoQjtJQUNGO0lBRUEsT0FBT3FaLE1BQU1KLFVBQVUsRUFBRTtRQUN2QixJQUFJLEVBQ0ZuRSxPQUFPLEVBQ1IsR0FBR21FO1FBQ0osSUFBSS9ZLFFBQVErWSxXQUFXdEQsaUJBQWlCO1FBQ3hDLE9BQU87WUFDTGI7WUFDQTVVO1FBQ0Y7SUFDRjtJQUVBbVosTUFBTTlhLEdBQUcsRUFBRWdFLFdBQVcsRUFBRTtRQUN0QixJQUFJLEVBQ0YwVyxVQUFVLEVBQ1gsR0FBRyxJQUFJO1FBQ1IsSUFBSSxFQUNGbkUsT0FBTyxFQUNQNVUsS0FBSyxFQUNOLEdBQUc4WSxZQUFZSyxLQUFLLENBQUNKO1FBQ3RCLElBQUksRUFDRmxaLENBQUMsRUFDREMsQ0FBQyxFQUNGLEdBQUdFO1FBQ0orWSxXQUFXN0MsU0FBUyxDQUFDbFcsT0FBTzRVO1FBQzVCdlMsWUFBWXlRLFFBQVEsQ0FBQ2pULEdBQUdDO1FBRXhCLElBQUl6QixLQUFLO1lBQ1BBLElBQUl5SSxNQUFNLENBQUNqSCxHQUFHQztRQUNoQjtJQUNGO0lBRUEsT0FBT3VaLE1BQU1OLFVBQVUsRUFBRTtRQUN2QixJQUFJLEVBQ0ZuRSxPQUFPLEVBQ1BDLE9BQU8sRUFDUixHQUFHa0U7UUFDSixJQUFJL1ksUUFBUSxJQUFJSixNQUFNLENBQUNpVixRQUFRb0IsUUFBUSxHQUFHckIsUUFBUS9VLENBQUMsR0FBRyxLQUFLZ1YsUUFBUWhWLENBQUMsRUFBRStVLFFBQVE5VSxDQUFDO1FBQy9FaVosV0FBV25FLE9BQU8sR0FBRzVVO1FBQ3JCLE9BQU87WUFDTDRVO1lBQ0E1VTtRQUNGO0lBQ0Y7SUFFQXFaLE1BQU1oYixHQUFHLEVBQUVnRSxXQUFXLEVBQUU7UUFDdEIsSUFBSSxFQUNGMFcsVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUksRUFDRm5FLE9BQU8sRUFDUDVVLEtBQUssRUFDTixHQUFHOFksWUFBWU8sS0FBSyxDQUFDTjtRQUN0QixJQUFJLEVBQ0ZsWixDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHRTtRQUNKK1ksV0FBVzdDLFNBQVMsQ0FBQ2xXLE9BQU80VTtRQUM1QnZTLFlBQVl5USxRQUFRLENBQUNqVCxHQUFHQztRQUV4QixJQUFJekIsS0FBSztZQUNQQSxJQUFJeUksTUFBTSxDQUFDakgsR0FBR0M7UUFDaEI7SUFDRjtJQUVBLE9BQU95WixNQUFNUixVQUFVLEVBQUU7UUFDdkIsSUFBSSxFQUNGbkUsT0FBTyxFQUNQQyxPQUFPLEVBQ1IsR0FBR2tFO1FBQ0osSUFBSS9ZLFFBQVEsSUFBSUosTUFBTWdWLFFBQVEvVSxDQUFDLEVBQUUsQ0FBQ2dWLFFBQVFvQixRQUFRLEdBQUdyQixRQUFROVUsQ0FBQyxHQUFHLEtBQUsrVSxRQUFRL1UsQ0FBQztRQUMvRWlaLFdBQVduRSxPQUFPLEdBQUc1VTtRQUNyQixPQUFPO1lBQ0w0VTtZQUNBNVU7UUFDRjtJQUNGO0lBRUF1WixNQUFNbGIsR0FBRyxFQUFFZ0UsV0FBVyxFQUFFO1FBQ3RCLElBQUksRUFDRjBXLFVBQVUsRUFDWCxHQUFHLElBQUk7UUFDUixJQUFJLEVBQ0ZuRSxPQUFPLEVBQ1A1VSxLQUFLLEVBQ04sR0FBRzhZLFlBQVlTLEtBQUssQ0FBQ1I7UUFDdEIsSUFBSSxFQUNGbFosQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBR0U7UUFDSitZLFdBQVc3QyxTQUFTLENBQUNsVyxPQUFPNFU7UUFDNUJ2UyxZQUFZeVEsUUFBUSxDQUFDalQsR0FBR0M7UUFFeEIsSUFBSXpCLEtBQUs7WUFDUEEsSUFBSXlJLE1BQU0sQ0FBQ2pILEdBQUdDO1FBQ2hCO0lBQ0Y7SUFFQSxPQUFPMFosTUFBTVQsVUFBVSxFQUFFO1FBQ3ZCLElBQUksRUFDRm5FLE9BQU8sRUFDUixHQUFHbUU7UUFDSixJQUFJL1ksUUFBUStZLFdBQVczRCxRQUFRLENBQUMsTUFBTTtRQUN0QyxJQUFJOEYsZUFBZW5DLFdBQVd2RCxpQkFBaUIsQ0FBQyxNQUFNO1FBQ3RELElBQUkyRixlQUFlcEMsV0FBV3RELGlCQUFpQjtRQUMvQyxPQUFPO1lBQ0xiO1lBQ0E1VTtZQUNBa2I7WUFDQUM7UUFDRjtJQUNGO0lBRUEzQixNQUFNbmIsR0FBRyxFQUFFZ0UsV0FBVyxFQUFFO1FBQ3RCLElBQUksRUFDRjBXLFVBQVUsRUFDWCxHQUFHLElBQUk7UUFDUixJQUFJLEVBQ0ZuRSxPQUFPLEVBQ1A1VSxLQUFLLEVBQ0xrYixZQUFZLEVBQ1pDLFlBQVksRUFDYixHQUFHckMsWUFBWVUsS0FBSyxDQUFDVDtRQUN0QkEsV0FBVzdDLFNBQVMsQ0FBQ2lGLGNBQWNELGNBQWNsYjtRQUNqRHFDLFlBQVl1UixjQUFjLENBQUNnQixRQUFRL1UsQ0FBQyxFQUFFK1UsUUFBUTlVLENBQUMsRUFBRUUsTUFBTUgsQ0FBQyxFQUFFRyxNQUFNRixDQUFDLEVBQUVvYixhQUFhcmIsQ0FBQyxFQUFFcWIsYUFBYXBiLENBQUMsRUFBRXFiLGFBQWF0YixDQUFDLEVBQUVzYixhQUFhcmIsQ0FBQztRQUVqSSxJQUFJekIsS0FBSztZQUNQQSxJQUFJK2MsYUFBYSxDQUFDcGIsTUFBTUgsQ0FBQyxFQUFFRyxNQUFNRixDQUFDLEVBQUVvYixhQUFhcmIsQ0FBQyxFQUFFcWIsYUFBYXBiLENBQUMsRUFBRXFiLGFBQWF0YixDQUFDLEVBQUVzYixhQUFhcmIsQ0FBQztRQUNwRztJQUNGO0lBRUEsT0FBTzJaLE1BQU1WLFVBQVUsRUFBRTtRQUN2QixJQUFJLEVBQ0ZuRSxPQUFPLEVBQ1IsR0FBR21FO1FBQ0osSUFBSS9ZLFFBQVErWSxXQUFXckQsd0JBQXdCO1FBQy9DLElBQUl3RixlQUFlbkMsV0FBV3ZELGlCQUFpQixDQUFDLE1BQU07UUFDdEQsSUFBSTJGLGVBQWVwQyxXQUFXdEQsaUJBQWlCO1FBQy9DLE9BQU87WUFDTGI7WUFDQTVVO1lBQ0FrYjtZQUNBQztRQUNGO0lBQ0Y7SUFFQTFCLE1BQU1wYixHQUFHLEVBQUVnRSxXQUFXLEVBQUU7UUFDdEIsSUFBSSxFQUNGMFcsVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUksRUFDRm5FLE9BQU8sRUFDUDVVLEtBQUssRUFDTGtiLFlBQVksRUFDWkMsWUFBWSxFQUNiLEdBQUdyQyxZQUFZVyxLQUFLLENBQUNWO1FBQ3RCQSxXQUFXN0MsU0FBUyxDQUFDaUYsY0FBY0QsY0FBY2xiO1FBQ2pEcUMsWUFBWXVSLGNBQWMsQ0FBQ2dCLFFBQVEvVSxDQUFDLEVBQUUrVSxRQUFROVUsQ0FBQyxFQUFFRSxNQUFNSCxDQUFDLEVBQUVHLE1BQU1GLENBQUMsRUFBRW9iLGFBQWFyYixDQUFDLEVBQUVxYixhQUFhcGIsQ0FBQyxFQUFFcWIsYUFBYXRiLENBQUMsRUFBRXNiLGFBQWFyYixDQUFDO1FBRWpJLElBQUl6QixLQUFLO1lBQ1BBLElBQUkrYyxhQUFhLENBQUNwYixNQUFNSCxDQUFDLEVBQUVHLE1BQU1GLENBQUMsRUFBRW9iLGFBQWFyYixDQUFDLEVBQUVxYixhQUFhcGIsQ0FBQyxFQUFFcWIsYUFBYXRiLENBQUMsRUFBRXNiLGFBQWFyYixDQUFDO1FBQ3BHO0lBQ0Y7SUFFQSxPQUFPNFosTUFBTVgsVUFBVSxFQUFFO1FBQ3ZCLElBQUksRUFDRm5FLE9BQU8sRUFDUixHQUFHbUU7UUFDSixJQUFJbUMsZUFBZW5DLFdBQVd2RCxpQkFBaUIsQ0FBQyxNQUFNO1FBQ3RELElBQUkyRixlQUFlcEMsV0FBV3RELGlCQUFpQjtRQUMvQyxPQUFPO1lBQ0xiO1lBQ0FzRztZQUNBQztRQUNGO0lBQ0Y7SUFFQXpCLE1BQU1yYixHQUFHLEVBQUVnRSxXQUFXLEVBQUU7UUFDdEIsSUFBSSxFQUNGMFcsVUFBVSxFQUNYLEdBQUcsSUFBSTtRQUNSLElBQUksRUFDRm5FLE9BQU8sRUFDUHNHLFlBQVksRUFDWkMsWUFBWSxFQUNiLEdBQUdyQyxZQUFZWSxLQUFLLENBQUNYO1FBQ3RCQSxXQUFXN0MsU0FBUyxDQUFDaUYsY0FBY0QsY0FBY0E7UUFDakQ3WSxZQUFZZ1MsaUJBQWlCLENBQUNPLFFBQVEvVSxDQUFDLEVBQUUrVSxRQUFROVUsQ0FBQyxFQUFFb2IsYUFBYXJiLENBQUMsRUFBRXFiLGFBQWFwYixDQUFDLEVBQUVxYixhQUFhdGIsQ0FBQyxFQUFFc2IsYUFBYXJiLENBQUM7UUFFbEgsSUFBSXpCLEtBQUs7WUFDUEEsSUFBSWdkLGdCQUFnQixDQUFDSCxhQUFhcmIsQ0FBQyxFQUFFcWIsYUFBYXBiLENBQUMsRUFBRXFiLGFBQWF0YixDQUFDLEVBQUVzYixhQUFhcmIsQ0FBQztRQUNyRjtJQUNGO0lBRUEsT0FBTzZaLE1BQU1aLFVBQVUsRUFBRTtRQUN2QixJQUFJLEVBQ0ZuRSxPQUFPLEVBQ1IsR0FBR21FO1FBQ0osSUFBSW1DLGVBQWVuQyxXQUFXckQsd0JBQXdCO1FBQ3REcUQsV0FBV3BFLE9BQU8sR0FBR3VHO1FBQ3JCLElBQUlDLGVBQWVwQyxXQUFXdEQsaUJBQWlCO1FBQy9DLE9BQU87WUFDTGI7WUFDQXNHO1lBQ0FDO1FBQ0Y7SUFDRjtJQUVBeEIsTUFBTXRiLEdBQUcsRUFBRWdFLFdBQVcsRUFBRTtRQUN0QixJQUFJLEVBQ0YwVyxVQUFVLEVBQ1gsR0FBRyxJQUFJO1FBQ1IsSUFBSSxFQUNGbkUsT0FBTyxFQUNQc0csWUFBWSxFQUNaQyxZQUFZLEVBQ2IsR0FBR3JDLFlBQVlhLEtBQUssQ0FBQ1o7UUFDdEJBLFdBQVc3QyxTQUFTLENBQUNpRixjQUFjRCxjQUFjQTtRQUNqRDdZLFlBQVlnUyxpQkFBaUIsQ0FBQ08sUUFBUS9VLENBQUMsRUFBRStVLFFBQVE5VSxDQUFDLEVBQUVvYixhQUFhcmIsQ0FBQyxFQUFFcWIsYUFBYXBiLENBQUMsRUFBRXFiLGFBQWF0YixDQUFDLEVBQUVzYixhQUFhcmIsQ0FBQztRQUVsSCxJQUFJekIsS0FBSztZQUNQQSxJQUFJZ2QsZ0JBQWdCLENBQUNILGFBQWFyYixDQUFDLEVBQUVxYixhQUFhcGIsQ0FBQyxFQUFFcWIsYUFBYXRiLENBQUMsRUFBRXNiLGFBQWFyYixDQUFDO1FBQ3JGO0lBQ0Y7SUFFQSxPQUFPK1osTUFBTWQsVUFBVSxFQUFFO1FBQ3ZCLElBQUksRUFDRm5FLE9BQU8sRUFDUEMsT0FBTyxFQUNSLEdBQUdrRTtRQUNKLElBQUksRUFDRnVDLEVBQUUsRUFDRkMsRUFBRSxFQUNGQyxJQUFJLEVBQ0pDLFFBQVEsRUFDUkMsU0FBUyxFQUNWLEdBQUc3RztRQUNKLElBQUk4RyxnQkFBZ0JILE9BQVF2aUIsQ0FBQUEsS0FBSzZFLEVBQUUsR0FBRyxLQUFJO1FBQzFDLElBQUlxZCxlQUFlcEMsV0FBV3RELGlCQUFpQixJQUFJLHNEQUFzRDtRQUN6RyxrRUFBa0U7UUFDbEUsV0FBVztRQUVYLElBQUltRyxRQUFRLElBQUloYyxNQUFNM0csS0FBS3NTLEdBQUcsQ0FBQ29RLGlCQUFrQi9HLENBQUFBLFFBQVEvVSxDQUFDLEdBQUdzYixhQUFhdGIsQ0FBQyxJQUFJLE1BQU01RyxLQUFLdVMsR0FBRyxDQUFDbVEsaUJBQWtCL0csQ0FBQUEsUUFBUTlVLENBQUMsR0FBR3FiLGFBQWFyYixDQUFDLElBQUksS0FBSyxDQUFDN0csS0FBS3VTLEdBQUcsQ0FBQ21RLGlCQUFrQi9HLENBQUFBLFFBQVEvVSxDQUFDLEdBQUdzYixhQUFhdGIsQ0FBQyxJQUFJLE1BQU01RyxLQUFLc1MsR0FBRyxDQUFDb1EsaUJBQWtCL0csQ0FBQUEsUUFBUTlVLENBQUMsR0FBR3FiLGFBQWFyYixDQUFDLElBQUksTUFBTSxlQUFlO1FBRWpTLElBQUkrYixJQUFJNWlCLEtBQUtxQixHQUFHLENBQUNzaEIsTUFBTS9iLENBQUMsRUFBRSxLQUFLNUcsS0FBS3FCLEdBQUcsQ0FBQ2doQixJQUFJLEtBQUtyaUIsS0FBS3FCLEdBQUcsQ0FBQ3NoQixNQUFNOWIsQ0FBQyxFQUFFLEtBQUs3RyxLQUFLcUIsR0FBRyxDQUFDaWhCLElBQUk7UUFFckYsSUFBSU0sSUFBSSxHQUFHO1lBQ1RQLE1BQU1yaUIsS0FBS29CLElBQUksQ0FBQ3doQjtZQUNoQk4sTUFBTXRpQixLQUFLb0IsSUFBSSxDQUFDd2hCO1FBQ2xCLEVBQUUsV0FBVztRQUdiLElBQUlDLElBQUksQ0FBQ0wsYUFBYUMsWUFBWSxDQUFDLElBQUksS0FBS3ppQixLQUFLb0IsSUFBSSxDQUFDLENBQUNwQixLQUFLcUIsR0FBRyxDQUFDZ2hCLElBQUksS0FBS3JpQixLQUFLcUIsR0FBRyxDQUFDaWhCLElBQUksS0FBS3RpQixLQUFLcUIsR0FBRyxDQUFDZ2hCLElBQUksS0FBS3JpQixLQUFLcUIsR0FBRyxDQUFDc2hCLE1BQU05YixDQUFDLEVBQUUsS0FBSzdHLEtBQUtxQixHQUFHLENBQUNpaEIsSUFBSSxLQUFLdGlCLEtBQUtxQixHQUFHLENBQUNzaEIsTUFBTS9iLENBQUMsRUFBRSxFQUFDLElBQU01RyxDQUFBQSxLQUFLcUIsR0FBRyxDQUFDZ2hCLElBQUksS0FBS3JpQixLQUFLcUIsR0FBRyxDQUFDc2hCLE1BQU05YixDQUFDLEVBQUUsS0FBSzdHLEtBQUtxQixHQUFHLENBQUNpaEIsSUFBSSxLQUFLdGlCLEtBQUtxQixHQUFHLENBQUNzaEIsTUFBTS9iLENBQUMsRUFBRSxFQUFDO1FBRTdQLElBQUlxSixNQUFNNFMsSUFBSTtZQUNaQSxJQUFJO1FBQ047UUFFQSxJQUFJQyxNQUFNLElBQUluYyxNQUFNa2MsSUFBSVIsS0FBS00sTUFBTTliLENBQUMsR0FBR3liLElBQUlPLElBQUksQ0FBQ1AsS0FBS0ssTUFBTS9iLENBQUMsR0FBR3liLEtBQUssU0FBUztRQUU3RSxJQUFJVSxRQUFRLElBQUlwYyxNQUFNLENBQUNnVixRQUFRL1UsQ0FBQyxHQUFHc2IsYUFBYXRiLENBQUMsSUFBSSxNQUFNNUcsS0FBS3NTLEdBQUcsQ0FBQ29RLGlCQUFpQkksSUFBSWxjLENBQUMsR0FBRzVHLEtBQUt1UyxHQUFHLENBQUNtUSxpQkFBaUJJLElBQUlqYyxDQUFDLEVBQUUsQ0FBQzhVLFFBQVE5VSxDQUFDLEdBQUdxYixhQUFhcmIsQ0FBQyxJQUFJLE1BQU03RyxLQUFLdVMsR0FBRyxDQUFDbVEsaUJBQWlCSSxJQUFJbGMsQ0FBQyxHQUFHNUcsS0FBS3NTLEdBQUcsQ0FBQ29RLGlCQUFpQkksSUFBSWpjLENBQUMsR0FBRyxnQkFBZ0I7UUFFdlAsSUFBSW1jLEtBQUt4aEIsYUFBYTtZQUFDO1lBQUc7U0FBRSxFQUFFO1lBQUVtaEIsQ0FBQUEsTUFBTS9iLENBQUMsR0FBR2tjLElBQUlsYyxDQUFDLElBQUl5YjtZQUFLTSxDQUFBQSxNQUFNOWIsQ0FBQyxHQUFHaWMsSUFBSWpjLENBQUMsSUFBSXliO1NBQUcsR0FBRyxLQUFLO1FBQ3RGLGNBQWM7UUFFZCxJQUFJL2dCLElBQUk7WUFBRW9oQixDQUFBQSxNQUFNL2IsQ0FBQyxHQUFHa2MsSUFBSWxjLENBQUMsSUFBSXliO1lBQUtNLENBQUFBLE1BQU05YixDQUFDLEdBQUdpYyxJQUFJamMsQ0FBQyxJQUFJeWI7U0FBRztRQUN4RCxJQUFJbmhCLElBQUk7WUFBRSxFQUFDd2hCLE1BQU0vYixDQUFDLEdBQUdrYyxJQUFJbGMsQ0FBQyxJQUFJeWI7WUFBSyxFQUFDTSxNQUFNOWIsQ0FBQyxHQUFHaWMsSUFBSWpjLENBQUMsSUFBSXliO1NBQUc7UUFDMUQsSUFBSVcsS0FBS3poQixhQUFhRCxHQUFHSixJQUFJLEtBQUs7UUFFbEMsSUFBSUcsYUFBYUMsR0FBR0osTUFBTSxDQUFDLEdBQUc7WUFDNUI4aEIsS0FBS2pqQixLQUFLNkUsRUFBRTtRQUNkO1FBRUEsSUFBSXZELGFBQWFDLEdBQUdKLE1BQU0sR0FBRztZQUMzQjhoQixLQUFLO1FBQ1A7UUFFQSxPQUFPO1lBQ0xmO1lBQ0FHO1lBQ0FDO1lBQ0FHO1lBQ0FDO1lBQ0FLO1lBQ0FDO1lBQ0FDO1FBQ0Y7SUFDRjtJQUVBckMsTUFBTXhiLEdBQUcsRUFBRWdFLFdBQVcsRUFBRTtRQUN0QixJQUFJLEVBQ0YwVyxVQUFVLEVBQ1gsR0FBRyxJQUFJO1FBQ1IsSUFBSSxFQUNGb0MsWUFBWSxFQUNaRyxFQUFFLEVBQ0ZDLEVBQUUsRUFDRkcsU0FBUyxFQUNUQyxhQUFhLEVBQ2JLLEtBQUssRUFDTEMsRUFBRSxFQUNGQyxFQUFFLEVBQ0gsR0FBR3BELFlBQVllLEtBQUssQ0FBQ2QsYUFBYSxjQUFjO1FBRWpELElBQUlvRCxNQUFNLElBQUlULFlBQVksTUFBTSxDQUFDO1FBQ2pDLElBQUlVLEtBQUtILEtBQUtFLE1BQU9ELENBQUFBLEtBQUssR0FBRTtRQUM1QixJQUFJRyxVQUFVLElBQUl6YyxNQUFNb2MsTUFBTW5jLENBQUMsR0FBR3liLEtBQUtyaUIsS0FBS3NTLEdBQUcsQ0FBQzZRLEtBQUtKLE1BQU1sYyxDQUFDLEdBQUd5YixLQUFLdGlCLEtBQUt1UyxHQUFHLENBQUM0UTtRQUM3RXJELFdBQVczQyxjQUFjLENBQUNpRyxTQUFTRCxLQUFLRCxNQUFNbGpCLEtBQUs2RSxFQUFFLEdBQUc7UUFDeERpYixXQUFXM0MsY0FBYyxDQUFDK0UsY0FBY2lCLEtBQUtELE1BQU1sakIsS0FBSzZFLEVBQUU7UUFDMUR1RSxZQUFZeVEsUUFBUSxDQUFDcUksYUFBYXRiLENBQUMsRUFBRXNiLGFBQWFyYixDQUFDLEdBQUcsMENBQTBDO1FBRWhHLElBQUl6QixPQUFPLENBQUM2SyxNQUFNK1MsT0FBTyxDQUFDL1MsTUFBTWdULEtBQUs7WUFDbkMsSUFBSUksSUFBSWhCLEtBQUtDLEtBQUtELEtBQUtDO1lBQ3ZCLElBQUlnQixLQUFLakIsS0FBS0MsS0FBSyxJQUFJRCxLQUFLQztZQUM1QixJQUFJaUIsS0FBS2xCLEtBQUtDLEtBQUtBLEtBQUtELEtBQUs7WUFDN0JqZCxJQUFJb0ksU0FBUyxDQUFDdVYsTUFBTW5jLENBQUMsRUFBRW1jLE1BQU1sYyxDQUFDO1lBQzlCekIsSUFBSXVNLE1BQU0sQ0FBQytRO1lBQ1h0ZCxJQUFJOEIsS0FBSyxDQUFDb2MsSUFBSUM7WUFDZG5lLElBQUlvZSxHQUFHLENBQUMsR0FBRyxHQUFHSCxHQUFHTCxJQUFJQSxLQUFLQyxJQUFJUSxRQUFRLElBQUloQjtZQUMxQ3JkLElBQUk4QixLQUFLLENBQUMsSUFBSW9jLElBQUksSUFBSUM7WUFDdEJuZSxJQUFJdU0sTUFBTSxDQUFDLENBQUMrUTtZQUNadGQsSUFBSW9JLFNBQVMsQ0FBQyxDQUFDdVYsTUFBTW5jLENBQUMsRUFBRSxDQUFDbWMsTUFBTWxjLENBQUM7UUFDbEM7SUFDRjtJQUVBLE9BQU9pYSxNQUFNaEIsVUFBVSxFQUFFO1FBQ3ZCQSxXQUFXbkUsT0FBTyxHQUFHbUUsV0FBV3pYLEtBQUs7SUFDdkM7SUFFQXlZLE1BQU0xYixHQUFHLEVBQUVnRSxXQUFXLEVBQUU7UUFDdEJ5VyxZQUFZaUIsS0FBSyxDQUFDLElBQUksQ0FBQ2hCLFVBQVU7UUFFakMsSUFBSTFhLEtBQUs7WUFDUCwrQ0FBK0M7WUFDL0MsSUFBSWdFLFlBQVltUSxFQUFFLEtBQUtuUSxZQUFZdVEsRUFBRSxJQUFJdlEsWUFBWXNRLEVBQUUsS0FBS3RRLFlBQVl3USxFQUFFLEVBQUU7Z0JBQzFFeFUsSUFBSTBJLFNBQVM7WUFDZjtRQUNGO0lBQ0Y7QUFFRjtBQUVBLE1BQU00VixxQkFBcUI3RDtJQUN6QjFkLFlBQVlDLFNBQVEsRUFBRXRFLElBQUksRUFBRXdXLGdCQUFnQixDQUFFO1FBQzVDLEtBQUssQ0FBQ2xTLFdBQVV0RSxNQUFNd1c7UUFDdEIsSUFBSSxDQUFDdEssSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDMlosU0FBUyxHQUFHLElBQUksQ0FBQ25lLFlBQVksQ0FBQyxlQUFlaEMsU0FBUztRQUMzRCxJQUFJLENBQUNvZ0IsT0FBTyxHQUFHLElBQUksQ0FBQ3BlLFlBQVksQ0FBQyxXQUFXOUMsU0FBUztRQUNyRCxJQUFJLENBQUNtaEIsVUFBVSxHQUFHLElBQUksQ0FBQ3JlLFlBQVksQ0FBQyxlQUFlOUMsU0FBUztJQUM5RDtBQUVGO0FBRUEsTUFBTW9oQixvQkFBb0J2RztJQUN4QnBiLFlBQVlDLFNBQVEsRUFBRXRFLElBQUksRUFBRXdXLGdCQUFnQixDQUFFO1FBQzVDLEtBQUssQ0FBQ2xTLFdBQVV0RSxNQUFNLGVBQWVnbUIsY0FBYyxPQUFPeFA7UUFDMUQsSUFBSSxDQUFDdEssSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDcEQsQ0FBQyxHQUFHO1FBQ1QsSUFBSSxDQUFDQyxDQUFDLEdBQUc7UUFDVCxJQUFJLENBQUNrZCxZQUFZLEdBQUcsQ0FBQztJQUN2QjtJQUVBek4sV0FBV2xSLEdBQUcsRUFBRTtRQUNkLElBQUl1WSxjQUFjamhCLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQ3RGLEtBQUssQ0FBQzRaLFdBQVdsUixLQUFLdVk7UUFDdEIsSUFBSXFHLGVBQWUsSUFBSSxDQUFDMVUsUUFBUSxDQUFDLHFCQUFxQjdKLGVBQWUsTUFBTSxJQUFJLENBQUM2SixRQUFRLENBQUMsc0JBQXNCN0osZUFBZTtRQUU5SCxJQUFJdWUsY0FBYztZQUNoQjVlLElBQUk0ZSxZQUFZLEdBQUdBO1FBQ3JCO0lBQ0Y7SUFFQUMsd0JBQXdCO1FBQ3RCLElBQUksQ0FBQ3JkLENBQUMsR0FBRztRQUNULElBQUksQ0FBQ0MsQ0FBQyxHQUFHO1FBQ1QsSUFBSSxDQUFDcWQsU0FBUyxHQUFHLEVBQUU7UUFDbkIsSUFBSSxDQUFDQyxjQUFjLEdBQUc7UUFDdEIsSUFBSSxDQUFDaFksSUFBSSxHQUFHcU4sT0FBTzRLLGlCQUFpQjtRQUNwQyxJQUFJLENBQUNDLElBQUksR0FBRzdLLE9BQU84SyxpQkFBaUI7SUFDdEM7SUFFQXZELGVBQWUzYixHQUFHLEVBQUU7UUFDbEIsSUFBSSxJQUFJLENBQUM0RSxJQUFJLEtBQUssUUFBUTtZQUN4QixPQUFPLElBQUksQ0FBQ3VhLHNCQUFzQixDQUFDbmY7UUFDckMsRUFBRSxtQ0FBbUM7UUFHckMsSUFBSSxDQUFDNmUscUJBQXFCO1FBQzFCLElBQUksQ0FBQ08sK0JBQStCLENBQUNwZjtRQUNyQyxJQUFJZ0UsY0FBYyxNQUFNLDhCQUE4QjtRQUV0RCxJQUFJLENBQUN5TCxRQUFRLENBQUNoTSxPQUFPLENBQUMsQ0FBQzJDLEdBQUcxRjtZQUN4QixJQUFJMmUsbUJBQW1CLElBQUksQ0FBQ0MsbUJBQW1CLENBQUN0ZixLQUFLLElBQUksRUFBRSxJQUFJLEVBQUVVO1lBRWpFLElBQUksQ0FBQ3NELGFBQWE7Z0JBQ2hCQSxjQUFjcWI7WUFDaEIsT0FBTztnQkFDTHJiLFlBQVk0USxjQUFjLENBQUN5SztZQUM3QjtRQUNGO1FBQ0EsT0FBT3JiO0lBQ1Q7SUFFQXViLGNBQWM7UUFDWixJQUFJLEVBQ0Z2aUIsVUFBQUEsU0FBUSxFQUNSMkcsTUFBTSxFQUNQLEdBQUcsSUFBSTtRQUNSLElBQUk2YixrQkFBa0JsTSxLQUFLNVIsS0FBSyxDQUFDMUUsVUFBU2dELEdBQUcsQ0FBQzJULElBQUksRUFBRUgsUUFBUTtRQUM1RCxJQUFJQSxXQUFXN1AsT0FBT3VHLFFBQVEsQ0FBQyxhQUFhOUwsU0FBUyxDQUFDb2hCO1FBQ3RELE9BQU9oTTtJQUNUO0lBRUEyTCx1QkFBdUJuZixHQUFHLEVBQUU7UUFDMUIsSUFBSXdULFdBQVcsSUFBSSxDQUFDK0wsV0FBVztRQUMvQixPQUFPLElBQUlyTCxZQUFZLElBQUksQ0FBQzFTLENBQUMsRUFBRSxJQUFJLENBQUNDLENBQUMsR0FBRytSLFVBQVUsSUFBSSxDQUFDaFMsQ0FBQyxHQUFHLElBQUksQ0FBQ2llLFdBQVcsQ0FBQ3pmLE1BQU0sSUFBSSxDQUFDeUIsQ0FBQztJQUMxRjtJQUVBaWUsU0FBUy9MLElBQUksRUFBRTFILElBQUksRUFBRXZMLENBQUMsRUFBRTtRQUN0QixJQUFJaWYsT0FBTzFULElBQUksQ0FBQ3ZMLEVBQUU7UUFDbEIsSUFBSWtmLFFBQVE7UUFFWixJQUFJak0sS0FBS2tNLFFBQVEsRUFBRTtZQUNqQixJQUFJcmYsTUFBTXlMLEtBQUsxVSxNQUFNO1lBQ3JCLElBQUl1b0IsV0FBVzdULElBQUksQ0FBQ3ZMLElBQUksRUFBRTtZQUMxQixJQUFJcWYsV0FBVzlULElBQUksQ0FBQ3ZMLElBQUksRUFBRTtZQUMxQixJQUFJK2QsYUFBYTtZQUVqQixJQUFJLENBQUMvZCxNQUFNLEtBQUtvZixhQUFhLEdBQUUsS0FBTXBmLElBQUlGLE1BQU0sS0FBS3VmLGFBQWEsS0FBSztnQkFDcEV0QixhQUFhO1lBQ2Y7WUFFQSxJQUFJL2QsSUFBSSxLQUFLb2YsYUFBYSxPQUFPcGYsSUFBSUYsTUFBTSxLQUFLdWYsYUFBYSxLQUFLO2dCQUNoRXRCLGFBQWE7WUFDZjtZQUVBLElBQUkvZCxJQUFJLEtBQUtvZixhQUFhLE9BQVFwZixDQUFBQSxNQUFNRixNQUFNLEtBQUt1ZixhQUFhLEdBQUUsR0FBSTtnQkFDcEV0QixhQUFhO1lBQ2Y7WUFFQSxJQUFJLE9BQU85SyxLQUFLcU0sTUFBTSxDQUFDTCxLQUFLLEtBQUssYUFBYTtnQkFDNUMsWUFBWTtnQkFDWixJQUFJTSxhQUFhdE0sS0FBS3FNLE1BQU0sQ0FBQ0wsS0FBSztnQkFDbENDLFFBQVFLLHNCQUFzQjNCLGVBQWUyQixhQUFhQSxVQUFVLENBQUN4QixXQUFXO1lBQ2xGO1FBQ0YsT0FBTztZQUNMbUIsUUFBUWpNLEtBQUtxTSxNQUFNLENBQUNMLEtBQUs7UUFDM0I7UUFFQSxJQUFJLENBQUNDLE9BQU87WUFDVkEsUUFBUWpNLEtBQUt1TSxZQUFZO1FBQzNCO1FBRUEsT0FBT047SUFDVDtJQUVBdFAsVUFBVTtRQUNSLE9BQU87SUFDVDtJQUVBNlAsZ0JBQWdCem5CLElBQUksRUFBRTtRQUNwQixJQUFJMFgsV0FBVzFYLFFBQVEsSUFBSSxDQUFDQSxJQUFJO1FBQ2hDLElBQUl1WCxhQUFhTixNQUFNQyxJQUFJLENBQUNRLFNBQVNnUSxVQUFVLENBQUNuUSxVQUFVO1FBQzFELElBQUluWCxRQUFRbVgsV0FBV3dDLE9BQU8sQ0FBQ3JDO1FBQy9CLElBQUlpUSxZQUFZcFEsV0FBVzFZLE1BQU0sR0FBRztRQUNwQyxJQUFJMFUsT0FBTy9TLGVBQ1gsbUJBQW1CO1FBQ25Ca1gsU0FBU3JFLFdBQVcsSUFBSTtRQUV4QixJQUFJalQsVUFBVSxHQUFHO1lBQ2ZtVCxPQUFPNVMsU0FBUzRTO1FBQ2xCO1FBRUEsSUFBSW5ULFVBQVV1bkIsV0FBVztZQUN2QnBVLE9BQU8zUyxVQUFVMlM7UUFDbkI7UUFFQSxPQUFPQTtJQUNUO0lBRUFrRixlQUFlblIsR0FBRyxFQUFFO1FBQ2xCLElBQUksSUFBSSxDQUFDNEUsSUFBSSxLQUFLLFFBQVE7WUFDeEIsSUFBSSxDQUFDMGIsc0JBQXNCLENBQUN0Z0I7WUFDNUI7UUFDRixFQUFFLG1DQUFtQztRQUdyQyxJQUFJLENBQUM2ZSxxQkFBcUI7UUFDMUIsSUFBSSxDQUFDTywrQkFBK0IsQ0FBQ3BmLE1BQU0sY0FBYztRQUV6RCxJQUFJLENBQUN5UCxRQUFRLENBQUNoTSxPQUFPLENBQUMsQ0FBQzJDLEdBQUcxRjtZQUN4QixJQUFJLENBQUM2ZixXQUFXLENBQUN2Z0IsS0FBSyxJQUFJLEVBQUUsSUFBSSxFQUFFVTtRQUNwQztRQUNBLElBQUksRUFDRjJFLEtBQUssRUFDTixHQUFHLElBQUksQ0FBQ3JJLFFBQVEsQ0FBQ21DLE1BQU0sRUFBRSxvREFBb0Q7UUFFOUUsSUFBSWtHLE1BQU1yQyxTQUFTLElBQUk7WUFDckJxQyxNQUFNdEIsZ0JBQWdCLENBQUMsSUFBSSxFQUFFLElBQUksQ0FBQzRYLGNBQWMsQ0FBQzNiO1FBQ25EO0lBQ0Y7SUFFQXNnQix1QkFBdUJ0Z0IsR0FBRyxFQUFFO1FBQzFCLElBQUksRUFDRmhELFVBQUFBLFNBQVEsRUFDUjJHLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJNmMsYUFBYSxJQUFJLENBQUNsUSxPQUFPO1FBQzdCLElBQUltUSxhQUFhOWMsT0FBT3VHLFFBQVEsQ0FBQyxlQUFleEssYUFBYTtRQUU3RCxJQUFJK2dCLFlBQVk7WUFDZCxJQUFJLEVBQ0ZDLFVBQVUsRUFDWCxHQUFHRCxXQUFXRSxRQUFRO1lBQ3ZCLElBQUlDLFVBQVV0TixLQUFLNVIsS0FBSyxDQUFDMUUsVUFBU2dELEdBQUcsQ0FBQzJULElBQUk7WUFDMUMsSUFBSUgsV0FBVzdQLE9BQU91RyxRQUFRLENBQUMsYUFBYTlMLFNBQVMsQ0FBQ3dpQixRQUFRcE4sUUFBUTtZQUN0RSxJQUFJUCxZQUFZdFAsT0FBT3VHLFFBQVEsQ0FBQyxjQUFjNU0sU0FBUyxDQUFDc2pCLFFBQVEzTixTQUFTO1lBQ3pFLElBQUluUixRQUFRMFIsV0FBV2tOO1lBQ3ZCLElBQUl6VSxPQUFPd1UsV0FBV0ksS0FBSyxHQUFHTCxXQUFXcGpCLEtBQUssQ0FBQyxJQUFJMGpCLE9BQU8sR0FBR2xsQixJQUFJLENBQUMsTUFBTTRrQjtZQUN4RSxJQUFJTyxLQUFLeG5CLFVBQVVvSyxPQUFPdkQsWUFBWSxDQUFDLE1BQU05QyxTQUFTO1lBQ3RELElBQUlrRCxNQUFNeUwsS0FBSzFVLE1BQU07WUFFckIsSUFBSyxJQUFJbUosSUFBSSxHQUFHQSxJQUFJRixLQUFLRSxJQUFLO2dCQUM1QixJQUFJa2YsUUFBUSxJQUFJLENBQUNGLFFBQVEsQ0FBQ2UsWUFBWXhVLE1BQU12TDtnQkFDNUNWLElBQUlvSSxTQUFTLENBQUMsSUFBSSxDQUFDNUcsQ0FBQyxFQUFFLElBQUksQ0FBQ0MsQ0FBQztnQkFDNUJ6QixJQUFJOEIsS0FBSyxDQUFDQSxPQUFPLENBQUNBO2dCQUNsQixJQUFJa2YsS0FBS2hoQixJQUFJbVosU0FBUztnQkFDdEJuWixJQUFJbVosU0FBUyxHQUFHblosSUFBSW1aLFNBQVMsR0FBR3VILGFBQWFsTjtnQkFFN0MsSUFBSVAsY0FBYyxVQUFVO29CQUMxQmpULElBQUlzQyxTQUFTLENBQUMsR0FBRyxHQUFHLElBQUksR0FBRyxHQUFHO2dCQUNoQztnQkFFQXNkLE1BQU1yVyxNQUFNLENBQUN2SjtnQkFFYixJQUFJaVQsY0FBYyxVQUFVO29CQUMxQmpULElBQUlzQyxTQUFTLENBQUMsR0FBRyxHQUFHLENBQUMsSUFBSSxHQUFHLEdBQUc7Z0JBQ2pDO2dCQUVBdEMsSUFBSW1aLFNBQVMsR0FBRzZIO2dCQUNoQmhoQixJQUFJOEIsS0FBSyxDQUFDLElBQUlBLE9BQU8sQ0FBQyxJQUFJQTtnQkFDMUI5QixJQUFJb0ksU0FBUyxDQUFDLENBQUMsSUFBSSxDQUFDNUcsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDQyxDQUFDO2dCQUM5QixJQUFJLENBQUNELENBQUMsSUFBSWdTLFdBQVlvTSxDQUFBQSxNQUFNckIsU0FBUyxJQUFJa0MsV0FBV2xDLFNBQVMsSUFBSW1DO2dCQUVqRSxJQUFJLE9BQU9LLEVBQUUsQ0FBQ3JnQixFQUFFLEtBQUssZUFBZSxDQUFDbUssTUFBTWtXLEVBQUUsQ0FBQ3JnQixFQUFFLEdBQUc7b0JBQ2pELElBQUksQ0FBQ2MsQ0FBQyxJQUFJdWYsRUFBRSxDQUFDcmdCLEVBQUU7Z0JBQ2pCO1lBQ0Y7WUFFQTtRQUNGO1FBRUEsSUFBSSxFQUNGYyxDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHLElBQUksRUFBRSxZQUFZO1FBQ3RCLHFDQUFxQztRQUNyQywwQkFBMEI7UUFDMUIsc0NBQXNDO1FBQ3RDLEtBQUs7UUFDTCx3QkFBd0I7UUFDeEIsb0NBQW9DO1FBQ3BDLEtBQUs7UUFDTCxXQUFXO1FBRVgsSUFBSXpCLElBQUk0WSxTQUFTLEVBQUU7WUFDakI1WSxJQUFJaWhCLFFBQVEsQ0FBQ1QsWUFBWWhmLEdBQUdDO1FBQzlCO1FBRUEsSUFBSXpCLElBQUl1RyxXQUFXLEVBQUU7WUFDbkJ2RyxJQUFJa2hCLFVBQVUsQ0FBQ1YsWUFBWWhmLEdBQUdDO1FBQ2hDLEVBQUUsSUFBSTtJQUVSO0lBRUEwZixpQkFBaUI7UUFDZixJQUFJLElBQUksQ0FBQ3BDLGNBQWMsSUFBSSxJQUFJLENBQUNELFNBQVMsQ0FBQ3ZuQixNQUFNLEVBQUU7WUFDaEQ7UUFDRixFQUFFLDRHQUE0RztRQUM5RywrR0FBK0c7UUFDL0csa0NBQWtDO1FBR2xDLElBQUk2cEIsZUFBZSxJQUFJLENBQUN0QyxTQUFTLENBQUMsSUFBSSxDQUFDQyxjQUFjLENBQUM7UUFDdEQsSUFBSXNDLGFBQWFELGFBQWFsWCxRQUFRLENBQUMsZUFBZTVNLFNBQVMsQ0FBQztRQUNoRSxJQUFJdWpCLFFBQVEsT0FBTyx3QkFBd0I7UUFFM0MsSUFBSVMsUUFBUTtRQUVaLElBQUlELGVBQWUsV0FBVyxDQUFDUixTQUFTUSxlQUFlLFNBQVNSLE9BQU87WUFDckVTLFFBQVFGLGFBQWE1ZixDQUFDLEdBQUcsSUFBSSxDQUFDdUYsSUFBSTtRQUNwQyxPQUFPLElBQUlzYSxlQUFlLFNBQVMsQ0FBQ1IsU0FBU1EsZUFBZSxXQUFXUixPQUFPO1lBQzVFUyxRQUFRRixhQUFhNWYsQ0FBQyxHQUFHLElBQUksQ0FBQ3lkLElBQUk7UUFDcEMsT0FBTztZQUNMcUMsUUFBUUYsYUFBYTVmLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQ3VGLElBQUksR0FBRyxJQUFJLENBQUNrWSxJQUFJLElBQUk7UUFDckQ7UUFFQSxJQUFLLElBQUl2ZSxJQUFJLElBQUksQ0FBQ3FlLGNBQWMsRUFBRXJlLElBQUksSUFBSSxDQUFDb2UsU0FBUyxDQUFDdm5CLE1BQU0sRUFBRW1KLElBQUs7WUFDaEUsSUFBSSxDQUFDb2UsU0FBUyxDQUFDcGUsRUFBRSxDQUFDYyxDQUFDLElBQUk4ZjtRQUN6QixFQUFFLGtCQUFrQjtRQUdwQixJQUFJLENBQUN2YSxJQUFJLEdBQUdxTixPQUFPNEssaUJBQWlCO1FBQ3BDLElBQUksQ0FBQ0MsSUFBSSxHQUFHN0ssT0FBTzhLLGlCQUFpQjtRQUNwQyxJQUFJLENBQUNILGNBQWMsR0FBRyxJQUFJLENBQUNELFNBQVMsQ0FBQ3ZuQixNQUFNO0lBQzdDO0lBRUE2bkIsZ0NBQWdDcGYsR0FBRyxFQUFFO1FBQ25DLElBQUksQ0FBQ3lQLFFBQVEsQ0FBQ2hNLE9BQU8sQ0FBQyxDQUFDMkMsR0FBRzFGO1lBQ3hCLElBQUksQ0FBQzZnQixtQ0FBbUMsQ0FBQ3ZoQixLQUFLLElBQUksRUFBRSxJQUFJLEVBQUVVO1FBQzVEO1FBQ0EsSUFBSSxDQUFDeWdCLGNBQWM7SUFDckI7SUFFQUksb0NBQW9DdmhCLEdBQUcsRUFBRXdoQixVQUFVLEVBQUU3ZCxNQUFNLEVBQUVqRCxDQUFDLEVBQUU7UUFDOUQsSUFBSTZRLFFBQVE1TixPQUFPOEwsUUFBUSxDQUFDL08sRUFBRTtRQUU5QixJQUFJNlEsTUFBTTlCLFFBQVEsQ0FBQ2xZLE1BQU0sR0FBRyxHQUFHO1lBQzdCZ2EsTUFBTTlCLFFBQVEsQ0FBQ2hNLE9BQU8sQ0FBQyxDQUFDMkMsR0FBRzFGO2dCQUN6QjhnQixXQUFXRCxtQ0FBbUMsQ0FBQ3ZoQixLQUFLd2hCLFlBQVlqUSxPQUFPN1E7WUFDekU7UUFDRixPQUFPO1lBQ0wsMEJBQTBCO1lBQzFCLElBQUksQ0FBQytnQixzQkFBc0IsQ0FBQ3poQixLQUFLd2hCLFlBQVk3ZCxRQUFRakQ7UUFDdkQ7SUFDRjtJQUVBK2dCLHVCQUF1QnpoQixHQUFHLEVBQUV3aEIsVUFBVSxFQUFFN2QsTUFBTSxFQUFFakQsQ0FBQyxFQUFFO1FBQ2pELElBQUk2USxRQUFRNU4sT0FBTzhMLFFBQVEsQ0FBQy9PLEVBQUU7UUFFOUIsSUFBSSxPQUFPNlEsTUFBTWtPLFdBQVcsS0FBSyxZQUFZO1lBQzNDLE9BQU9sTztRQUNUO1FBRUF2UixJQUFJOFEsSUFBSTtRQUNSUyxNQUFNTCxVQUFVLENBQUNsUixLQUFLO1FBQ3RCLElBQUkwaEIsUUFBUW5RLE1BQU1uUixZQUFZLENBQUM7UUFDL0IsSUFBSXVoQixRQUFRcFEsTUFBTW5SLFlBQVksQ0FBQztRQUMvQixJQUFJd2hCLFNBQVNyUSxNQUFNblIsWUFBWSxDQUFDO1FBQ2hDLElBQUl5aEIsU0FBU3RRLE1BQU1uUixZQUFZLENBQUM7UUFDaEMsSUFBSXFnQixhQUFhbFAsTUFBTXJILFFBQVEsQ0FBQyxlQUFleEssYUFBYTtRQUM1RCxJQUFJbWhCLFFBQVF4QyxRQUFRb0MsZUFBZUEsV0FBV0ksS0FBSztRQUVuRCxJQUFJbmdCLE1BQU0sR0FBRztZQUNYLDBFQUEwRTtZQUMxRSx3REFBd0Q7WUFDeEQsSUFBSSxDQUFDZ2hCLE1BQU1sa0IsUUFBUSxJQUFJO2dCQUNyQmtrQixNQUFNempCLFFBQVEsQ0FBQ3NULE1BQU11USxxQkFBcUIsQ0FBQztZQUM3QztZQUVBLElBQUksQ0FBQ0gsTUFBTW5rQixRQUFRLElBQUk7Z0JBQ3JCbWtCLE1BQU0xakIsUUFBUSxDQUFDc1QsTUFBTXVRLHFCQUFxQixDQUFDO1lBQzdDO1lBRUEsSUFBSSxDQUFDRixPQUFPcGtCLFFBQVEsSUFBSTtnQkFDdEJva0IsT0FBTzNqQixRQUFRLENBQUNzVCxNQUFNdVEscUJBQXFCLENBQUM7WUFDOUM7WUFFQSxJQUFJLENBQUNELE9BQU9ya0IsUUFBUSxJQUFJO2dCQUN0QnFrQixPQUFPNWpCLFFBQVEsQ0FBQ3NULE1BQU11USxxQkFBcUIsQ0FBQztZQUM5QztRQUNGO1FBRUEsSUFBSWhxQixRQUFReVosTUFBTWtPLFdBQVcsQ0FBQ3pmO1FBRTlCLElBQUk2Z0IsT0FBTztZQUNUVyxXQUFXaGdCLENBQUMsSUFBSTFKO1FBQ2xCO1FBRUEsSUFBSTRwQixNQUFNbGtCLFFBQVEsSUFBSTtZQUNwQixrREFBa0Q7WUFDbERna0IsV0FBV0wsY0FBYztZQUN6QjVQLE1BQU0vUCxDQUFDLEdBQUdrZ0IsTUFBTTdpQixTQUFTLENBQUM7WUFFMUIsSUFBSStpQixPQUFPcGtCLFFBQVEsSUFBSTtnQkFDckIrVCxNQUFNL1AsQ0FBQyxJQUFJb2dCLE9BQU8vaUIsU0FBUyxDQUFDO1lBQzlCO1FBQ0YsT0FBTztZQUNMLElBQUkraUIsT0FBT3BrQixRQUFRLElBQUk7Z0JBQ3JCZ2tCLFdBQVdoZ0IsQ0FBQyxJQUFJb2dCLE9BQU8vaUIsU0FBUyxDQUFDO1lBQ25DO1lBRUEwUyxNQUFNL1AsQ0FBQyxHQUFHZ2dCLFdBQVdoZ0IsQ0FBQztRQUN4QjtRQUVBZ2dCLFdBQVdoZ0IsQ0FBQyxHQUFHK1AsTUFBTS9QLENBQUM7UUFFdEIsSUFBSSxDQUFDcWYsT0FBTztZQUNWVyxXQUFXaGdCLENBQUMsSUFBSTFKO1FBQ2xCO1FBRUEsSUFBSTZwQixNQUFNbmtCLFFBQVEsSUFBSTtZQUNwQitULE1BQU05UCxDQUFDLEdBQUdrZ0IsTUFBTTlpQixTQUFTLENBQUM7WUFFMUIsSUFBSWdqQixPQUFPcmtCLFFBQVEsSUFBSTtnQkFDckIrVCxNQUFNOVAsQ0FBQyxJQUFJb2dCLE9BQU9oakIsU0FBUyxDQUFDO1lBQzlCO1FBQ0YsT0FBTztZQUNMLElBQUlnakIsT0FBT3JrQixRQUFRLElBQUk7Z0JBQ3JCZ2tCLFdBQVcvZixDQUFDLElBQUlvZ0IsT0FBT2hqQixTQUFTLENBQUM7WUFDbkM7WUFFQTBTLE1BQU05UCxDQUFDLEdBQUcrZixXQUFXL2YsQ0FBQztRQUN4QjtRQUVBK2YsV0FBVy9mLENBQUMsR0FBRzhQLE1BQU05UCxDQUFDLEVBQUUsMkNBQTJDO1FBRW5FK2YsV0FBVzFDLFNBQVMsQ0FBQzVkLElBQUksQ0FBQ3FRO1FBQzFCaVEsV0FBV3phLElBQUksR0FBR25NLEtBQUt3RSxHQUFHLENBQUNvaUIsV0FBV3phLElBQUksRUFBRXdLLE1BQU0vUCxDQUFDLEVBQUUrUCxNQUFNL1AsQ0FBQyxHQUFHMUo7UUFDL0QwcEIsV0FBV3ZDLElBQUksR0FBR3JrQixLQUFLMEUsR0FBRyxDQUFDa2lCLFdBQVd2QyxJQUFJLEVBQUUxTixNQUFNL1AsQ0FBQyxFQUFFK1AsTUFBTS9QLENBQUMsR0FBRzFKO1FBQy9EeVosTUFBTUgsWUFBWSxDQUFDcFI7UUFDbkJBLElBQUlxUixPQUFPO1FBQ1gsT0FBT0U7SUFDVDtJQUVBK04sb0JBQW9CdGYsR0FBRyxFQUFFd2hCLFVBQVUsRUFBRTdkLE1BQU0sRUFBRWpELENBQUMsRUFBRTtRQUM5QyxJQUFJNlEsUUFBUTVOLE9BQU84TCxRQUFRLENBQUMvTyxFQUFFLEVBQUUsbUJBQW1CO1FBRW5ELElBQUksT0FBTzZRLE1BQU1vSyxjQUFjLEtBQUssWUFBWTtZQUM5QyxPQUFPO1FBQ1Q7UUFFQSxJQUFJM1gsY0FBY3VOLE1BQU1vSyxjQUFjLENBQUMzYjtRQUV2QyxJQUFJLENBQUNnRSxhQUFhO1lBQ2hCLE9BQU87UUFDVDtRQUVBdU4sTUFBTTlCLFFBQVEsQ0FBQ2hNLE9BQU8sQ0FBQyxDQUFDMkMsR0FBRzFGO1lBQ3pCLElBQUkyZSxtQkFBbUJtQyxXQUFXbEMsbUJBQW1CLENBQUN0ZixLQUFLd2hCLFlBQVlqUSxPQUFPN1E7WUFDOUVzRCxZQUFZNFEsY0FBYyxDQUFDeUs7UUFDN0I7UUFDQSxPQUFPcmI7SUFDVDtJQUVBdWMsWUFBWXZnQixHQUFHLEVBQUV3aEIsVUFBVSxFQUFFN2QsTUFBTSxFQUFFakQsQ0FBQyxFQUFFO1FBQ3RDLElBQUk2USxRQUFRNU4sT0FBTzhMLFFBQVEsQ0FBQy9PLEVBQUU7UUFDOUI2USxNQUFNaEksTUFBTSxDQUFDdko7UUFDYnVSLE1BQU05QixRQUFRLENBQUNoTSxPQUFPLENBQUMsQ0FBQzJDLEdBQUcxRjtZQUN6QjhnQixXQUFXakIsV0FBVyxDQUFDdmdCLEtBQUt3aEIsWUFBWWpRLE9BQU83UTtRQUNqRDtJQUNGO0lBRUErZSxZQUFZemYsR0FBRyxFQUFFO1FBQ2YsSUFBSSxFQUNGMmUsWUFBWSxFQUNiLEdBQUcsSUFBSTtRQUVSLElBQUksQ0FBQ0EsY0FBYztZQUNqQixPQUFPQTtRQUNUO1FBRUEsSUFBSTZCLGFBQWEsSUFBSSxDQUFDbFEsT0FBTztRQUM3QixJQUFJeVIsVUFBVSxJQUFJLENBQUNDLGlCQUFpQixDQUFDaGlCLEtBQUt3Z0I7UUFDMUMsSUFBSSxDQUFDN0IsWUFBWSxHQUFHb0Q7UUFDcEIsT0FBT0E7SUFDVDtJQUVBQyxrQkFBa0JoaUIsR0FBRyxFQUFFaWlCLFVBQVUsRUFBRTtRQUNqQyxJQUFJLENBQUNBLFdBQVcxcUIsTUFBTSxFQUFFO1lBQ3RCLE9BQU87UUFDVDtRQUVBLElBQUksRUFDRm9NLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJOGMsYUFBYTljLE9BQU91RyxRQUFRLENBQUMsZUFBZXhLLGFBQWE7UUFFN0QsSUFBSStnQixZQUFZO1lBQ2QsSUFBSWpOLFdBQVcsSUFBSSxDQUFDK0wsV0FBVztZQUMvQixJQUFJdFQsT0FBT3dVLFdBQVdJLEtBQUssR0FBR29CLFdBQVc3a0IsS0FBSyxDQUFDLElBQUkwakIsT0FBTyxHQUFHbGxCLElBQUksQ0FBQyxNQUFNcW1CO1lBQ3hFLElBQUlsQixLQUFLeG5CLFVBQVVvSyxPQUFPdkQsWUFBWSxDQUFDLE1BQU05QyxTQUFTO1lBQ3RELElBQUlrRCxNQUFNeUwsS0FBSzFVLE1BQU07WUFDckIsSUFBSTJxQixXQUFXO1lBRWYsSUFBSyxJQUFJeGhCLElBQUksR0FBR0EsSUFBSUYsS0FBS0UsSUFBSztnQkFDNUIsSUFBSWtmLFFBQVEsSUFBSSxDQUFDRixRQUFRLENBQUNlLFlBQVl4VSxNQUFNdkw7Z0JBQzVDd2hCLFlBQVksQ0FBQ3RDLE1BQU1yQixTQUFTLElBQUlrQyxXQUFXbEMsU0FBUyxJQUFJL0ssV0FBV2lOLFdBQVdFLFFBQVEsQ0FBQ0QsVUFBVTtnQkFFakcsSUFBSSxPQUFPSyxFQUFFLENBQUNyZ0IsRUFBRSxLQUFLLGVBQWUsQ0FBQ21LLE1BQU1rVyxFQUFFLENBQUNyZ0IsRUFBRSxHQUFHO29CQUNqRHdoQixZQUFZbkIsRUFBRSxDQUFDcmdCLEVBQUU7Z0JBQ25CO1lBQ0Y7WUFFQSxPQUFPd2hCO1FBQ1Q7UUFFQSxJQUFJLENBQUNsaUIsSUFBSXlmLFdBQVcsRUFBRTtZQUNwQixPQUFPd0MsV0FBVzFxQixNQUFNLEdBQUc7UUFDN0I7UUFFQXlJLElBQUk4USxJQUFJO1FBQ1IsSUFBSSxDQUFDSSxVQUFVLENBQUNsUixLQUFLO1FBQ3JCLElBQUksRUFDRmxJLE9BQU9pcUIsT0FBTyxFQUNmLEdBQUcvaEIsSUFBSXlmLFdBQVcsQ0FBQ3dDO1FBQ3BCLElBQUksQ0FBQzdRLFlBQVksQ0FBQ3BSO1FBQ2xCQSxJQUFJcVIsT0FBTztRQUNYLE9BQU8wUTtJQUNUO0lBQ0E7Ozs7O0dBS0MsR0FHREQsc0JBQXNCaG9CLElBQUksRUFBRTtRQUMxQiw0RUFBNEU7UUFDNUUsSUFBSXljLFVBQVUsSUFBSTtRQUVsQixNQUFPQSxtQkFBbUJtSSxlQUFlbkksUUFBUWhFLFlBQVksR0FBSTtZQUMvRCxJQUFJNFAsYUFBYTVMLFFBQVE1UyxNQUFNLENBQUN2RCxZQUFZLENBQUN0RztZQUU3QyxJQUFJcW9CLFdBQVcza0IsUUFBUSxDQUFDLE9BQU87Z0JBQzdCLE9BQU8ya0IsV0FBV2prQixRQUFRLENBQUM7WUFDN0I7WUFFQXFZLFVBQVVBLFFBQVE1UyxNQUFNO1FBQzFCO1FBRUEsT0FBTztJQUNUO0FBRUY7QUFFQSxNQUFNeWUscUJBQXFCMUQ7SUFDekIzaEIsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU0sZUFBZTBwQixlQUFlLE9BQU9sVDtRQUMzRCxJQUFJLENBQUN0SyxJQUFJLEdBQUcsU0FBUyxvREFBb0Q7UUFFekUsSUFBSSxDQUFDcUgsSUFBSSxHQUFHLElBQUksQ0FBQ3dELFFBQVEsQ0FBQ2xZLE1BQU0sR0FBRyxJQUFJLEtBQUssSUFBSSxDQUFDNG9CLGVBQWU7SUFDbEU7SUFFQTdQLFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQ3JFLElBQUk7SUFDbEI7QUFFRjtBQUVBLE1BQU1vVyxpQkFBaUJEO0lBQ3JCcmxCLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0FBRUY7QUFFQSxNQUFNMGQsbUJBQW1Cbks7SUFDdkJwYixhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUMyZCxJQUFJLEdBQUc7SUFDZDtJQUVBclIsV0FBV2xSLEdBQUcsRUFBRTtRQUNkLElBQUl3aUI7UUFFSixJQUFJLEVBQ0Z4bEIsVUFBQUEsU0FBUSxFQUNULEdBQUcsSUFBSTtRQUNSLElBQUksRUFDRm1DLE1BQU0sRUFDTnpILFFBQUFBLE9BQU0sRUFDUCxHQUFHc0Y7UUFDSixJQUFJcEUsU0FBU29ILElBQUlwSCxNQUFNO1FBQ3ZCdUcsT0FBT21ILFdBQVcsQ0FBQ3RHO1FBRW5CLElBQUlwSCxPQUFPMkssS0FBSyxJQUFJLE9BQU92RCxJQUFJMlQsSUFBSSxLQUFLLGVBQWVqYyxXQUFVLE9BQU9BLFFBQU8rcUIsZ0JBQWdCLEtBQUssYUFBYTtZQUMvR3ppQixJQUFJMlQsSUFBSSxHQUFHamMsUUFBTytxQixnQkFBZ0IsQ0FBQzdwQixRQUFROHBCLGdCQUFnQixDQUFDO1lBQzVELElBQUlDLGVBQWUsSUFBSTdsQixTQUFTRSxXQUFVLFlBQVlzVyxLQUFLNVIsS0FBSyxDQUFDMUIsSUFBSTJULElBQUksRUFBRUgsUUFBUTtZQUVuRixJQUFJbVAsYUFBYW5sQixRQUFRLElBQUk7Z0JBQzNCUixVQUFTeUIsVUFBVSxHQUFHa2tCLGFBQWE5akIsU0FBUyxDQUFDO2dCQUM3QzdCLFVBQVMyQixNQUFNLEdBQUczQixVQUFTeUIsVUFBVTtZQUN2QztRQUNGLEVBQUUsdUJBQXVCO1FBR3pCLElBQUksQ0FBQyxJQUFJLENBQUMyQixZQUFZLENBQUMsS0FBSzVDLFFBQVEsSUFBSTtZQUN0QyxJQUFJLENBQUM0QyxZQUFZLENBQUMsS0FBSyxNQUFNbkMsUUFBUSxDQUFDO1FBQ3hDO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ21DLFlBQVksQ0FBQyxLQUFLNUMsUUFBUSxJQUFJO1lBQ3RDLElBQUksQ0FBQzRDLFlBQVksQ0FBQyxLQUFLLE1BQU1uQyxRQUFRLENBQUM7UUFDeEM7UUFFQSxJQUFJLEVBQ0ZuRyxLQUFLLEVBQ0xDLE1BQU0sRUFDUCxHQUFHb0gsT0FBT0QsUUFBUTtRQUVuQixJQUFJLENBQUMsSUFBSSxDQUFDZ0wsUUFBUSxDQUFDLFNBQVMxTSxRQUFRLElBQUk7WUFDdEMsSUFBSSxDQUFDME0sUUFBUSxDQUFDLFNBQVMsTUFBTWpNLFFBQVEsQ0FBQztRQUN4QztRQUVBLElBQUksQ0FBQyxJQUFJLENBQUNpTSxRQUFRLENBQUMsVUFBVTFNLFFBQVEsSUFBSTtZQUN2QyxJQUFJLENBQUMwTSxRQUFRLENBQUMsVUFBVSxNQUFNak0sUUFBUSxDQUFDO1FBQ3pDO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ2lNLFFBQVEsQ0FBQyxTQUFTMU0sUUFBUSxJQUFJO1lBQ3RDLElBQUksQ0FBQzBNLFFBQVEsQ0FBQyxTQUFTLE1BQU1qTSxRQUFRLENBQUM7UUFDeEM7UUFFQSxJQUFJMmtCLFdBQVcsSUFBSSxDQUFDeGlCLFlBQVksQ0FBQztRQUNqQyxJQUFJeWlCLFdBQVcsSUFBSSxDQUFDemlCLFlBQVksQ0FBQztRQUNqQyxJQUFJMGlCLGNBQWMsSUFBSSxDQUFDMWlCLFlBQVksQ0FBQztRQUNwQyxJQUFJcUssVUFBVXFZLFlBQVl0bEIsUUFBUSxLQUFLakUsVUFBVXVwQixZQUFZeGxCLFNBQVMsTUFBTTtRQUM1RSxJQUFJNkosT0FBTyxDQUFDLElBQUksQ0FBQ29iLElBQUksSUFBSSxJQUFJLENBQUNyWSxRQUFRLENBQUMsWUFBWWhNLFFBQVEsQ0FBQyxjQUFjO1FBQzFFLElBQUk2SSxPQUFPO1FBQ1gsSUFBSUMsT0FBTztRQUNYLElBQUlJLFFBQVE7UUFDWixJQUFJQyxRQUFRO1FBRVosSUFBSW9ELFNBQVM7WUFDWDFELE9BQU8wRCxPQUFPLENBQUMsRUFBRTtZQUNqQnpELE9BQU95RCxPQUFPLENBQUMsRUFBRTtRQUNuQjtRQUVBLElBQUksQ0FBQyxJQUFJLENBQUM4WCxJQUFJLEVBQUU7WUFDZHpxQixRQUFRLElBQUksQ0FBQ29TLFFBQVEsQ0FBQyxTQUFTckwsU0FBUyxDQUFDO1lBQ3pDOUcsU0FBUyxJQUFJLENBQUNtUyxRQUFRLENBQUMsVUFBVXJMLFNBQVMsQ0FBQztZQUUzQyxJQUFJLElBQUksQ0FBQytGLElBQUksS0FBSyxVQUFVO2dCQUMxQndDLFFBQVFMO2dCQUNSTSxRQUFRTDtnQkFDUkQsT0FBTztnQkFDUEMsT0FBTztZQUNUO1FBQ0Y7UUFFQTdILE9BQU9ELFFBQVEsQ0FBQytCLFVBQVUsQ0FBQ25KLE9BQU9DLFNBQVMseUVBQXlFO1FBQ3BILDhFQUE4RTtRQUU5RSxJQUFJLElBQUksQ0FBQ1csSUFBSSxDQUFDLDhCQUE4QjtZQUN4QyxFQUFDLElBQUksQ0FBQ2lMLE1BQU0sSUFBSSxDQUFDLENBQUM2ZSx3QkFBd0IsSUFBSSxDQUFDOXBCLElBQUksQ0FBQzBuQixVQUFVLE1BQU0sUUFBUW9DLDBCQUEwQixLQUFLLElBQUksS0FBSyxJQUFJQSxzQkFBc0IxUyxRQUFRLE1BQU0sZUFBYyxLQUFNLElBQUksQ0FBQzVGLFFBQVEsQ0FBQyxhQUFhLE9BQU8sTUFBTTFNLFFBQVEsTUFBTSxDQUFDLElBQUksQ0FBQzBNLFFBQVEsQ0FBQyxvQkFBb0IsT0FBTyxNQUFNMU0sUUFBUSxJQUFJO1lBQ3BTLElBQUksQ0FBQzBNLFFBQVEsQ0FBQyxvQkFBb0IsTUFBTSxNQUFNak0sUUFBUSxDQUFDO1FBQ3pEO1FBRUEsS0FBSyxDQUFDaVQsV0FBV2xSO1FBQ2pCQSxJQUFJb0ksU0FBUyxDQUFDLElBQUksQ0FBQ2hJLFlBQVksQ0FBQyxLQUFLdkIsU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDdUIsWUFBWSxDQUFDLEtBQUt2QixTQUFTLENBQUM7UUFFdEYsSUFBSTRMLFNBQVM7WUFDWDNTLFFBQVEyUyxPQUFPLENBQUMsRUFBRTtZQUNsQjFTLFNBQVMwUyxPQUFPLENBQUMsRUFBRTtRQUNyQjtRQUVBek4sVUFBUzJKLFVBQVUsQ0FBQztZQUNsQjNHO1lBQ0E0RyxhQUFhLElBQUksQ0FBQ3hHLFlBQVksQ0FBQyx1QkFBdUI5QyxTQUFTO1lBQy9EeEYsT0FBT3FILE9BQU9ELFFBQVEsQ0FBQ3BILEtBQUs7WUFDNUIrTyxjQUFjL087WUFDZEMsUUFBUW9ILE9BQU9ELFFBQVEsQ0FBQ25ILE1BQU07WUFDOUIrTyxlQUFlL087WUFDZmdQO1lBQ0FDO1lBQ0FDLE1BQU0yYixTQUFTMWtCLFFBQVE7WUFDdkJnSixNQUFNMmIsU0FBUzNrQixRQUFRO1lBQ3ZCaUo7WUFDQUM7WUFDQUM7UUFDRjtRQUVBLElBQUlvRCxTQUFTO1lBQ1h0TCxPQUFPRCxRQUFRLENBQUNpQyxhQUFhO1lBQzdCaEMsT0FBT0QsUUFBUSxDQUFDK0IsVUFBVSxDQUFDbkosT0FBT0M7UUFDcEM7SUFDRjtJQUVBcVosYUFBYXBSLEdBQUcsRUFBRTtRQUNoQixLQUFLLENBQUNvUixhQUFhcFI7UUFDbkIsSUFBSSxDQUFDaEQsUUFBUSxDQUFDbUMsTUFBTSxDQUFDRCxRQUFRLENBQUNpQyxhQUFhO0lBQzdDO0lBQ0E7Ozs7O0dBS0MsR0FHRDRoQixPQUFPanJCLEtBQUssRUFBRTtRQUNaLElBQUlDLFNBQVNULFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHUTtRQUNqRixJQUFJa3JCLHNCQUFzQjFyQixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUM5RixJQUFJMnJCLFlBQVksSUFBSSxDQUFDN2lCLFlBQVksQ0FBQyxTQUFTO1FBQzNDLElBQUk4aUIsYUFBYSxJQUFJLENBQUM5aUIsWUFBWSxDQUFDLFVBQVU7UUFDN0MsSUFBSTBpQixjQUFjLElBQUksQ0FBQzFpQixZQUFZLENBQUM7UUFDcEMsSUFBSStpQixZQUFZLElBQUksQ0FBQy9pQixZQUFZLENBQUM7UUFDbEMsSUFBSWdqQixjQUFjSCxVQUFVN2tCLFNBQVMsQ0FBQztRQUN0QyxJQUFJaWxCLGVBQWVILFdBQVc5a0IsU0FBUyxDQUFDO1FBRXhDLElBQUk0a0IscUJBQXFCO1lBQ3ZCLElBQUksT0FBT0Esd0JBQXdCLFVBQVU7Z0JBQzNDLElBQUksQ0FBQzVpQixZQUFZLENBQUMsdUJBQXVCLE1BQU1uQyxRQUFRLENBQUMra0I7WUFDMUQsT0FBTztnQkFDTCxJQUFJTSwwQkFBMEIsSUFBSSxDQUFDbGpCLFlBQVksQ0FBQztnQkFFaEQsSUFBSWtqQix3QkFBd0I5bEIsUUFBUSxJQUFJO29CQUN0QzhsQix3QkFBd0JybEIsUUFBUSxDQUFDcWxCLHdCQUF3QmhtQixTQUFTLEdBQUdsRSxPQUFPLENBQUMsb0JBQW9CO2dCQUNuRztZQUNGO1FBQ0Y7UUFFQTZwQixVQUFVaGxCLFFBQVEsQ0FBQ25HO1FBQ25Cb3JCLFdBQVdqbEIsUUFBUSxDQUFDbEc7UUFFcEIsSUFBSSxDQUFDK3FCLFlBQVl0bEIsUUFBUSxJQUFJO1lBQzNCc2xCLFlBQVk3a0IsUUFBUSxDQUFDLE9BQU9tTSxNQUFNLENBQUNnWixlQUFldHJCLE9BQU8sS0FBS3NTLE1BQU0sQ0FBQ2laLGdCQUFnQnRyQjtRQUN2RjtRQUVBLElBQUlvckIsVUFBVTNsQixRQUFRLElBQUk7WUFDeEIsSUFBSXlNLGFBQWEsSUFBSSxDQUFDQyxRQUFRLENBQUM7WUFDL0IsSUFBSUMsY0FBYyxJQUFJLENBQUNELFFBQVEsQ0FBQztZQUVoQyxJQUFJRCxXQUFXek0sUUFBUSxJQUFJO2dCQUN6QnlNLFdBQVdoTSxRQUFRLENBQUMsR0FBR21NLE1BQU0sQ0FBQ3RTLE9BQU87WUFDdkM7WUFFQSxJQUFJcVMsWUFBWTNNLFFBQVEsSUFBSTtnQkFDMUIyTSxZQUFZbE0sUUFBUSxDQUFDLEdBQUdtTSxNQUFNLENBQUNyUyxRQUFRO1lBQ3pDO1FBQ0Y7SUFDRjtBQUVGO0FBRUEsTUFBTXdyQixvQkFBb0I5STtJQUN4QjFkLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUE1QyxLQUFLaEMsR0FBRyxFQUFFO1FBQ1IsSUFBSXdCLElBQUksSUFBSSxDQUFDcEIsWUFBWSxDQUFDLEtBQUt2QixTQUFTLENBQUM7UUFDekMsSUFBSTRDLElBQUksSUFBSSxDQUFDckIsWUFBWSxDQUFDLEtBQUt2QixTQUFTLENBQUM7UUFDekMsSUFBSS9HLFFBQVEsSUFBSSxDQUFDb1MsUUFBUSxDQUFDLFNBQVMsT0FBTyxNQUFNckwsU0FBUyxDQUFDO1FBQzFELElBQUk5RyxTQUFTLElBQUksQ0FBQ21TLFFBQVEsQ0FBQyxVQUFVLE9BQU8sTUFBTXJMLFNBQVMsQ0FBQztRQUM1RCxJQUFJMmtCLFNBQVMsSUFBSSxDQUFDcGpCLFlBQVksQ0FBQztRQUMvQixJQUFJcWpCLFNBQVMsSUFBSSxDQUFDcmpCLFlBQVksQ0FBQztRQUMvQixJQUFJc2pCLEtBQUtGLE9BQU8za0IsU0FBUyxDQUFDO1FBQzFCLElBQUk4a0IsS0FBS0YsT0FBTzVrQixTQUFTLENBQUM7UUFFMUIsSUFBSTJrQixPQUFPaG1CLFFBQVEsTUFBTSxDQUFDaW1CLE9BQU9qbUIsUUFBUSxJQUFJO1lBQzNDbW1CLEtBQUtEO1FBQ1A7UUFFQSxJQUFJRCxPQUFPam1CLFFBQVEsTUFBTSxDQUFDZ21CLE9BQU9obUIsUUFBUSxJQUFJO1lBQzNDa21CLEtBQUtDO1FBQ1A7UUFFQUQsS0FBSzlvQixLQUFLd0UsR0FBRyxDQUFDc2tCLElBQUk1ckIsUUFBUTtRQUMxQjZyQixLQUFLL29CLEtBQUt3RSxHQUFHLENBQUN1a0IsSUFBSTVyQixTQUFTO1FBRTNCLElBQUlpSSxLQUFLO1lBQ1AsSUFBSTRqQixRQUFRLElBQUssRUFBQ2hwQixLQUFLb0IsSUFBSSxDQUFDLEtBQUssS0FBSztZQUN0Q2dFLElBQUl1SSxTQUFTLElBQUkscURBQXFEO1lBRXRFLElBQUl4USxTQUFTLEtBQUtELFFBQVEsR0FBRztnQkFDM0JrSSxJQUFJd0ksTUFBTSxDQUFDaEgsSUFBSWtpQixJQUFJamlCO2dCQUNuQnpCLElBQUl5SSxNQUFNLENBQUNqSCxJQUFJMUosUUFBUTRyQixJQUFJamlCO2dCQUMzQnpCLElBQUkrYyxhQUFhLENBQUN2YixJQUFJMUosUUFBUTRyQixLQUFLRSxRQUFRRixJQUFJamlCLEdBQUdELElBQUkxSixPQUFPMkosSUFBSWtpQixLQUFLQyxRQUFRRCxJQUFJbmlCLElBQUkxSixPQUFPMkosSUFBSWtpQjtnQkFDakczakIsSUFBSXlJLE1BQU0sQ0FBQ2pILElBQUkxSixPQUFPMkosSUFBSTFKLFNBQVM0ckI7Z0JBQ25DM2pCLElBQUkrYyxhQUFhLENBQUN2YixJQUFJMUosT0FBTzJKLElBQUkxSixTQUFTNHJCLEtBQUtDLFFBQVFELElBQUluaUIsSUFBSTFKLFFBQVE0ckIsS0FBS0UsUUFBUUYsSUFBSWppQixJQUFJMUosUUFBUXlKLElBQUkxSixRQUFRNHJCLElBQUlqaUIsSUFBSTFKO2dCQUN4SGlJLElBQUl5SSxNQUFNLENBQUNqSCxJQUFJa2lCLElBQUlqaUIsSUFBSTFKO2dCQUN2QmlJLElBQUkrYyxhQUFhLENBQUN2YixJQUFJa2lCLEtBQUtFLFFBQVFGLElBQUlqaUIsSUFBSTFKLFFBQVF5SixHQUFHQyxJQUFJMUosU0FBUzRyQixLQUFLQyxRQUFRRCxJQUFJbmlCLEdBQUdDLElBQUkxSixTQUFTNHJCO2dCQUNwRzNqQixJQUFJeUksTUFBTSxDQUFDakgsR0FBR0MsSUFBSWtpQjtnQkFDbEIzakIsSUFBSStjLGFBQWEsQ0FBQ3ZiLEdBQUdDLElBQUlraUIsS0FBS0MsUUFBUUQsSUFBSW5pQixJQUFJa2lCLEtBQUtFLFFBQVFGLElBQUlqaUIsR0FBR0QsSUFBSWtpQixJQUFJamlCO2dCQUMxRXpCLElBQUkwSSxTQUFTO1lBQ2Y7UUFDRjtRQUVBLE9BQU8sSUFBSXdMLFlBQVkxUyxHQUFHQyxHQUFHRCxJQUFJMUosT0FBTzJKLElBQUkxSjtJQUM5QztJQUVBNmpCLGFBQWE7UUFDWCxPQUFPO0lBQ1Q7QUFFRjtBQUVBLE1BQU1pSSxzQkFBc0JwSjtJQUMxQjFkLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUE1QyxLQUFLaEMsR0FBRyxFQUFFO1FBQ1IsSUFBSTRNLEtBQUssSUFBSSxDQUFDeE0sWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7UUFDM0MsSUFBSWdPLEtBQUssSUFBSSxDQUFDek0sWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7UUFDM0MsSUFBSW9mLElBQUksSUFBSSxDQUFDN2QsWUFBWSxDQUFDLEtBQUt2QixTQUFTO1FBRXhDLElBQUltQixPQUFPaWUsSUFBSSxHQUFHO1lBQ2hCamUsSUFBSXVJLFNBQVM7WUFDYnZJLElBQUlvZSxHQUFHLENBQUN4UixJQUFJQyxJQUFJb1IsR0FBRyxHQUFHcmpCLEtBQUs2RSxFQUFFLEdBQUcsR0FBRztZQUNuQ08sSUFBSTBJLFNBQVM7UUFDZjtRQUVBLE9BQU8sSUFBSXdMLFlBQVl0SCxLQUFLcVIsR0FBR3BSLEtBQUtvUixHQUFHclIsS0FBS3FSLEdBQUdwUixLQUFLb1I7SUFDdEQ7SUFFQXJDLGFBQWE7UUFDWCxPQUFPO0lBQ1Q7QUFFRjtBQUVBLE1BQU1rSSx1QkFBdUJySjtJQUMzQjFkLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUE1QyxLQUFLaEMsR0FBRyxFQUFFO1FBQ1IsSUFBSTRqQixRQUFRLElBQUssRUFBQ2hwQixLQUFLb0IsSUFBSSxDQUFDLEtBQUssS0FBSztRQUN0QyxJQUFJMG5CLEtBQUssSUFBSSxDQUFDdGpCLFlBQVksQ0FBQyxNQUFNdkIsU0FBUyxDQUFDO1FBQzNDLElBQUk4a0IsS0FBSyxJQUFJLENBQUN2akIsWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7UUFDM0MsSUFBSStOLEtBQUssSUFBSSxDQUFDeE0sWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7UUFDM0MsSUFBSWdPLEtBQUssSUFBSSxDQUFDek0sWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7UUFFM0MsSUFBSW1CLE9BQU8wakIsS0FBSyxLQUFLQyxLQUFLLEdBQUc7WUFDM0IzakIsSUFBSXVJLFNBQVM7WUFDYnZJLElBQUl3SSxNQUFNLENBQUNvRSxLQUFLOFcsSUFBSTdXO1lBQ3BCN00sSUFBSStjLGFBQWEsQ0FBQ25RLEtBQUs4VyxJQUFJN1csS0FBSytXLFFBQVFELElBQUkvVyxLQUFLZ1gsUUFBUUYsSUFBSTdXLEtBQUs4VyxJQUFJL1csSUFBSUMsS0FBSzhXO1lBQy9FM2pCLElBQUkrYyxhQUFhLENBQUNuUSxLQUFLZ1gsUUFBUUYsSUFBSTdXLEtBQUs4VyxJQUFJL1csS0FBSzhXLElBQUk3VyxLQUFLK1csUUFBUUQsSUFBSS9XLEtBQUs4VyxJQUFJN1c7WUFDL0U3TSxJQUFJK2MsYUFBYSxDQUFDblEsS0FBSzhXLElBQUk3VyxLQUFLK1csUUFBUUQsSUFBSS9XLEtBQUtnWCxRQUFRRixJQUFJN1csS0FBSzhXLElBQUkvVyxJQUFJQyxLQUFLOFc7WUFDL0UzakIsSUFBSStjLGFBQWEsQ0FBQ25RLEtBQUtnWCxRQUFRRixJQUFJN1csS0FBSzhXLElBQUkvVyxLQUFLOFcsSUFBSTdXLEtBQUsrVyxRQUFRRCxJQUFJL1csS0FBSzhXLElBQUk3VztZQUMvRTdNLElBQUkwSSxTQUFTO1FBQ2Y7UUFFQSxPQUFPLElBQUl3TCxZQUFZdEgsS0FBSzhXLElBQUk3VyxLQUFLOFcsSUFBSS9XLEtBQUs4VyxJQUFJN1csS0FBSzhXO0lBQ3pEO0lBRUEvSCxhQUFhO1FBQ1gsT0FBTztJQUNUO0FBRUY7QUFFQSxNQUFNbUksb0JBQW9CdEo7SUFDeEIxZCxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtJQUVBb2YsWUFBWTtRQUNWLE9BQU87WUFBQyxJQUFJemlCLE1BQU0sSUFBSSxDQUFDbkIsWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUMsTUFBTSxJQUFJLENBQUN1QixZQUFZLENBQUMsTUFBTXZCLFNBQVMsQ0FBQztZQUFPLElBQUkwQyxNQUFNLElBQUksQ0FBQ25CLFlBQVksQ0FBQyxNQUFNdkIsU0FBUyxDQUFDLE1BQU0sSUFBSSxDQUFDdUIsWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7U0FBTTtJQUMvTDtJQUVBbUQsS0FBS2hDLEdBQUcsRUFBRTtRQUNSLElBQUksQ0FBQyxFQUNId0IsR0FBR3lpQixFQUFFLEVBQ0x4aUIsR0FBR3lpQixFQUFFLEVBQ04sRUFBRSxFQUNEMWlCLEdBQUcyUyxFQUFFLEVBQ0wxUyxHQUFHNlMsRUFBRSxFQUNOLENBQUMsR0FBRyxJQUFJLENBQUMwUCxTQUFTO1FBRW5CLElBQUloa0IsS0FBSztZQUNQQSxJQUFJdUksU0FBUztZQUNidkksSUFBSXdJLE1BQU0sQ0FBQ3liLElBQUlDO1lBQ2Zsa0IsSUFBSXlJLE1BQU0sQ0FBQzBMLElBQUlHO1FBQ2pCO1FBRUEsT0FBTyxJQUFJSixZQUFZK1AsSUFBSUMsSUFBSS9QLElBQUlHO0lBQ3JDO0lBRUFzSCxhQUFhO1FBQ1gsSUFBSSxDQUFDOUcsSUFBSUMsR0FBRyxHQUFHLElBQUksQ0FBQ2lQLFNBQVM7UUFDN0IsSUFBSXhXLElBQUlzSCxHQUFHM1MsT0FBTyxDQUFDNFM7UUFDbkIsT0FBTztZQUFDO2dCQUFDRDtnQkFBSXRIO2FBQUU7WUFBRTtnQkFBQ3VIO2dCQUFJdkg7YUFBRTtTQUFDO0lBQzNCO0FBRUY7QUFFQSxNQUFNMlcsd0JBQXdCMUo7SUFDNUIxZCxZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO1FBQ3RCLElBQUksQ0FBQ3RLLElBQUksR0FBRztRQUNaLElBQUksQ0FBQzNDLE1BQU0sR0FBRyxFQUFFO1FBQ2hCLElBQUksQ0FBQ0EsTUFBTSxHQUFHVixNQUFNUSxTQUFTLENBQUMsSUFBSSxDQUFDM0IsWUFBWSxDQUFDLFVBQVU5QyxTQUFTO0lBQ3JFO0lBRUEwRSxLQUFLaEMsR0FBRyxFQUFFO1FBQ1IsSUFBSSxFQUNGaUMsTUFBTSxFQUNQLEdBQUcsSUFBSTtRQUNSLElBQUksQ0FBQyxFQUNIVCxHQUFHeWlCLEVBQUUsRUFDTHhpQixHQUFHeWlCLEVBQUUsRUFDTixDQUFDLEdBQUdqaUI7UUFDTCxJQUFJK0IsY0FBYyxJQUFJa1EsWUFBWStQLElBQUlDO1FBRXRDLElBQUlsa0IsS0FBSztZQUNQQSxJQUFJdUksU0FBUztZQUNidkksSUFBSXdJLE1BQU0sQ0FBQ3liLElBQUlDO1FBQ2pCO1FBRUFqaUIsT0FBT3dCLE9BQU8sQ0FBQzlLLENBQUFBO1lBQ2IsSUFBSSxFQUNGNkksQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBRzlJO1lBQ0pxTCxZQUFZeVEsUUFBUSxDQUFDalQsR0FBR0M7WUFFeEIsSUFBSXpCLEtBQUs7Z0JBQ1BBLElBQUl5SSxNQUFNLENBQUNqSCxHQUFHQztZQUNoQjtRQUNGO1FBQ0EsT0FBT3VDO0lBQ1Q7SUFFQTRYLGFBQWE7UUFDWCxJQUFJLEVBQ0YzWixNQUFNLEVBQ1AsR0FBRyxJQUFJO1FBQ1IsSUFBSW9lLFlBQVlwZSxPQUFPMUssTUFBTSxHQUFHO1FBQ2hDLElBQUlza0IsVUFBVSxFQUFFO1FBQ2hCNVosT0FBT3dCLE9BQU8sQ0FBQyxDQUFDOUIsT0FBT2pCO1lBQ3JCLElBQUlBLE1BQU0yZixXQUFXO2dCQUNuQjtZQUNGO1lBRUF4RSxRQUFRM2EsSUFBSSxDQUFDO2dCQUFDUztnQkFBT0EsTUFBTVEsT0FBTyxDQUFDRixNQUFNLENBQUN2QixJQUFJLEVBQUU7YUFBRTtRQUNwRDtRQUVBLElBQUltYixRQUFRdGtCLE1BQU0sR0FBRyxHQUFHO1lBQ3RCc2tCLFFBQVEzYSxJQUFJLENBQUM7Z0JBQUNlLE1BQU0sQ0FBQ0EsT0FBTzFLLE1BQU0sR0FBRyxFQUFFO2dCQUFFc2tCLE9BQU8sQ0FBQ0EsUUFBUXRrQixNQUFNLEdBQUcsRUFBRSxDQUFDLEVBQUU7YUFBQztRQUMxRTtRQUVBLE9BQU9za0I7SUFDVDtBQUVGO0FBRUEsTUFBTXVJLHVCQUF1QkQ7SUFDM0JwbkIsYUFBYztRQUNaLEtBQUssSUFBSXpGO1FBQ1QsSUFBSSxDQUFDc04sSUFBSSxHQUFHO0lBQ2Q7SUFFQTVDLEtBQUtoQyxHQUFHLEVBQUU7UUFDUixJQUFJZ0UsY0FBYyxLQUFLLENBQUNoQyxLQUFLaEM7UUFDN0IsSUFBSSxDQUFDLEVBQ0h3QixDQUFDLEVBQ0RDLENBQUMsRUFDRixDQUFDLEdBQUcsSUFBSSxDQUFDUSxNQUFNO1FBRWhCLElBQUlqQyxLQUFLO1lBQ1BBLElBQUl5SSxNQUFNLENBQUNqSCxHQUFHQztZQUNkekIsSUFBSTBJLFNBQVM7UUFDZjtRQUVBLE9BQU8xRTtJQUNUO0FBRUY7QUFFQSxNQUFNcWdCLHVCQUF1QnBWO0lBQzNCbFMsYUFBYztRQUNaLEtBQUssSUFBSXpGO1FBQ1QsSUFBSSxDQUFDc04sSUFBSSxHQUFHO0lBQ2Q7SUFFQTNFLGNBQWNELEdBQUcsRUFBRW9HLENBQUMsRUFBRWtlLGlCQUFpQixFQUFFO1FBQ3ZDLElBQUl4c0IsUUFBUSxJQUFJLENBQUNvUyxRQUFRLENBQUMsU0FBU3JMLFNBQVMsQ0FBQyxLQUFLO1FBQ2xELElBQUk5RyxTQUFTLElBQUksQ0FBQ21TLFFBQVEsQ0FBQyxVQUFVckwsU0FBUyxDQUFDLEtBQUssT0FBTywwQ0FBMEM7UUFFckcsSUFBSTBsQixhQUFhLElBQUlqQyxXQUFXLElBQUksQ0FBQ3RsQixRQUFRLEVBQUU7UUFDL0N1bkIsV0FBV3BWLFVBQVUsQ0FBQzFFLE9BQU8sR0FBRyxJQUFJM04sU0FBUyxJQUFJLENBQUNFLFFBQVEsRUFBRSxXQUFXLElBQUksQ0FBQ29ELFlBQVksQ0FBQyxXQUFXbEMsUUFBUTtRQUM1R3FtQixXQUFXcFYsVUFBVSxDQUFDclgsS0FBSyxHQUFHLElBQUlnRixTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLFNBQVMsR0FBR29OLE1BQU0sQ0FBQ3RTLE9BQU87UUFDcEZ5c0IsV0FBV3BWLFVBQVUsQ0FBQ3BYLE1BQU0sR0FBRyxJQUFJK0UsU0FBUyxJQUFJLENBQUNFLFFBQVEsRUFBRSxVQUFVLEdBQUdvTixNQUFNLENBQUNyUyxRQUFRO1FBQ3ZGd3NCLFdBQVdwVixVQUFVLENBQUM3TSxTQUFTLEdBQUcsSUFBSXhGLFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUUsYUFBYSxJQUFJLENBQUNvRCxZQUFZLENBQUMsb0JBQW9CbEMsUUFBUTtRQUN6SHFtQixXQUFXOVUsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtRQUNuQyxJQUFJK1UsZ0JBQWdCLElBQUksQ0FBQ3huQixRQUFRLENBQUNuRixZQUFZLENBQUNDLE9BQU9DO1FBQ3RELElBQUkwc0IsYUFBYUQsY0FBY0UsVUFBVSxDQUFDO1FBQzFDLElBQUloRCxRQUFRLElBQUksQ0FBQ3RoQixZQUFZLENBQUM7UUFDOUIsSUFBSXVoQixRQUFRLElBQUksQ0FBQ3ZoQixZQUFZLENBQUM7UUFFOUIsSUFBSXNoQixNQUFNbGtCLFFBQVEsTUFBTW1rQixNQUFNbmtCLFFBQVEsSUFBSTtZQUN4Q2luQixXQUFXcmMsU0FBUyxDQUFDc1osTUFBTTdpQixTQUFTLENBQUMsS0FBSyxPQUFPOGlCLE1BQU05aUIsU0FBUyxDQUFDLEtBQUs7UUFDeEU7UUFFQSxJQUFJeWxCLGtCQUFrQjltQixRQUFRLElBQUk7WUFDaEMsSUFBSSxDQUFDNlIsTUFBTSxDQUFDLGVBQWUsR0FBR2lWO1FBQ2hDLE9BQU87WUFDTDlyQixRQUFRQyxjQUFjLENBQUMsSUFBSSxDQUFDNFcsTUFBTSxFQUFFO1FBQ3RDLEVBQUUsdUVBQXVFO1FBR3pFLElBQUssSUFBSTdOLElBQUksQ0FBQyxHQUFHQSxLQUFLLEdBQUdBLElBQUs7WUFDNUIsSUFBSyxJQUFJQyxJQUFJLENBQUMsR0FBR0EsS0FBSyxHQUFHQSxJQUFLO2dCQUM1QmdqQixXQUFXM1QsSUFBSTtnQkFDZnlULFdBQVdwVixVQUFVLENBQUMzTixDQUFDLEdBQUcsSUFBSTFFLFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUUsS0FBS3dFLElBQUlnakIsY0FBYzFzQixLQUFLO2dCQUNsRnlzQixXQUFXcFYsVUFBVSxDQUFDMU4sQ0FBQyxHQUFHLElBQUkzRSxTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLEtBQUt5RSxJQUFJK2lCLGNBQWN6c0IsTUFBTTtnQkFDbkZ3c0IsV0FBV2hiLE1BQU0sQ0FBQ2tiO2dCQUNsQkEsV0FBV3BULE9BQU87WUFDcEI7UUFDRjtRQUVBLElBQUlzVCxVQUFVM2tCLElBQUlDLGFBQWEsQ0FBQ3VrQixlQUFlO1FBQy9DLE9BQU9HO0lBQ1Q7QUFFRjtBQUVBLE1BQU1DLHNCQUFzQjNWO0lBQzFCbFMsYUFBYztRQUNaLEtBQUssSUFBSXpGO1FBQ1QsSUFBSSxDQUFDc04sSUFBSSxHQUFHO0lBQ2Q7SUFFQTJFLE9BQU92SixHQUFHLEVBQUUyQixLQUFLLEVBQUU4SyxLQUFLLEVBQUU7UUFDeEIsSUFBSSxDQUFDOUssT0FBTztZQUNWO1FBQ0Y7UUFFQSxJQUFJLEVBQ0ZILENBQUMsRUFDREMsQ0FBQyxFQUNGLEdBQUdFO1FBQ0osSUFBSWtqQixTQUFTLElBQUksQ0FBQ3prQixZQUFZLENBQUMsVUFBVTlDLFNBQVMsQ0FBQztRQUNuRCxJQUFJd25CLGNBQWMsSUFBSSxDQUFDMWtCLFlBQVksQ0FBQyxlQUFlOUMsU0FBUyxDQUFDO1FBQzdEMEMsSUFBSW9JLFNBQVMsQ0FBQzVHLEdBQUdDO1FBRWpCLElBQUlvakIsV0FBVyxRQUFRO1lBQ3JCN2tCLElBQUl1TSxNQUFNLENBQUNFO1FBQ2I7UUFFQSxJQUFJcVksZ0JBQWdCLGVBQWU7WUFDakM5a0IsSUFBSThCLEtBQUssQ0FBQzlCLElBQUltWixTQUFTLEVBQUVuWixJQUFJbVosU0FBUztRQUN4QztRQUVBblosSUFBSThRLElBQUksSUFBSSwwQ0FBMEM7UUFFdEQsSUFBSWlVLFlBQVksSUFBSXpDLFdBQVcsSUFBSSxDQUFDdGxCLFFBQVEsRUFBRTtRQUM5QytuQixVQUFVbmdCLElBQUksR0FBRyxJQUFJLENBQUNBLElBQUk7UUFDMUJtZ0IsVUFBVTVWLFVBQVUsQ0FBQzFFLE9BQU8sR0FBRyxJQUFJM04sU0FBUyxJQUFJLENBQUNFLFFBQVEsRUFBRSxXQUFXLElBQUksQ0FBQ29ELFlBQVksQ0FBQyxXQUFXbEMsUUFBUTtRQUMzRzZtQixVQUFVNVYsVUFBVSxDQUFDbEksSUFBSSxHQUFHLElBQUluSyxTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLFFBQVEsSUFBSSxDQUFDb0QsWUFBWSxDQUFDLFFBQVFsQyxRQUFRO1FBQ2xHNm1CLFVBQVU1VixVQUFVLENBQUNqSSxJQUFJLEdBQUcsSUFBSXBLLFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUUsUUFBUSxJQUFJLENBQUNvRCxZQUFZLENBQUMsUUFBUWxDLFFBQVE7UUFDbEc2bUIsVUFBVTVWLFVBQVUsQ0FBQ3JYLEtBQUssR0FBRyxJQUFJZ0YsU0FBUyxJQUFJLENBQUNFLFFBQVEsRUFBRSxTQUFTLElBQUksQ0FBQ29ELFlBQVksQ0FBQyxlQUFlbEMsUUFBUTtRQUMzRzZtQixVQUFVNVYsVUFBVSxDQUFDcFgsTUFBTSxHQUFHLElBQUkrRSxTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLFVBQVUsSUFBSSxDQUFDb0QsWUFBWSxDQUFDLGdCQUFnQmxDLFFBQVE7UUFDOUc2bUIsVUFBVTVWLFVBQVUsQ0FBQzZWLFFBQVEsR0FBRyxJQUFJbG9CLFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUUsWUFBWSxJQUFJLENBQUNvRCxZQUFZLENBQUMsWUFBWWxDLFFBQVE7UUFDOUc2bUIsVUFBVTVWLFVBQVUsQ0FBQzRNLElBQUksR0FBRyxJQUFJamYsU0FBUyxJQUFJLENBQUNFLFFBQVEsRUFBRSxRQUFRLElBQUksQ0FBQ29ELFlBQVksQ0FBQyxRQUFROUIsUUFBUSxDQUFDO1FBQ25HeW1CLFVBQVU1VixVQUFVLENBQUM4TSxNQUFNLEdBQUcsSUFBSW5mLFNBQVMsSUFBSSxDQUFDRSxRQUFRLEVBQUUsVUFBVSxJQUFJLENBQUNvRCxZQUFZLENBQUMsVUFBVWxDLFFBQVEsQ0FBQztRQUN6RzZtQixVQUFVdFYsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtRQUNsQ3NWLFVBQVV4YixNQUFNLENBQUN2SjtRQUNqQkEsSUFBSXFSLE9BQU87UUFFWCxJQUFJeVQsZ0JBQWdCLGVBQWU7WUFDakM5a0IsSUFBSThCLEtBQUssQ0FBQyxJQUFJOUIsSUFBSW1aLFNBQVMsRUFBRSxJQUFJblosSUFBSW1aLFNBQVM7UUFDaEQ7UUFFQSxJQUFJMEwsV0FBVyxRQUFRO1lBQ3JCN2tCLElBQUl1TSxNQUFNLENBQUMsQ0FBQ0U7UUFDZDtRQUVBek0sSUFBSW9JLFNBQVMsQ0FBQyxDQUFDNUcsR0FBRyxDQUFDQztJQUNyQjtBQUVGO0FBRUEsTUFBTXdqQixvQkFBb0JoVztJQUN4QmxTLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUEyRSxTQUFTLENBQ1Q7QUFFRjtBQUVBLE1BQU0yYixpQkFBaUIvTTtJQUNyQnBiLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUErVyxlQUFlM2IsR0FBRyxFQUFFO1FBQ2xCLElBQUlnRSxjQUFjLElBQUlrUTtRQUN0QixJQUFJLENBQUN6RSxRQUFRLENBQUNoTSxPQUFPLENBQUM4TixDQUFBQTtZQUNwQnZOLFlBQVk0USxjQUFjLENBQUNyRCxNQUFNb0ssY0FBYyxDQUFDM2I7UUFDbEQ7UUFDQSxPQUFPZ0U7SUFDVDtBQUVGO0FBRUEsTUFBTW1oQix3QkFBd0JsVztJQUM1QmxTLFlBQVlDLFNBQVEsRUFBRXRFLElBQUksRUFBRXdXLGdCQUFnQixDQUFFO1FBQzVDLEtBQUssQ0FBQ2xTLFdBQVV0RSxNQUFNd1c7UUFDdEIsSUFBSSxDQUFDa1csbUJBQW1CLEdBQUc7WUFBQztTQUFnQjtRQUM1QyxJQUFJLENBQUNDLEtBQUssR0FBRyxFQUFFO1FBQ2YsSUFBSSxFQUNGQSxLQUFLLEVBQ0w1VixRQUFRLEVBQ1QsR0FBRyxJQUFJO1FBQ1JBLFNBQVNoTSxPQUFPLENBQUM4TixDQUFBQTtZQUNmLElBQUlBLE1BQU0zTSxJQUFJLEtBQUssUUFBUTtnQkFDekJ5Z0IsTUFBTW5rQixJQUFJLENBQUNxUTtZQUNiO1FBQ0Y7SUFDRjtJQUVBK1QsbUJBQW1CO1FBQ2pCLE9BQU8sSUFBSSxDQUFDbGxCLFlBQVksQ0FBQyxpQkFBaUI5QyxTQUFTLENBQUM7SUFDdEQ7SUFFQXlDLGVBQWVDLEdBQUcsRUFBRUgsT0FBTyxFQUFFeWtCLGlCQUFpQixFQUFFO1FBQzlDLDZFQUE2RTtRQUM3RSxJQUFJaUIsaUJBQWlCLElBQUk7UUFFekIsSUFBSSxJQUFJLENBQUNybEIsZ0JBQWdCLEdBQUcxQyxRQUFRLElBQUk7WUFDdEMrbkIsaUJBQWlCLElBQUksQ0FBQ3JsQixnQkFBZ0IsR0FBR1IsYUFBYTtZQUN0RCxJQUFJLENBQUM4bEIsb0JBQW9CLENBQUNEO1FBQzVCO1FBRUEsSUFBSSxFQUNGRixLQUFLLEVBQ04sR0FBR0U7UUFDSixJQUFJRSxXQUFXLElBQUksQ0FBQ0MsV0FBVyxDQUFDMWxCLEtBQUtIO1FBRXJDLElBQUksQ0FBQzRsQixVQUFVO1lBQ2IsT0FBTyxJQUFJLENBQUNFLGdCQUFnQixDQUFDckIsbUJBQW1CZSxLQUFLLENBQUNBLE1BQU05dEIsTUFBTSxHQUFHLEVBQUUsQ0FBQzhDLEtBQUs7UUFDL0U7UUFFQWdyQixNQUFNNWhCLE9BQU8sQ0FBQ0wsQ0FBQUE7WUFDWnFpQixTQUFTRyxZQUFZLENBQUN4aUIsS0FBS3lXLE1BQU0sRUFBRSxJQUFJLENBQUM4TCxnQkFBZ0IsQ0FBQ3JCLG1CQUFtQmxoQixLQUFLL0ksS0FBSztRQUN4RjtRQUVBLElBQUksSUFBSSxDQUFDK0YsWUFBWSxDQUFDLHFCQUFxQjVDLFFBQVEsSUFBSTtZQUNyRCxvREFBb0Q7WUFDcEQsSUFBSSxFQUNGUixVQUFBQSxTQUFRLEVBQ1QsR0FBRyxJQUFJO1lBQ1IsSUFBSSxFQUNGa0ksa0JBQWtCLEVBQ2xCaEcsUUFBUSxFQUNULEdBQUdsQyxVQUFTbUMsTUFBTTtZQUNuQixJQUFJLENBQUMwbUIsU0FBUyxHQUFHM21CLFNBQVM2QixTQUFTO1lBQ25DLElBQUkra0IsT0FBTyxJQUFJdkMsWUFBWXZtQixXQUFVO1lBQ3JDOG9CLEtBQUszVyxVQUFVLENBQUMzTixDQUFDLEdBQUcsSUFBSTFFLFNBQVNFLFdBQVUsS0FBSyxDQUFDa0kscUJBQXFCO1lBQ3RFNGdCLEtBQUszVyxVQUFVLENBQUMxTixDQUFDLEdBQUcsSUFBSTNFLFNBQVNFLFdBQVUsS0FBSyxDQUFDa0kscUJBQXFCO1lBQ3RFNGdCLEtBQUszVyxVQUFVLENBQUNyWCxLQUFLLEdBQUcsSUFBSWdGLFNBQVNFLFdBQVUsU0FBU2tJO1lBQ3hENGdCLEtBQUszVyxVQUFVLENBQUNwWCxNQUFNLEdBQUcsSUFBSStFLFNBQVNFLFdBQVUsVUFBVWtJO1lBQzFELElBQUk2Z0IsUUFBUSxJQUFJYixTQUFTbG9CLFdBQVU7WUFDbkMrb0IsTUFBTTVXLFVBQVUsQ0FBQzdNLFNBQVMsR0FBRyxJQUFJeEYsU0FBU0UsV0FBVSxhQUFhLElBQUksQ0FBQ29ELFlBQVksQ0FBQyxxQkFBcUJsQyxRQUFRO1lBQ2hINm5CLE1BQU10VyxRQUFRLEdBQUc7Z0JBQUNxVzthQUFLO1lBQ3ZCLElBQUl2QixhQUFhLElBQUlqQyxXQUFXdGxCLFdBQVU7WUFDMUN1bkIsV0FBV3BWLFVBQVUsQ0FBQzNOLENBQUMsR0FBRyxJQUFJMUUsU0FBU0UsV0FBVSxLQUFLO1lBQ3REdW5CLFdBQVdwVixVQUFVLENBQUMxTixDQUFDLEdBQUcsSUFBSTNFLFNBQVNFLFdBQVUsS0FBSztZQUN0RHVuQixXQUFXcFYsVUFBVSxDQUFDclgsS0FBSyxHQUFHLElBQUlnRixTQUFTRSxXQUFVLFNBQVM2b0IsU0FBUy90QixLQUFLO1lBQzVFeXNCLFdBQVdwVixVQUFVLENBQUNwWCxNQUFNLEdBQUcsSUFBSStFLFNBQVNFLFdBQVUsVUFBVTZvQixTQUFTOXRCLE1BQU07WUFDL0V3c0IsV0FBVzlVLFFBQVEsR0FBRztnQkFBQ3NXO2FBQU07WUFDN0IsSUFBSXZCLGdCQUFnQnhuQixVQUFTbkYsWUFBWSxDQUFDZ3VCLFNBQVMvdEIsS0FBSyxFQUFFK3RCLFNBQVM5dEIsTUFBTTtZQUN6RSxJQUFJMHNCLGFBQWFELGNBQWNFLFVBQVUsQ0FBQztZQUMxQ0QsV0FBVzdMLFNBQVMsR0FBRzZNO1lBQ3ZCbEIsV0FBV2hiLE1BQU0sQ0FBQ2tiO1lBQ2xCLE9BQU9BLFdBQVd4a0IsYUFBYSxDQUFDdWtCLGVBQWU7UUFDakQ7UUFFQSxPQUFPaUI7SUFDVDtJQUVBRCxxQkFBcUJELGNBQWMsRUFBRTtRQUNuQyxJQUFJLENBQUNILG1CQUFtQixDQUFDM2hCLE9BQU8sQ0FBQ3VpQixDQUFBQTtZQUMvQixJQUFJLENBQUMsSUFBSSxDQUFDNWxCLFlBQVksQ0FBQzRsQixvQkFBb0J4b0IsUUFBUSxNQUFNK25CLGVBQWVubEIsWUFBWSxDQUFDNGxCLG9CQUFvQnhvQixRQUFRLElBQUk7Z0JBQ25ILElBQUksQ0FBQzRDLFlBQVksQ0FBQzRsQixvQkFBb0IsTUFBTS9uQixRQUFRLENBQUNzbkIsZUFBZW5sQixZQUFZLENBQUM0bEIsb0JBQW9COW5CLFFBQVE7WUFDL0c7UUFDRjtJQUNGO0lBRUF5bkIsaUJBQWlCckIsaUJBQWlCLEVBQUVqcUIsS0FBSyxFQUFFO1FBQ3pDLElBQUlpcUIsa0JBQWtCOW1CLFFBQVEsSUFBSTtZQUNoQyxJQUFJeW9CLFlBQVksSUFBSW5wQixTQUFTLElBQUksQ0FBQ0UsUUFBUSxFQUFFLFNBQVMzQztZQUNyRCxPQUFPNHJCLFVBQVUxbEIsVUFBVSxDQUFDK2pCLG1CQUFtQmhtQixRQUFRO1FBQ3pEO1FBRUEsT0FBT2pFO0lBQ1Q7QUFFRjtBQUVBLE1BQU02ckIsOEJBQThCZjtJQUNsQ3BvQixZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO1FBQ3RCLElBQUksQ0FBQ3RLLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3dnQixtQkFBbUIsQ0FBQ2xrQixJQUFJLENBQUMsTUFBTSxNQUFNLE1BQU07SUFDbEQ7SUFFQXdrQixZQUFZMWxCLEdBQUcsRUFBRUgsT0FBTyxFQUFFO1FBQ3hCLElBQUlzbUIscUJBQXFCLElBQUksQ0FBQ2IsZ0JBQWdCLE9BQU87UUFDckQsSUFBSXRoQixjQUFjbWlCLHFCQUFxQnRtQixRQUFROGIsY0FBYyxDQUFDM2IsT0FBTztRQUVyRSxJQUFJbW1CLHNCQUFzQixDQUFDbmlCLGFBQWE7WUFDdEMsT0FBTztRQUNUO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQzVELFlBQVksQ0FBQyxNQUFNNUMsUUFBUSxNQUFNLENBQUMsSUFBSSxDQUFDNEMsWUFBWSxDQUFDLE1BQU01QyxRQUFRLE1BQU0sQ0FBQyxJQUFJLENBQUM0QyxZQUFZLENBQUMsTUFBTTVDLFFBQVEsTUFBTSxDQUFDLElBQUksQ0FBQzRDLFlBQVksQ0FBQyxNQUFNNUMsUUFBUSxJQUFJO1lBQzVKLElBQUksQ0FBQzRDLFlBQVksQ0FBQyxNQUFNLE1BQU1uQyxRQUFRLENBQUM7WUFDdkMsSUFBSSxDQUFDbUMsWUFBWSxDQUFDLE1BQU0sTUFBTW5DLFFBQVEsQ0FBQztZQUN2QyxJQUFJLENBQUNtQyxZQUFZLENBQUMsTUFBTSxNQUFNbkMsUUFBUSxDQUFDO1lBQ3ZDLElBQUksQ0FBQ21DLFlBQVksQ0FBQyxNQUFNLE1BQU1uQyxRQUFRLENBQUM7UUFDekM7UUFFQSxJQUFJa1csS0FBS2dTLHFCQUFxQm5pQixZQUFZeEMsQ0FBQyxHQUFHd0MsWUFBWWxNLEtBQUssR0FBRyxJQUFJLENBQUNzSSxZQUFZLENBQUMsTUFBTWhDLFNBQVMsS0FBSyxJQUFJLENBQUNnQyxZQUFZLENBQUMsTUFBTXZCLFNBQVMsQ0FBQztRQUMxSSxJQUFJeVYsS0FBSzZSLHFCQUFxQm5pQixZQUFZdkMsQ0FBQyxHQUFHdUMsWUFBWWpNLE1BQU0sR0FBRyxJQUFJLENBQUNxSSxZQUFZLENBQUMsTUFBTWhDLFNBQVMsS0FBSyxJQUFJLENBQUNnQyxZQUFZLENBQUMsTUFBTXZCLFNBQVMsQ0FBQztRQUMzSSxJQUFJMFYsS0FBSzRSLHFCQUFxQm5pQixZQUFZeEMsQ0FBQyxHQUFHd0MsWUFBWWxNLEtBQUssR0FBRyxJQUFJLENBQUNzSSxZQUFZLENBQUMsTUFBTWhDLFNBQVMsS0FBSyxJQUFJLENBQUNnQyxZQUFZLENBQUMsTUFBTXZCLFNBQVMsQ0FBQztRQUMxSSxJQUFJMlYsS0FBSzJSLHFCQUFxQm5pQixZQUFZdkMsQ0FBQyxHQUFHdUMsWUFBWWpNLE1BQU0sR0FBRyxJQUFJLENBQUNxSSxZQUFZLENBQUMsTUFBTWhDLFNBQVMsS0FBSyxJQUFJLENBQUNnQyxZQUFZLENBQUMsTUFBTXZCLFNBQVMsQ0FBQztRQUUzSSxJQUFJc1YsT0FBT0ksTUFBTUQsT0FBT0UsSUFBSTtZQUMxQixPQUFPO1FBQ1Q7UUFFQSxPQUFPeFUsSUFBSW9tQixvQkFBb0IsQ0FBQ2pTLElBQUlHLElBQUlDLElBQUlDO0lBQzlDO0FBRUY7QUFFQSxNQUFNNlIsOEJBQThCbEI7SUFDbENwb0IsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUN3Z0IsbUJBQW1CLENBQUNsa0IsSUFBSSxDQUFDLE1BQU0sTUFBTSxLQUFLLE1BQU0sTUFBTTtJQUM3RDtJQUVBd2tCLFlBQVkxbEIsR0FBRyxFQUFFSCxPQUFPLEVBQUU7UUFDeEIsSUFBSXNtQixxQkFBcUIsSUFBSSxDQUFDYixnQkFBZ0IsT0FBTztRQUNyRCxJQUFJdGhCLGNBQWNuRSxRQUFROGIsY0FBYyxDQUFDM2I7UUFFekMsSUFBSW1tQixzQkFBc0IsQ0FBQ25pQixhQUFhO1lBQ3RDLE9BQU87UUFDVDtRQUVBLElBQUksQ0FBQyxJQUFJLENBQUM1RCxZQUFZLENBQUMsTUFBTTVDLFFBQVEsSUFBSTtZQUN2QyxJQUFJLENBQUM0QyxZQUFZLENBQUMsTUFBTSxNQUFNbkMsUUFBUSxDQUFDO1FBQ3pDO1FBRUEsSUFBSSxDQUFDLElBQUksQ0FBQ21DLFlBQVksQ0FBQyxNQUFNNUMsUUFBUSxJQUFJO1lBQ3ZDLElBQUksQ0FBQzRDLFlBQVksQ0FBQyxNQUFNLE1BQU1uQyxRQUFRLENBQUM7UUFDekM7UUFFQSxJQUFJLENBQUMsSUFBSSxDQUFDbUMsWUFBWSxDQUFDLEtBQUs1QyxRQUFRLElBQUk7WUFDdEMsSUFBSSxDQUFDNEMsWUFBWSxDQUFDLEtBQUssTUFBTW5DLFFBQVEsQ0FBQztRQUN4QztRQUVBLElBQUkyTyxLQUFLdVoscUJBQXFCbmlCLFlBQVl4QyxDQUFDLEdBQUd3QyxZQUFZbE0sS0FBSyxHQUFHLElBQUksQ0FBQ3NJLFlBQVksQ0FBQyxNQUFNaEMsU0FBUyxLQUFLLElBQUksQ0FBQ2dDLFlBQVksQ0FBQyxNQUFNdkIsU0FBUyxDQUFDO1FBQzFJLElBQUlnTyxLQUFLc1oscUJBQXFCbmlCLFlBQVl2QyxDQUFDLEdBQUd1QyxZQUFZak0sTUFBTSxHQUFHLElBQUksQ0FBQ3FJLFlBQVksQ0FBQyxNQUFNaEMsU0FBUyxLQUFLLElBQUksQ0FBQ2dDLFlBQVksQ0FBQyxNQUFNdkIsU0FBUyxDQUFDO1FBQzNJLElBQUl5bkIsS0FBSzFaO1FBQ1QsSUFBSTJaLEtBQUsxWjtRQUVULElBQUksSUFBSSxDQUFDek0sWUFBWSxDQUFDLE1BQU01QyxRQUFRLElBQUk7WUFDdEM4b0IsS0FBS0gscUJBQXFCbmlCLFlBQVl4QyxDQUFDLEdBQUd3QyxZQUFZbE0sS0FBSyxHQUFHLElBQUksQ0FBQ3NJLFlBQVksQ0FBQyxNQUFNaEMsU0FBUyxLQUFLLElBQUksQ0FBQ2dDLFlBQVksQ0FBQyxNQUFNdkIsU0FBUyxDQUFDO1FBQ3hJO1FBRUEsSUFBSSxJQUFJLENBQUN1QixZQUFZLENBQUMsTUFBTTVDLFFBQVEsSUFBSTtZQUN0QytvQixLQUFLSixxQkFBcUJuaUIsWUFBWXZDLENBQUMsR0FBR3VDLFlBQVlqTSxNQUFNLEdBQUcsSUFBSSxDQUFDcUksWUFBWSxDQUFDLE1BQU1oQyxTQUFTLEtBQUssSUFBSSxDQUFDZ0MsWUFBWSxDQUFDLE1BQU12QixTQUFTLENBQUM7UUFDekk7UUFFQSxJQUFJb2YsSUFBSWtJLHFCQUFxQixDQUFDbmlCLFlBQVlsTSxLQUFLLEdBQUdrTSxZQUFZak0sTUFBTSxJQUFJLE1BQU0sSUFBSSxDQUFDcUksWUFBWSxDQUFDLEtBQUtoQyxTQUFTLEtBQUssSUFBSSxDQUFDZ0MsWUFBWSxDQUFDLEtBQUt2QixTQUFTO1FBQ25KLElBQUkybkIsS0FBSyxJQUFJLENBQUNwbUIsWUFBWSxDQUFDLE1BQU12QixTQUFTO1FBQzFDLE9BQU9tQixJQUFJeW1CLG9CQUFvQixDQUFDSCxJQUFJQyxJQUFJQyxJQUFJNVosSUFBSUMsSUFBSW9SO0lBQ3REO0FBRUY7QUFFQSxNQUFNeUksb0JBQW9Celg7SUFDeEJsUyxZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO1FBQ3RCLElBQUksQ0FBQ3RLLElBQUksR0FBRztRQUNaLElBQUlpVixTQUFTamYsS0FBSzBFLEdBQUcsQ0FBQyxHQUFHMUUsS0FBS3dFLEdBQUcsQ0FBQyxHQUFHLElBQUksQ0FBQ2dCLFlBQVksQ0FBQyxVQUFVaEMsU0FBUztRQUMxRSxJQUFJdW9CLGNBQWMsSUFBSSxDQUFDemMsUUFBUSxDQUFDO1FBQ2hDLElBQUkwYyxZQUFZLElBQUksQ0FBQzFjLFFBQVEsQ0FBQyxjQUFjO1FBRTVDLElBQUkwYyxVQUFVdHBCLFNBQVMsT0FBTyxJQUFJO1lBQ2hDc3BCLFVBQVUzb0IsUUFBUSxDQUFDO1FBQ3JCO1FBRUEsSUFBSTBvQixZQUFZbnBCLFFBQVEsSUFBSTtZQUMxQm9wQixZQUFZQSxVQUFVcm1CLFVBQVUsQ0FBQ29tQjtRQUNuQztRQUVBLElBQUksQ0FBQzlNLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUN4ZixLQUFLLEdBQUd1c0IsVUFBVXRvQixRQUFRO0lBQ2pDO0FBRUY7QUFFQSxNQUFNdW9CLHVCQUF1QjVYO0lBQzNCbFMsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNraUIsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsWUFBWSxHQUFHO1FBQ3BCLElBQUksQ0FBQ0MsT0FBTyxHQUFHO1FBQ2YsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZGxxQixVQUFTbUMsTUFBTSxDQUFDbUcsVUFBVSxDQUFDcEUsSUFBSSxDQUFDLElBQUk7UUFDcEMsSUFBSSxDQUFDaW1CLEtBQUssR0FBRyxJQUFJLENBQUMvbUIsWUFBWSxDQUFDLFNBQVNiLGVBQWU7UUFDdkQsSUFBSSxDQUFDNm5CLFdBQVcsR0FBRyxJQUFJLENBQUNELEtBQUssR0FBRyxJQUFJLENBQUMvbUIsWUFBWSxDQUFDLE9BQU9iLGVBQWU7UUFDeEUsSUFBSSxDQUFDcVEsSUFBSSxHQUFHLElBQUksQ0FBQ3hQLFlBQVksQ0FBQztRQUM5QixJQUFJLENBQUNpbkIsRUFBRSxHQUFHLElBQUksQ0FBQ2puQixZQUFZLENBQUM7UUFDNUIsSUFBSSxDQUFDa25CLE1BQU0sR0FBRyxJQUFJeHFCLFNBQVNFLFdBQVUsVUFBVTtRQUMvQyxJQUFJdXFCLGFBQWEsSUFBSSxDQUFDbm5CLFlBQVksQ0FBQztRQUVuQyxJQUFJbW5CLFdBQVcvcEIsUUFBUSxJQUFJO1lBQ3pCLElBQUksQ0FBQzhwQixNQUFNLENBQUNycEIsUUFBUSxDQUFDc3BCLFdBQVdqcUIsU0FBUyxHQUFHRixLQUFLLENBQUM7UUFDcEQ7SUFDRjtJQUVBb3FCLGNBQWM7UUFDWixJQUFJQyxnQkFBZ0IsSUFBSSxDQUFDcm5CLFlBQVksQ0FBQyxpQkFBaUI5QyxTQUFTO1FBQ2hFLElBQUlvcUIsZ0JBQWdCLElBQUksQ0FBQ3RuQixZQUFZLENBQUMsaUJBQWlCOUMsU0FBUztRQUVoRSxJQUFJbXFCLGtCQUFrQixPQUFPO1lBQzNCLE9BQU8sSUFBSSxDQUFDOWpCLE1BQU0sQ0FBQ3VHLFFBQVEsQ0FBQ3dkLGVBQWU7UUFDN0M7UUFFQSxPQUFPLElBQUksQ0FBQy9qQixNQUFNLENBQUN2RCxZQUFZLENBQUNzbkIsZUFBZTtJQUNqRDtJQUVBQyxZQUFZO1FBQ1YsSUFBSSxFQUNGWCxZQUFZLEVBQ2IsR0FBRyxJQUFJO1FBQ1IsSUFBSSxFQUNGWSxRQUFRLEVBQ1JoWSxJQUFJLEVBQ0p5WCxFQUFFLEVBQ0gsR0FBRyxJQUFJLENBQUNRLFdBQVcsSUFBSSx1QkFBdUI7UUFFL0MsSUFBSUMsV0FBV2xZLEtBQUt4UixTQUFTLEtBQUssQ0FBQ2lwQixHQUFHanBCLFNBQVMsS0FBS3dSLEtBQUt4UixTQUFTLEVBQUMsSUFBS3dwQjtRQUV4RSxJQUFJWixpQkFBaUIsS0FBSztZQUN4QmMsWUFBWSxPQUFPLHNEQUFzRDtRQUMzRTtRQUVBLE9BQU8sR0FBRzFkLE1BQU0sQ0FBQzBkLFVBQVUxZCxNQUFNLENBQUM0YztJQUNwQztJQUVBaGQsT0FBT3JPLEtBQUssRUFBRTtRQUNaLElBQUksRUFDRmdJLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJb2tCLE9BQU8sSUFBSSxDQUFDUCxXQUFXLElBQUksb0JBQW9CO1FBRW5ELElBQUksQ0FBQyxJQUFJLENBQUNULFlBQVksRUFBRTtZQUN0QixJQUFJLENBQUNBLFlBQVksR0FBR2dCLEtBQUt6cUIsU0FBUztZQUNsQyxJQUFJLENBQUMwcEIsWUFBWSxHQUFHZSxLQUFLbnBCLFFBQVE7UUFDbkMsRUFBRSw2QkFBNkI7UUFHL0IsSUFBSSxJQUFJLENBQUNrb0IsUUFBUSxHQUFHLElBQUksQ0FBQ00sV0FBVyxFQUFFO1lBQ3BDLElBQUlyTCxPQUFPLElBQUksQ0FBQzNiLFlBQVksQ0FBQyxRQUFROUMsU0FBUyxDQUFDLFdBQVcsNkNBQTZDO1lBRXZHLElBQUksSUFBSSxDQUFDOEMsWUFBWSxDQUFDLGVBQWU5QyxTQUFTLE9BQU8sZ0JBQWdCLElBQUksQ0FBQzhDLFlBQVksQ0FBQyxhQUFhOUMsU0FBUyxPQUFPLGNBQWM7Z0JBQ2hJLElBQUksQ0FBQ3dwQixRQUFRLEdBQUc7WUFDbEIsT0FBTyxJQUFJL0ssU0FBUyxZQUFZLENBQUMsSUFBSSxDQUFDbUwsTUFBTSxFQUFFO2dCQUM1QyxJQUFJLENBQUNBLE1BQU0sR0FBRztnQkFDZHZqQixPQUFPNEwsZUFBZSxHQUFHO2dCQUN6QjVMLE9BQU82TCxvQkFBb0IsR0FBR3VZLEtBQUt6cUIsU0FBUztZQUM5QyxPQUFPLElBQUl5ZSxTQUFTLFlBQVksQ0FBQyxJQUFJLENBQUNrTCxPQUFPLEVBQUU7Z0JBQzdDLElBQUksQ0FBQ0EsT0FBTyxHQUFHO2dCQUNmYyxLQUFLOXBCLFFBQVEsQ0FBQzBGLE9BQU80TCxlQUFlLEdBQUc1TCxPQUFPNkwsb0JBQW9CLEdBQUcsSUFBSSxDQUFDdVgsWUFBWTtnQkFDdEYsT0FBTztZQUNUO1lBRUEsT0FBTztRQUNUO1FBRUEsSUFBSSxDQUFDRCxRQUFRLElBQUluckIsT0FBTywrQkFBK0I7UUFFdkQsSUFBSXFzQixVQUFVO1FBRWQsSUFBSSxJQUFJLENBQUNiLEtBQUssR0FBRyxJQUFJLENBQUNMLFFBQVEsRUFBRTtZQUM5QixJQUFJZ0IsV0FBVyxJQUFJLENBQUNILFNBQVMsSUFBSSxRQUFRO1lBRXpDLElBQUlNLFdBQVcsSUFBSSxDQUFDN25CLFlBQVksQ0FBQztZQUVqQyxJQUFJNm5CLFNBQVN6cUIsUUFBUSxJQUFJO2dCQUN2QixzQkFBc0I7Z0JBQ3RCLElBQUlvSCxPQUFPcWpCLFNBQVMzcUIsU0FBUztnQkFDN0J3cUIsV0FBVyxHQUFHMWQsTUFBTSxDQUFDeEYsTUFBTSxLQUFLd0YsTUFBTSxDQUFDMGQsVUFBVTtZQUNuRDtZQUVBQyxLQUFLOXBCLFFBQVEsQ0FBQzZwQjtZQUNkRSxVQUFVO1FBQ1o7UUFFQSxPQUFPQTtJQUNUO0lBRUFILGNBQWM7UUFDWixJQUFJLEVBQ0Y3cUIsVUFBQUEsU0FBUSxFQUNSc3FCLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJMXBCLFNBQVM7WUFDWGdxQixVQUFVLENBQUMsSUFBSSxDQUFDZCxRQUFRLEdBQUcsSUFBSSxDQUFDSyxLQUFLLElBQUssS0FBSSxDQUFDQyxXQUFXLEdBQUcsSUFBSSxDQUFDRCxLQUFLO1FBQ3pFO1FBRUEsSUFBSUcsT0FBTzlwQixRQUFRLElBQUk7WUFDckIsSUFBSTBxQixJQUFJdHFCLE9BQU9ncUIsUUFBUSxHQUFJTixDQUFBQSxPQUFPcHBCLFFBQVEsR0FBRzNHLE1BQU0sR0FBRztZQUN0RCxJQUFJNHdCLEtBQUt2dEIsS0FBS3d0QixLQUFLLENBQUNGO1lBQ3BCLElBQUlHLEtBQUt6dEIsS0FBSzB0QixJQUFJLENBQUNKO1lBQ25CdHFCLE9BQU9nUyxJQUFJLEdBQUcsSUFBSTlTLFNBQVNFLFdBQVUsUUFBUXJELFdBQVcydEIsT0FBT3BwQixRQUFRLEVBQUUsQ0FBQ2lxQixHQUFHO1lBQzdFdnFCLE9BQU95cEIsRUFBRSxHQUFHLElBQUl2cUIsU0FBU0UsV0FBVSxNQUFNckQsV0FBVzJ0QixPQUFPcHBCLFFBQVEsRUFBRSxDQUFDbXFCLEdBQUc7WUFDekV6cUIsT0FBT2dxQixRQUFRLEdBQUcsQ0FBQ00sSUFBSUMsRUFBQyxJQUFNRSxDQUFBQSxLQUFLRixFQUFDO1FBQ3RDLE9BQU87WUFDTHZxQixPQUFPZ1MsSUFBSSxHQUFHLElBQUksQ0FBQ0EsSUFBSTtZQUN2QmhTLE9BQU95cEIsRUFBRSxHQUFHLElBQUksQ0FBQ0EsRUFBRTtRQUNyQjtRQUVBLE9BQU96cEI7SUFDVDtBQUVGO0FBRUEsTUFBTTJxQiw0QkFBNEIxQjtJQUNoQzlwQixhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtJQUVBK2lCLFlBQVk7UUFDVixJQUFJLEVBQ0ZDLFFBQVEsRUFDUmhZLElBQUksRUFDSnlYLEVBQUUsRUFDSCxHQUFHLElBQUksQ0FBQ1EsV0FBVztRQUNwQixJQUFJVyxZQUFZLElBQUl4eEIsc0NBQVFBLENBQUM0WSxLQUFLdFIsUUFBUTtRQUMxQyxJQUFJbXFCLFVBQVUsSUFBSXp4QixzQ0FBUUEsQ0FBQ3F3QixHQUFHL29CLFFBQVE7UUFFdEMsSUFBSWtxQixVQUFVN25CLEVBQUUsSUFBSThuQixRQUFROW5CLEVBQUUsRUFBRTtZQUM5Qix1QkFBdUI7WUFDdkIsSUFBSXNkLElBQUl1SyxVQUFVdkssQ0FBQyxHQUFHLENBQUN3SyxRQUFReEssQ0FBQyxHQUFHdUssVUFBVXZLLENBQUMsSUFBSTJKO1lBQ2xELElBQUkvWixJQUFJMmEsVUFBVTNhLENBQUMsR0FBRyxDQUFDNGEsUUFBUTVhLENBQUMsR0FBRzJhLFVBQVUzYSxDQUFDLElBQUkrWjtZQUNsRCxJQUFJbmEsSUFBSSthLFVBQVUvYSxDQUFDLEdBQUcsQ0FBQ2diLFFBQVFoYixDQUFDLEdBQUcrYSxVQUFVL2EsQ0FBQyxJQUFJbWEsVUFBVSxVQUFVO1lBRXRFLE9BQU8sT0FBT3hkLE1BQU0sQ0FBQ3hQLEtBQUt3dEIsS0FBSyxDQUFDbkssSUFBSSxNQUFNN1QsTUFBTSxDQUFDeFAsS0FBS3d0QixLQUFLLENBQUN2YSxJQUFJLE1BQU16RCxNQUFNLENBQUN4UCxLQUFLd3RCLEtBQUssQ0FBQzNhLElBQUk7UUFDOUY7UUFFQSxPQUFPLElBQUksQ0FBQ3JOLFlBQVksQ0FBQyxRQUFROUIsUUFBUTtJQUMzQztBQUVGO0FBRUEsTUFBTW9xQixnQ0FBZ0M3QjtJQUNwQzlwQixhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtJQUVBK2lCLFlBQVk7UUFDVixJQUFJLEVBQ0ZDLFFBQVEsRUFDUmhZLElBQUksRUFDSnlYLEVBQUUsRUFDSCxHQUFHLElBQUksQ0FBQ1EsV0FBVyxJQUFJLHVCQUF1QjtRQUUvQyxJQUFJYyxnQkFBZ0JwdkIsVUFBVXFXLEtBQUt0UyxTQUFTO1FBQzVDLElBQUlzckIsY0FBY3J2QixVQUFVOHRCLEdBQUcvcEIsU0FBUztRQUN4QyxJQUFJd3FCLFdBQVdhLGNBQWNqdkIsR0FBRyxDQUFDLENBQUNrVyxNQUFNbFA7WUFDdEMsSUFBSTJtQixLQUFLdUIsV0FBVyxDQUFDbG9CLEVBQUU7WUFDdkIsT0FBT2tQLE9BQU8sQ0FBQ3lYLEtBQUt6WCxJQUFHLElBQUtnWTtRQUM5QixHQUFHaHNCLElBQUksQ0FBQztRQUNSLE9BQU9rc0I7SUFDVDtBQUVGO0FBRUEsTUFBTWUsb0JBQW9CNVo7SUFDeEJsUyxZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO1FBQ3RCLElBQUksQ0FBQ3RLLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ29iLE1BQU0sR0FBR2puQixPQUFPcVcsTUFBTSxDQUFDO1FBQzVCLElBQUksQ0FBQ21QLFNBQVMsR0FBRyxJQUFJLENBQUNuZSxZQUFZLENBQUMsZUFBZWhDLFNBQVM7UUFDM0QsSUFBSSxFQUNGdUIsV0FBVyxFQUNaLEdBQUczQztRQUNKLElBQUksRUFDRnlTLFFBQVEsRUFDVCxHQUFHLElBQUk7UUFFUixLQUFLLElBQUk4QixTQUFTOUIsU0FBVTtZQUMxQixPQUFROEIsTUFBTTNNLElBQUk7Z0JBQ2hCLEtBQUs7b0JBQ0g7d0JBQ0UsSUFBSSxDQUFDK2IsUUFBUSxHQUFHcFA7d0JBQ2hCLElBQUl1WCxrQkFBa0J2WCxNQUFNckgsUUFBUSxDQUFDO3dCQUVyQyxJQUFJNGUsZ0JBQWdCdHJCLFFBQVEsSUFBSTs0QkFDOUJtQyxXQUFXLENBQUNtcEIsZ0JBQWdCeHJCLFNBQVMsR0FBRyxHQUFHLElBQUk7d0JBQ2pEO3dCQUVBO29CQUNGO2dCQUVGLEtBQUs7b0JBQ0gsSUFBSSxDQUFDNGlCLFlBQVksR0FBRzNPO29CQUNwQjtnQkFFRixLQUFLO29CQUNIO3dCQUNFLElBQUlxTyxRQUFRck87d0JBRVosSUFBSXFPLE1BQU1uQixVQUFVLEVBQUU7NEJBQ3BCLElBQUksQ0FBQ29DLEtBQUssR0FBRzs0QkFDYixJQUFJLENBQUNoQixRQUFRLEdBQUc7NEJBRWhCLElBQUksT0FBTyxJQUFJLENBQUNHLE1BQU0sQ0FBQ0osTUFBTXBCLE9BQU8sQ0FBQyxLQUFLLGFBQWE7Z0NBQ3JELElBQUksQ0FBQ3dCLE1BQU0sQ0FBQ0osTUFBTXBCLE9BQU8sQ0FBQyxHQUFHemxCLE9BQU9xVyxNQUFNLENBQUM7NEJBQzdDOzRCQUVBLElBQUksQ0FBQzRRLE1BQU0sQ0FBQ0osTUFBTXBCLE9BQU8sQ0FBQyxDQUFDb0IsTUFBTW5CLFVBQVUsQ0FBQyxHQUFHbUI7d0JBQ2pELE9BQU87NEJBQ0wsSUFBSSxDQUFDSSxNQUFNLENBQUNKLE1BQU1wQixPQUFPLENBQUMsR0FBR29CO3dCQUMvQjt3QkFFQTtvQkFDRjtZQUNKO1FBQ0Y7SUFDRjtJQUVBclcsU0FBUyxDQUNUO0FBRUY7QUFFQSxNQUFNd2Ysd0JBQXdCOVo7SUFDNUJsUyxZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO1FBQ3RCLElBQUksQ0FBQ3RLLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ29rQixNQUFNLEdBQUcsSUFBSSxDQUFDNW9CLFlBQVksQ0FBQyxVQUFVaEMsU0FBUztRQUNuRCxJQUFJLENBQUM2cUIsT0FBTyxHQUFHLElBQUksQ0FBQzdvQixZQUFZLENBQUMsV0FBV2hDLFNBQVM7UUFDckQsSUFBSSxDQUFDc2lCLFVBQVUsR0FBRyxJQUFJLENBQUN0Z0IsWUFBWSxDQUFDLGdCQUFnQmhDLFNBQVM7SUFDL0Q7QUFFRjtBQUVBLE1BQU04cUIsNEJBQTRCek87SUFDaEMxZCxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7UUFDWixJQUFJLENBQUMyWixTQUFTLEdBQUc7SUFDbkI7QUFFRjtBQUVBLE1BQU00SyxvQkFBb0J6SztJQUN4QjNoQixhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtJQUVBMEwsVUFBVTtRQUNSLElBQUl6USxVQUFVLElBQUksQ0FBQ0ssZ0JBQWdCLEdBQUdSLGFBQWE7UUFFbkQsSUFBSUcsU0FBUztZQUNYLElBQUl1cEIsYUFBYXZwQixRQUFRNFAsUUFBUSxDQUFDLEVBQUU7WUFFcEMsSUFBSTJaLFlBQVk7Z0JBQ2QsT0FBT0EsV0FBVzlZLE9BQU87WUFDM0I7UUFDRjtRQUVBLE9BQU87SUFDVDtBQUVGO0FBRUEsTUFBTStZLGlCQUFpQjNLO0lBQ3JCM2hCLFlBQVlDLFNBQVEsRUFBRXRFLElBQUksRUFBRXdXLGdCQUFnQixDQUFFO1FBQzVDLEtBQUssQ0FBQ2xTLFdBQVV0RSxNQUFNd1c7UUFDdEIsSUFBSSxDQUFDdEssSUFBSSxHQUFHO1FBQ1osSUFBSSxFQUNGcUwsVUFBVSxFQUNYLEdBQUd2WDtRQUNKLElBQUkwd0IsYUFBYW5aLFVBQVUsQ0FBQyxFQUFFO1FBQzlCLElBQUlxWixVQUFVclosV0FBVzFZLE1BQU0sR0FBRyxLQUFLb1ksTUFBTUMsSUFBSSxDQUFDSyxZQUFZOUosS0FBSyxDQUFDek4sQ0FBQUEsT0FBUUEsS0FBS2dYLFFBQVEsS0FBSztRQUM5RixJQUFJLENBQUM0WixPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDcmQsSUFBSSxHQUFHcWQsVUFBVSxJQUFJLENBQUNuSixlQUFlLENBQUNpSixjQUFjO0lBQzNEO0lBRUE5WSxVQUFVO1FBQ1IsT0FBTyxJQUFJLENBQUNyRSxJQUFJO0lBQ2xCO0lBRUFrRixlQUFlblIsR0FBRyxFQUFFO1FBQ2xCLElBQUksSUFBSSxDQUFDc3BCLE9BQU8sRUFBRTtZQUNoQix5QkFBeUI7WUFDekIsS0FBSyxDQUFDblksZUFBZW5SO1lBQ3JCLElBQUksRUFDRmhELFVBQUFBLFNBQVEsRUFDUndFLENBQUMsRUFDREMsQ0FBQyxFQUNGLEdBQUcsSUFBSTtZQUNSLElBQUksRUFDRjRELEtBQUssRUFDTixHQUFHckksVUFBU21DLE1BQU07WUFDbkIsSUFBSXFVLFdBQVcsSUFBSTFXLFNBQVNFLFdBQVUsWUFBWXNXLEtBQUs1UixLQUFLLENBQUMxRSxVQUFTZ0QsR0FBRyxDQUFDMlQsSUFBSSxFQUFFSCxRQUFRLEdBQUcsb0RBQW9EO1lBRS9JLElBQUluTyxNQUFNckMsU0FBUyxJQUFJO2dCQUNyQnFDLE1BQU10QixnQkFBZ0IsQ0FBQyxJQUFJLEVBQUUsSUFBSW1RLFlBQVkxUyxHQUFHQyxJQUFJK1IsU0FBUzNVLFNBQVMsQ0FBQyxNQUFNMkMsSUFBSSxJQUFJLENBQUNpZSxXQUFXLENBQUN6ZixNQUFNeUI7WUFDMUc7UUFDRixPQUFPLElBQUksSUFBSSxDQUFDZ08sUUFBUSxDQUFDbFksTUFBTSxHQUFHLEdBQUc7WUFDbkMsNEJBQTRCO1lBQzVCLElBQUlzVyxJQUFJLElBQUlxWCxTQUFTLElBQUksQ0FBQ2xvQixRQUFRLEVBQUU7WUFDcEM2USxFQUFFNEIsUUFBUSxHQUFHLElBQUksQ0FBQ0EsUUFBUTtZQUMxQjVCLEVBQUVsSyxNQUFNLEdBQUcsSUFBSTtZQUNma0ssRUFBRXRFLE1BQU0sQ0FBQ3ZKO1FBQ1g7SUFDRjtJQUVBNkMsVUFBVTtRQUNSLElBQUksRUFDRm5MLFFBQUFBLE9BQU0sRUFDUCxHQUFHLElBQUksQ0FBQ3NGLFFBQVE7UUFFakIsSUFBSXRGLFNBQVE7WUFDVkEsUUFBTzZ4QixJQUFJLENBQUMsSUFBSSxDQUFDcnBCLGdCQUFnQixHQUFHNUMsU0FBUztRQUMvQztJQUNGO0lBRUF5RixjQUFjO1FBQ1osSUFBSS9DLE1BQU0sSUFBSSxDQUFDaEQsUUFBUSxDQUFDZ0QsR0FBRztRQUMzQkEsSUFBSXBILE1BQU0sQ0FBQzJLLEtBQUssQ0FBQ0MsTUFBTSxHQUFHO0lBQzVCO0FBRUY7QUFFQSxTQUFTZ21CLFVBQVVDLE1BQU0sRUFBRUMsY0FBYztJQUFJLElBQUlDLE9BQU81d0IsT0FBTzR3QixJQUFJLENBQUNGO0lBQVMsSUFBSTF3QixPQUFPNndCLHFCQUFxQixFQUFFO1FBQUUsSUFBSUMsVUFBVTl3QixPQUFPNndCLHFCQUFxQixDQUFDSDtRQUFTLElBQUlDLGdCQUFnQjtZQUFFRyxVQUFVQSxRQUFRNVksTUFBTSxDQUFDLFNBQVU2WSxHQUFHO2dCQUFJLE9BQU8vd0IsT0FBT2d4Qix3QkFBd0IsQ0FBQ04sUUFBUUssS0FBS0UsVUFBVTtZQUFFO1FBQUk7UUFBRUwsS0FBS3pvQixJQUFJLENBQUNpTCxLQUFLLENBQUN3ZCxNQUFNRTtJQUFVO0lBQUUsT0FBT0Y7QUFBTTtBQUUxVixTQUFTTSxnQkFBZ0JDLE1BQU07SUFBSSxJQUFLLElBQUl4cEIsSUFBSSxHQUFHQSxJQUFJcEosVUFBVUMsTUFBTSxFQUFFbUosSUFBSztRQUFFLElBQUl5cEIsU0FBUzd5QixTQUFTLENBQUNvSixFQUFFLElBQUksT0FBT3BKLFNBQVMsQ0FBQ29KLEVBQUUsR0FBRyxDQUFDO1FBQUcsSUFBSUEsSUFBSSxHQUFHO1lBQUU4b0IsVUFBVXp3QixPQUFPb3hCLFNBQVMsTUFBTTFtQixPQUFPLENBQUMsU0FBVWlOLEdBQUc7Z0JBQUk1WixrRUFBZUEsQ0FBQ296QixRQUFReFosS0FBS3laLE1BQU0sQ0FBQ3paLElBQUk7WUFBRztRQUFJLE9BQU8sSUFBSTNYLE9BQU9xeEIseUJBQXlCLEVBQUU7WUFBRXJ4QixPQUFPc3hCLGdCQUFnQixDQUFDSCxRQUFRbnhCLE9BQU9xeEIseUJBQXlCLENBQUNEO1FBQVUsT0FBTztZQUFFWCxVQUFVendCLE9BQU9veEIsU0FBUzFtQixPQUFPLENBQUMsU0FBVWlOLEdBQUc7Z0JBQUkzWCxPQUFPdXhCLGNBQWMsQ0FBQ0osUUFBUXhaLEtBQUszWCxPQUFPZ3hCLHdCQUF3QixDQUFDSSxRQUFRelo7WUFBTztRQUFJO0lBQUU7SUFBRSxPQUFPd1o7QUFBUTtBQUMzaEIsTUFBTUssd0JBQXdCN0w7SUFDNUIzaEIsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUM0bEIsU0FBUyxHQUFHO1FBQ2pCLElBQUksQ0FBQ0MsVUFBVSxHQUFHO1FBQ2xCLElBQUksQ0FBQ0MsVUFBVSxHQUFHLENBQUM7UUFDbkIsSUFBSSxDQUFDQyxTQUFTLEdBQUc7UUFDakIsSUFBSSxDQUFDQyxrQkFBa0IsR0FBRyxFQUFFO1FBQzVCLElBQUksQ0FBQ0MsYUFBYSxHQUFHLElBQUlDLElBQUk7WUFBQztnQkFBQztnQkFBSTthQUFFO1NBQUM7UUFDdEMsSUFBSUMsY0FBYyxJQUFJLENBQUM3cUIsZ0JBQWdCLEdBQUdSLGFBQWE7UUFDdkQsSUFBSSxDQUFDdU0sSUFBSSxHQUFHLElBQUksQ0FBQ2tVLGVBQWU7UUFDaEMsSUFBSSxDQUFDNkssU0FBUyxHQUFHLElBQUksQ0FBQ0MsYUFBYSxDQUFDRjtJQUN0QztJQUVBemEsVUFBVTtRQUNSLE9BQU8sSUFBSSxDQUFDckUsSUFBSTtJQUNsQjtJQUVBakssS0FBS2hDLEdBQUcsRUFBRTtRQUNSLElBQUksRUFDRmdyQixTQUFTLEVBQ1YsR0FBRyxJQUFJO1FBRVIsSUFBSWhyQixLQUFLO1lBQ1BBLElBQUl1SSxTQUFTO1FBQ2Y7UUFFQXlpQixVQUFVdm5CLE9BQU8sQ0FBQzlLLENBQUFBO1lBQ2hCLElBQUksRUFDRmlNLElBQUksRUFDSjNDLE1BQU0sRUFDUCxHQUFHdEo7WUFFSixPQUFRaU07Z0JBQ04sS0FBS3lSLFdBQVd3RSxPQUFPO29CQUNyQixJQUFJN2EsS0FBSzt3QkFDUEEsSUFBSXlJLE1BQU0sQ0FBQ3hHLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFO29CQUNqQztvQkFFQTtnQkFFRixLQUFLb1UsV0FBV3NFLE9BQU87b0JBQ3JCLElBQUkzYSxLQUFLO3dCQUNQQSxJQUFJd0ksTUFBTSxDQUFDdkcsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUU7b0JBQ2pDO29CQUVBO2dCQUVGLEtBQUtvVSxXQUFXaUIsUUFBUTtvQkFDdEIsSUFBSXRYLEtBQUs7d0JBQ1BBLElBQUkrYyxhQUFhLENBQUM5YSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRTtvQkFDcEY7b0JBRUE7Z0JBRUYsS0FBS29VLFdBQVdtQixPQUFPO29CQUNyQixJQUFJeFgsS0FBSzt3QkFDUEEsSUFBSWdkLGdCQUFnQixDQUFDL2EsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUU7b0JBQ2pFO29CQUVBO2dCQUVGLEtBQUtvVSxXQUFXa0YsR0FBRztvQkFDakI7d0JBQ0UsSUFBSSxDQUFDM08sSUFBSUMsSUFBSTZXLElBQUlDLElBQUl1SCxPQUFPQyxRQUFRQyxLQUFLQyxHQUFHLEdBQUdwcEI7d0JBQy9DLElBQUlnYyxJQUFJeUYsS0FBS0MsS0FBS0QsS0FBS0M7d0JBQ3ZCLElBQUloYyxTQUFTK2IsS0FBS0MsS0FBSyxJQUFJRCxLQUFLQzt3QkFDaEMsSUFBSS9iLFNBQVM4YixLQUFLQyxLQUFLQSxLQUFLRCxLQUFLO3dCQUVqQyxJQUFJMWpCLEtBQUs7NEJBQ1BBLElBQUlvSSxTQUFTLENBQUN3RSxJQUFJQzs0QkFDbEI3TSxJQUFJdU0sTUFBTSxDQUFDNmU7NEJBQ1hwckIsSUFBSThCLEtBQUssQ0FBQzZGLFFBQVFDOzRCQUNsQjVILElBQUlvZSxHQUFHLENBQUMsR0FBRyxHQUFHSCxHQUFHaU4sT0FBT0EsUUFBUUMsUUFBUTlNLFFBQVEsSUFBSWdOOzRCQUNwRHJyQixJQUFJOEIsS0FBSyxDQUFDLElBQUk2RixRQUFRLElBQUlDOzRCQUMxQjVILElBQUl1TSxNQUFNLENBQUMsQ0FBQzZlOzRCQUNacHJCLElBQUlvSSxTQUFTLENBQUMsQ0FBQ3dFLElBQUksQ0FBQ0M7d0JBQ3RCO3dCQUVBO29CQUNGO2dCQUVGLEtBQUt3SixXQUFXb0YsVUFBVTtvQkFDeEIsSUFBSXpiLEtBQUs7d0JBQ1BBLElBQUkwSSxTQUFTO29CQUNmO29CQUVBO1lBQ0o7UUFDRjtJQUNGO0lBRUF5SSxlQUFlblIsR0FBRyxFQUFFO1FBQ2xCLElBQUksQ0FBQ3NyQixXQUFXLENBQUN0ckI7UUFDakJBLElBQUk4USxJQUFJO1FBQ1IsSUFBSXlhLGlCQUFpQixJQUFJLENBQUM1bkIsTUFBTSxDQUFDdUcsUUFBUSxDQUFDLG1CQUFtQjVNLFNBQVM7UUFDdEUsSUFBSWtXLFdBQVcsSUFBSSxDQUFDK0wsV0FBVztRQUMvQixJQUFJLEVBQ0ZvTCxTQUFTLEVBQ1YsR0FBRyxJQUFJO1FBQ1IsSUFBSTVPLE9BQU8vYixJQUFJNFksU0FBUztRQUV4QixJQUFJMlMsbUJBQW1CLGFBQWE7WUFDbEN2ckIsSUFBSXVJLFNBQVM7UUFDZjtRQUVBb2lCLFVBQVVsbkIsT0FBTyxDQUFDLENBQUNtYyxPQUFPbGY7WUFDeEIsSUFBSSxFQUNGb1UsRUFBRSxFQUNGQyxFQUFFLEVBQ0Z5VyxRQUFRLEVBQ1J2ZixNQUFNd2YsV0FBVyxFQUNsQixHQUFHN0w7WUFDSjVmLElBQUk4USxJQUFJO1lBQ1I5USxJQUFJb0ksU0FBUyxDQUFDME0sR0FBR3RULENBQUMsRUFBRXNULEdBQUdyVCxDQUFDO1lBQ3hCekIsSUFBSXVNLE1BQU0sQ0FBQ2lmO1lBRVgsSUFBSXhyQixJQUFJNFksU0FBUyxFQUFFO2dCQUNqQjVZLElBQUlpaEIsUUFBUSxDQUFDd0ssYUFBYSxHQUFHO1lBQy9CO1lBRUEsSUFBSXpyQixJQUFJdUcsV0FBVyxFQUFFO2dCQUNuQnZHLElBQUlraEIsVUFBVSxDQUFDdUssYUFBYSxHQUFHO1lBQ2pDO1lBRUF6ckIsSUFBSXFSLE9BQU87WUFFWCxJQUFJa2EsbUJBQW1CLGFBQWE7Z0JBQ2xDLElBQUk3cUIsTUFBTSxHQUFHO29CQUNYVixJQUFJd0ksTUFBTSxDQUFDc00sR0FBR3RULENBQUMsRUFBRXNULEdBQUdyVCxDQUFDLEdBQUcrUixXQUFXO2dCQUNyQztnQkFFQXhULElBQUl5SSxNQUFNLENBQUNzTSxHQUFHdlQsQ0FBQyxFQUFFdVQsR0FBR3RULENBQUMsR0FBRytSLFdBQVc7WUFDckMsRUFBRSw0REFBNEQ7UUFDOUQsRUFBRTtRQUNGLG1CQUFtQjtRQUNuQixhQUFhO1FBQ2IsNEJBQTRCO1FBQzVCLE9BQU87UUFDUCw4QkFBOEI7UUFDOUIsMEJBQTBCO1FBQzFCLDBCQUEwQjtRQUMxQixnQkFBZ0I7UUFDaEIsbUJBQW1CO1FBRXJCO1FBRUEsSUFBSStYLG1CQUFtQixhQUFhO1lBQ2xDdnJCLElBQUltWixTQUFTLEdBQUczRixXQUFXO1lBQzNCeFQsSUFBSXVHLFdBQVcsR0FBR3dWO1lBQ2xCL2IsSUFBSWljLE1BQU07WUFDVmpjLElBQUkwSSxTQUFTO1FBQ2Y7UUFFQTFJLElBQUlxUixPQUFPO0lBQ2I7SUFFQXFhLHFCQUFxQjtRQUNuQixJQUFJQyxNQUFNcjBCLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHO1FBQzlFLE9BQU8sSUFBSSxDQUFDc3pCLGtCQUFrQixDQUFDZSxJQUFJLElBQUk7SUFDekM7SUFFQUMscUJBQXFCNXJCLEdBQUcsRUFBRTZyQixNQUFNLEVBQUVDLGFBQWEsRUFBRUMsYUFBYSxFQUFFQyxZQUFZLEVBQUVDLFdBQVcsRUFBRUMsRUFBRSxFQUFFeGUsQ0FBQyxFQUFFeWUsS0FBSyxFQUFFO1FBQ3ZHLElBQUl0UyxTQUFTb1M7UUFDYixJQUFJRyxhQUFhLElBQUksQ0FBQzNNLFdBQVcsQ0FBQ3pmLEtBQUswTjtRQUV2QyxJQUFJQSxNQUFNLE9BQU9tZSxXQUFXLGFBQWFDLGdCQUFnQkMsZUFBZTtZQUN0RUssY0FBYyxDQUFDTCxnQkFBZ0JELGFBQVksSUFBS0U7UUFDbEQ7UUFFQSxJQUFJRyxRQUFRLENBQUMsR0FBRztZQUNkdFMsVUFBVSxJQUFJLENBQUM2UixrQkFBa0IsQ0FBQ1M7UUFDcEM7UUFFQSxJQUFJRSxhQUFhLElBQUksQ0FBQzVCLFVBQVUsR0FBRztRQUNuQyxJQUFJM1YsS0FBSyxJQUFJLENBQUN3WCx5QkFBeUIsQ0FBQ3pTLFFBQVF3UyxZQUFZO1FBQzVELElBQUl0WCxLQUFLLElBQUksQ0FBQ3VYLHlCQUF5QixDQUFDelMsU0FBU3VTLFlBQVlDLFlBQVk7UUFDekUsSUFBSUUsVUFBVTtZQUNaelg7WUFDQUM7UUFDRjtRQUNBLElBQUl5VyxXQUFXMVcsTUFBTUMsS0FBS25hLEtBQUt3SCxLQUFLLENBQUMyUyxHQUFHdFQsQ0FBQyxHQUFHcVQsR0FBR3JULENBQUMsRUFBRXNULEdBQUd2VCxDQUFDLEdBQUdzVCxHQUFHdFQsQ0FBQyxJQUFJO1FBRWpFLElBQUkwcUIsSUFBSTtZQUNOLElBQUlNLE1BQU01eEIsS0FBS3NTLEdBQUcsQ0FBQ3RTLEtBQUs2RSxFQUFFLEdBQUcsSUFBSStyQixZQUFZVTtZQUM3QyxJQUFJTyxNQUFNN3hCLEtBQUtzUyxHQUFHLENBQUMsQ0FBQ3NlLFlBQVlVO1lBQ2hDSyxRQUFRelgsRUFBRSxHQUFHbVYsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHblYsS0FBSyxDQUFDLEdBQUc7Z0JBQ3hEdFQsR0FBR3NULEdBQUd0VCxDQUFDLEdBQUdnckI7Z0JBQ1YvcUIsR0FBR3FULEdBQUdyVCxDQUFDLEdBQUdnckI7WUFDWjtZQUNBRixRQUFReFgsRUFBRSxHQUFHa1YsZ0JBQWdCQSxnQkFBZ0IsQ0FBQyxHQUFHbFYsS0FBSyxDQUFDLEdBQUc7Z0JBQ3hEdlQsR0FBR3VULEdBQUd2VCxDQUFDLEdBQUdnckI7Z0JBQ1YvcUIsR0FBR3NULEdBQUd0VCxDQUFDLEdBQUdnckI7WUFDWjtRQUNGO1FBRUE1UyxVQUFVdVM7UUFDVixPQUFPO1lBQ0x2UztZQUNBMFM7WUFDQWY7UUFDRjtJQUNGO0lBRUEvTCxZQUFZemYsR0FBRyxFQUFFaU0sSUFBSSxFQUFFO1FBQ3JCLElBQUksRUFDRjRlLGFBQWEsRUFDZCxHQUFHLElBQUk7UUFDUixJQUFJNUksYUFBYWhXLFFBQVEsSUFBSSxDQUFDcUUsT0FBTztRQUVyQyxJQUFJdWEsY0FBYzZCLEdBQUcsQ0FBQ3pLLGFBQWE7WUFDakMsT0FBTzRJLGNBQWM4QixHQUFHLENBQUMxSztRQUMzQjtRQUVBLElBQUlGLFVBQVUsSUFBSSxDQUFDQyxpQkFBaUIsQ0FBQ2hpQixLQUFLaWlCO1FBQzFDNEksY0FBY2hYLEdBQUcsQ0FBQ29PLFlBQVlGO1FBQzlCLE9BQU9BO0lBQ1Q7SUFDQSxpR0FBaUc7SUFDakcsZ0VBQWdFO0lBR2hFdUosWUFBWXRyQixHQUFHLEVBQUU7UUFDZixJQUFJLElBQUksQ0FBQzJxQixTQUFTLEVBQUU7WUFDbEI7UUFDRjtRQUVBLElBQUluSyxhQUFhLElBQUksQ0FBQ2xRLE9BQU87UUFDN0IsSUFBSXNjLFFBQVFwTSxXQUFXcGpCLEtBQUssQ0FBQztRQUM3QixJQUFJNHVCLGVBQWV4TCxXQUFXcGpCLEtBQUssQ0FBQyxLQUFLN0YsTUFBTSxHQUFHO1FBQ2xELElBQUl3cEIsS0FBSyxJQUFJLENBQUNwZCxNQUFNLENBQUN2RCxZQUFZLENBQUMsTUFBTWhELEtBQUssR0FBRzFELEdBQUcsQ0FBQzBNLENBQUFBLElBQUtBLEVBQUV2SCxTQUFTLENBQUM7UUFDckUsSUFBSXF0QixLQUFLLElBQUksQ0FBQ3ZvQixNQUFNLENBQUN2RCxZQUFZLENBQUMsTUFBTXZCLFNBQVMsQ0FBQztRQUNsRCxJQUFJZ3RCLFNBQVMsSUFBSSxDQUFDbG9CLE1BQU0sQ0FBQ3VHLFFBQVEsQ0FBQyxlQUFlNU0sU0FBUyxDQUFDO1FBQzNELElBQUl1dkIsY0FBYyxJQUFJLENBQUMzaUIsUUFBUSxDQUFDO1FBQ2hDLElBQUk0aUIsZ0JBQWdCLElBQUksQ0FBQ25wQixNQUFNLENBQUN1RyxRQUFRLENBQUM7UUFDekMsSUFBSTZpQixnQkFBZ0I7UUFFcEIsSUFBSSxDQUFDRixZQUFZcnZCLFFBQVEsTUFBTXF2QixZQUFZM3VCLFFBQVEsT0FBTyxXQUFXO1lBQ25FNnVCLGdCQUFnQkQsY0FBY2p1QixTQUFTO1FBQ3pDLE9BQU8sSUFBSWd1QixZQUFZcnZCLFFBQVEsSUFBSTtZQUNqQyxJQUFJcXZCLFlBQVkzdUIsUUFBUSxPQUFPLGFBQWEydUIsWUFBWTN1QixRQUFRLE9BQU8sU0FBUztnQkFDOUU2dUIsZ0JBQWdCRixZQUFZaHVCLFNBQVM7WUFDdkM7UUFDRixFQUFFLDRCQUE0QjtRQUc5QixJQUFJK3JCLHFCQUFxQixFQUFFO1FBQzNCLElBQUlvQyxVQUFVeE0sV0FBV2pwQixNQUFNO1FBQy9CLElBQUksQ0FBQ3F6QixrQkFBa0IsR0FBR0E7UUFFMUIsSUFBSyxJQUFJbHFCLElBQUksR0FBR0EsSUFBSXNzQixTQUFTdHNCLElBQUs7WUFDaENrcUIsbUJBQW1CMXBCLElBQUksQ0FBQyxPQUFPNmYsRUFBRSxDQUFDcmdCLEVBQUUsS0FBSyxjQUFjcWdCLEVBQUUsQ0FBQ3JnQixFQUFFLEdBQUdxc0I7UUFDakU7UUFFQSxJQUFJRSxRQUFRckMsbUJBQW1COWdCLE1BQU0sQ0FBQyxDQUFDb2pCLEtBQUtDLEtBQUt6c0IsSUFBTUEsTUFBTSxJQUFJLElBQUl3c0IsTUFBTUMsT0FBTyxHQUFHO1FBQ3JGLElBQUkzQyxZQUFZLElBQUksQ0FBQy9LLFdBQVcsQ0FBQ3pmO1FBQ2pDLElBQUk4ckIsZ0JBQWdCbHhCLEtBQUswRSxHQUFHLENBQUNrckIsWUFBWXlDLE9BQU87UUFDaEQsSUFBSSxDQUFDekMsU0FBUyxHQUFHQTtRQUNqQixJQUFJLENBQUNDLFVBQVUsR0FBRyxJQUFJLENBQUNsTCxXQUFXO1FBQ2xDLElBQUksQ0FBQ29MLFNBQVMsR0FBRyxFQUFFO1FBQ25CLElBQUlvQixnQkFBZ0IsSUFBSSxDQUFDcUIsYUFBYTtRQUN0QyxJQUFJQyxjQUFjLElBQUksQ0FBQ25qQixRQUFRLENBQUMsZUFBZTlMLFNBQVMsQ0FBQyxLQUFLMnRCO1FBQzlELElBQUlsUyxTQUFTO1FBRWIsSUFBSWdTLFdBQVcsWUFBWUEsV0FBVyxVQUFVO1lBQzlDaFMsU0FBUyxDQUFDaVMsZ0JBQWdCO1FBQzVCO1FBRUEsSUFBSUQsV0FBVyxTQUFTQSxXQUFXLFNBQVM7WUFDMUNoUyxTQUFTLENBQUNpUztRQUNaO1FBRUFqUyxVQUFVd1Q7UUFDVlQsTUFBTW5wQixPQUFPLENBQUMsQ0FBQ2tjLE1BQU1qZjtZQUNuQiw4RUFBOEU7WUFDOUUsSUFBSSxFQUNGbVosUUFBUXlULFVBQVUsRUFDbEJmLE9BQU8sRUFDUGYsUUFBUSxFQUNULEdBQUcsSUFBSSxDQUFDSSxvQkFBb0IsQ0FBQzVyQixLQUFLNnJCLFFBQVFDLGVBQWVDLGVBQWVDLGNBQWNuUyxRQUFRcVMsSUFBSXZNLE1BQU1qZjtZQUN6R21aLFNBQVN5VDtZQUVULElBQUksQ0FBQ2YsUUFBUXpYLEVBQUUsSUFBSSxDQUFDeVgsUUFBUXhYLEVBQUUsRUFBRTtnQkFDOUI7WUFDRixFQUFFLG9DQUFvQztZQUN0QyxpQkFBaUI7WUFDakIsaUJBQWlCO1lBQ2pCLGlCQUFpQjtZQUNqQixnQkFBZ0I7WUFDaEIsS0FBSztZQUNMLDZHQUE2RztZQUM3Ryw0RkFBNEY7WUFDNUYsa0VBQWtFO1lBQ2xFLGtCQUFrQjtZQUNsQix3Q0FBd0M7WUFDeEMsd0NBQXdDO1lBQ3hDLHVCQUF1QjtZQUN2QiwwREFBMEQ7WUFDMUQsS0FBSztZQUdMLElBQUksQ0FBQzRWLFNBQVMsQ0FBQ3pwQixJQUFJLENBQUM7Z0JBQ2xCLDBCQUEwQjtnQkFDMUIsMEJBQTBCO2dCQUMxQitLLE1BQU0yZ0IsS0FBSyxDQUFDbHNCLEVBQUU7Z0JBQ2RvVSxJQUFJeVgsUUFBUXpYLEVBQUU7Z0JBQ2RDLElBQUl3WCxRQUFReFgsRUFBRTtnQkFDZHlXO1lBQ0Y7UUFDRjtJQUNGO0lBRUFQLGNBQWNqcEIsSUFBSSxFQUFFO1FBQ2xCLElBQUksQ0FBQzBvQixVQUFVLEdBQUcsQ0FBQyxHQUFHLG9CQUFvQjtRQUUxQyxJQUFJLENBQUMxb0IsTUFBTTtZQUNULE9BQU8sRUFBRTtRQUNYO1FBRUEsSUFBSXVyQixlQUFlLEVBQUU7UUFDckIsSUFBSSxFQUNGN1MsVUFBVSxFQUNYLEdBQUcxWTtRQUNKMFksV0FBVzlELEtBQUssSUFBSSxpQ0FBaUM7UUFFckQsTUFBTyxDQUFDOEQsV0FBVzdELEtBQUssR0FBSTtZQUMxQixJQUFJLEVBQ0ZOLE9BQU8sRUFDUixHQUFHbUU7WUFDSixJQUFJOFMsU0FBU2pYLFVBQVVBLFFBQVEvVSxDQUFDLEdBQUc7WUFDbkMsSUFBSWlzQixTQUFTbFgsVUFBVUEsUUFBUTlVLENBQUMsR0FBRztZQUNuQyxJQUFJK1UsVUFBVWtFLFdBQVc1RCxJQUFJO1lBQzdCLElBQUk0VyxrQkFBa0JsWCxRQUFRNVIsSUFBSTtZQUNsQyxJQUFJM0MsU0FBUyxFQUFFO1lBRWYsT0FBUXVVLFFBQVE1UixJQUFJO2dCQUNsQixLQUFLeVIsV0FBV3NFLE9BQU87b0JBQ3JCLElBQUksQ0FBQ0MsS0FBSyxDQUFDRixZQUFZelk7b0JBQ3ZCO2dCQUVGLEtBQUtvVSxXQUFXd0UsT0FBTztvQkFDckI2UyxrQkFBa0IsSUFBSSxDQUFDNVMsS0FBSyxDQUFDSixZQUFZelk7b0JBQ3pDO2dCQUVGLEtBQUtvVSxXQUFXMEUsYUFBYTtvQkFDM0IyUyxrQkFBa0IsSUFBSSxDQUFDMVMsS0FBSyxDQUFDTixZQUFZelk7b0JBQ3pDO2dCQUVGLEtBQUtvVSxXQUFXNEUsWUFBWTtvQkFDMUJ5UyxrQkFBa0IsSUFBSSxDQUFDeFMsS0FBSyxDQUFDUixZQUFZelk7b0JBQ3pDO2dCQUVGLEtBQUtvVSxXQUFXaUIsUUFBUTtvQkFDdEIsSUFBSSxDQUFDNkQsS0FBSyxDQUFDVCxZQUFZelk7b0JBQ3ZCO2dCQUVGLEtBQUtvVSxXQUFXa0IsZUFBZTtvQkFDN0JtVyxrQkFBa0IsSUFBSSxDQUFDdFMsS0FBSyxDQUFDVixZQUFZelk7b0JBQ3pDO2dCQUVGLEtBQUtvVSxXQUFXbUIsT0FBTztvQkFDckIsSUFBSSxDQUFDNkQsS0FBSyxDQUFDWCxZQUFZelk7b0JBQ3ZCO2dCQUVGLEtBQUtvVSxXQUFXb0IsY0FBYztvQkFDNUJpVyxrQkFBa0IsSUFBSSxDQUFDcFMsS0FBSyxDQUFDWixZQUFZelk7b0JBQ3pDO2dCQUVGLEtBQUtvVSxXQUFXa0YsR0FBRztvQkFDakJ0WixTQUFTLElBQUksQ0FBQ3VaLEtBQUssQ0FBQ2Q7b0JBQ3BCO2dCQUVGLEtBQUtyRSxXQUFXb0YsVUFBVTtvQkFDeEJoQixZQUFZaUIsS0FBSyxDQUFDaEI7b0JBQ2xCO1lBQ0o7WUFFQSxJQUFJbEUsUUFBUTVSLElBQUksS0FBS3lSLFdBQVdvRixVQUFVLEVBQUU7Z0JBQzFDOFIsYUFBYXJzQixJQUFJLENBQUM7b0JBQ2hCMEQsTUFBTThvQjtvQkFDTnpyQjtvQkFDQWdCLE9BQU87d0JBQ0x6QixHQUFHZ3NCO3dCQUNIL3JCLEdBQUdnc0I7b0JBQ0w7b0JBQ0EvQyxZQUFZLElBQUksQ0FBQ2lELFVBQVUsQ0FBQ0gsUUFBUUMsUUFBUUMsaUJBQWlCenJCO2dCQUMvRDtZQUNGLE9BQU87Z0JBQ0xzckIsYUFBYXJzQixJQUFJLENBQUM7b0JBQ2hCMEQsTUFBTXlSLFdBQVdvRixVQUFVO29CQUMzQnhaLFFBQVEsRUFBRTtvQkFDVnlvQixZQUFZO2dCQUNkO1lBQ0Y7UUFDRjtRQUVBLE9BQU82QztJQUNUO0lBRUEzUyxNQUFNRixVQUFVLEVBQUV6WSxNQUFNLEVBQUU7UUFDeEIsSUFBSSxFQUNGVCxDQUFDLEVBQ0RDLENBQUMsRUFDRixHQUFHZ1osWUFBWUcsS0FBSyxDQUFDRixZQUFZL1ksS0FBSztRQUN2Q00sT0FBT2YsSUFBSSxDQUFDTSxHQUFHQztJQUNqQjtJQUVBcVosTUFBTUosVUFBVSxFQUFFelksTUFBTSxFQUFFO1FBQ3hCLElBQUksRUFDRlQsQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBR2daLFlBQVlLLEtBQUssQ0FBQ0osWUFBWS9ZLEtBQUs7UUFDdkNNLE9BQU9mLElBQUksQ0FBQ00sR0FBR0M7UUFDZixPQUFPNFUsV0FBV3dFLE9BQU87SUFDM0I7SUFFQUcsTUFBTU4sVUFBVSxFQUFFelksTUFBTSxFQUFFO1FBQ3hCLElBQUksRUFDRlQsQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBR2daLFlBQVlPLEtBQUssQ0FBQ04sWUFBWS9ZLEtBQUs7UUFDdkNNLE9BQU9mLElBQUksQ0FBQ00sR0FBR0M7UUFDZixPQUFPNFUsV0FBV3dFLE9BQU87SUFDM0I7SUFFQUssTUFBTVIsVUFBVSxFQUFFelksTUFBTSxFQUFFO1FBQ3hCLElBQUksRUFDRlQsQ0FBQyxFQUNEQyxDQUFDLEVBQ0YsR0FBR2daLFlBQVlTLEtBQUssQ0FBQ1IsWUFBWS9ZLEtBQUs7UUFDdkNNLE9BQU9mLElBQUksQ0FBQ00sR0FBR0M7UUFDZixPQUFPNFUsV0FBV3dFLE9BQU87SUFDM0I7SUFFQU0sTUFBTVQsVUFBVSxFQUFFelksTUFBTSxFQUFFO1FBQ3hCLElBQUksRUFDRk4sS0FBSyxFQUNMa2IsWUFBWSxFQUNaQyxZQUFZLEVBQ2IsR0FBR3JDLFlBQVlVLEtBQUssQ0FBQ1Q7UUFDdEJ6WSxPQUFPZixJQUFJLENBQUNTLE1BQU1ILENBQUMsRUFBRUcsTUFBTUYsQ0FBQyxFQUFFb2IsYUFBYXJiLENBQUMsRUFBRXFiLGFBQWFwYixDQUFDLEVBQUVxYixhQUFhdGIsQ0FBQyxFQUFFc2IsYUFBYXJiLENBQUM7SUFDOUY7SUFFQTJaLE1BQU1WLFVBQVUsRUFBRXpZLE1BQU0sRUFBRTtRQUN4QixJQUFJLEVBQ0ZOLEtBQUssRUFDTGtiLFlBQVksRUFDWkMsWUFBWSxFQUNiLEdBQUdyQyxZQUFZVyxLQUFLLENBQUNWO1FBQ3RCelksT0FBT2YsSUFBSSxDQUFDUyxNQUFNSCxDQUFDLEVBQUVHLE1BQU1GLENBQUMsRUFBRW9iLGFBQWFyYixDQUFDLEVBQUVxYixhQUFhcGIsQ0FBQyxFQUFFcWIsYUFBYXRiLENBQUMsRUFBRXNiLGFBQWFyYixDQUFDO1FBQzVGLE9BQU80VSxXQUFXaUIsUUFBUTtJQUM1QjtJQUVBK0QsTUFBTVgsVUFBVSxFQUFFelksTUFBTSxFQUFFO1FBQ3hCLElBQUksRUFDRjRhLFlBQVksRUFDWkMsWUFBWSxFQUNiLEdBQUdyQyxZQUFZWSxLQUFLLENBQUNYO1FBQ3RCelksT0FBT2YsSUFBSSxDQUFDMmIsYUFBYXJiLENBQUMsRUFBRXFiLGFBQWFwYixDQUFDLEVBQUVxYixhQUFhdGIsQ0FBQyxFQUFFc2IsYUFBYXJiLENBQUM7SUFDNUU7SUFFQTZaLE1BQU1aLFVBQVUsRUFBRXpZLE1BQU0sRUFBRTtRQUN4QixJQUFJLEVBQ0Y0YSxZQUFZLEVBQ1pDLFlBQVksRUFDYixHQUFHckMsWUFBWWEsS0FBSyxDQUFDWjtRQUN0QnpZLE9BQU9mLElBQUksQ0FBQzJiLGFBQWFyYixDQUFDLEVBQUVxYixhQUFhcGIsQ0FBQyxFQUFFcWIsYUFBYXRiLENBQUMsRUFBRXNiLGFBQWFyYixDQUFDO1FBQzFFLE9BQU80VSxXQUFXbUIsT0FBTztJQUMzQjtJQUVBZ0UsTUFBTWQsVUFBVSxFQUFFO1FBQ2hCLElBQUksRUFDRnVDLEVBQUUsRUFDRkMsRUFBRSxFQUNGRyxTQUFTLEVBQ1RDLGFBQWEsRUFDYkssS0FBSyxFQUNMQyxFQUFFLEVBQ0ZDLEVBQUUsRUFDSCxHQUFHcEQsWUFBWWUsS0FBSyxDQUFDZDtRQUV0QixJQUFJMkMsY0FBYyxLQUFLUSxLQUFLLEdBQUc7WUFDN0JBLE1BQU0sSUFBSWpqQixLQUFLNkUsRUFBRTtRQUNuQjtRQUVBLElBQUk0ZCxjQUFjLEtBQUtRLEtBQUssR0FBRztZQUM3QkEsTUFBTSxJQUFJampCLEtBQUs2RSxFQUFFO1FBQ25CO1FBRUEsT0FBTztZQUFDa2UsTUFBTW5jLENBQUM7WUFBRW1jLE1BQU1sYyxDQUFDO1lBQUV3YjtZQUFJQztZQUFJVTtZQUFJQztZQUFJUDtZQUFlRDtTQUFVO0lBQ3JFO0lBRUFzUSxXQUFXbnNCLENBQUMsRUFBRUMsQ0FBQyxFQUFFbXNCLFdBQVcsRUFBRTNyQixNQUFNLEVBQUU7UUFDcEMsSUFBSXpCLE1BQU07UUFDVixJQUFJdVUsS0FBSztRQUNULElBQUlDLEtBQUs7UUFDVCxJQUFJelksSUFBSTtRQUVSLE9BQVFxeEI7WUFDTixLQUFLdlgsV0FBV3dFLE9BQU87Z0JBQ3JCLE9BQU8sSUFBSSxDQUFDZ1QsYUFBYSxDQUFDcnNCLEdBQUdDLEdBQUdRLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFO1lBRXRELEtBQUtvVSxXQUFXaUIsUUFBUTtnQkFDdEIsd0RBQXdEO2dCQUN4RDlXLE1BQU07Z0JBQ051VSxLQUFLLElBQUksQ0FBQytZLHFCQUFxQixDQUFDLEdBQUd0c0IsR0FBR0MsR0FBR1EsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUU7Z0JBRXpHLElBQUsxRixJQUFJLE1BQU1BLEtBQUssR0FBR0EsS0FBSyxLQUFNO29CQUNoQ3lZLEtBQUssSUFBSSxDQUFDOFkscUJBQXFCLENBQUN2eEIsR0FBR2lGLEdBQUdDLEdBQUdRLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFO29CQUN6R3pCLE9BQU8sSUFBSSxDQUFDcXRCLGFBQWEsQ0FBQzlZLEdBQUd2VCxDQUFDLEVBQUV1VCxHQUFHdFQsQ0FBQyxFQUFFdVQsR0FBR3hULENBQUMsRUFBRXdULEdBQUd2VCxDQUFDO29CQUNoRHNULEtBQUtDO2dCQUNQO2dCQUVBLE9BQU94VTtZQUVULEtBQUs2VixXQUFXbUIsT0FBTztnQkFDckIsd0RBQXdEO2dCQUN4RGhYLE1BQU07Z0JBQ051VSxLQUFLLElBQUksQ0FBQ2daLHlCQUF5QixDQUFDLEdBQUd2c0IsR0FBR0MsR0FBR1EsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUU7Z0JBRXZGLElBQUsxRixJQUFJLE1BQU1BLEtBQUssR0FBR0EsS0FBSyxLQUFNO29CQUNoQ3lZLEtBQUssSUFBSSxDQUFDK1kseUJBQXlCLENBQUN4eEIsR0FBR2lGLEdBQUdDLEdBQUdRLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFO29CQUN2RnpCLE9BQU8sSUFBSSxDQUFDcXRCLGFBQWEsQ0FBQzlZLEdBQUd2VCxDQUFDLEVBQUV1VCxHQUFHdFQsQ0FBQyxFQUFFdVQsR0FBR3hULENBQUMsRUFBRXdULEdBQUd2VCxDQUFDO29CQUNoRHNULEtBQUtDO2dCQUNQO2dCQUVBLE9BQU94VTtZQUVULEtBQUs2VixXQUFXa0YsR0FBRztnQkFDakI7b0JBQ0Usb0RBQW9EO29CQUNwRC9hLE1BQU07b0JBQ04sSUFBSXlDLFFBQVFoQixNQUFNLENBQUMsRUFBRSxFQUFFLFlBQVk7b0JBRW5DLElBQUlrcEIsU0FBU2xwQixNQUFNLENBQUMsRUFBRSxFQUFFLGFBQWE7b0JBRXJDLElBQUkrckIsTUFBTS9yQixNQUFNLENBQUMsRUFBRSxHQUFHa3BCO29CQUN0QixJQUFJOEMsTUFBTXJ6QixLQUFLNkUsRUFBRSxHQUFHLE9BQU8sc0JBQXNCO29CQUVqRCxJQUFJN0UsS0FBS3N6QixHQUFHLENBQUNqckIsUUFBUStxQixPQUFPQyxLQUFLO3dCQUMvQkEsTUFBTXJ6QixLQUFLc3pCLEdBQUcsQ0FBQ2pyQixRQUFRK3FCO29CQUN6QixFQUFFLHFHQUFxRztvQkFHdkdqWixLQUFLLElBQUksQ0FBQ29aLHVCQUF1QixDQUFDbHNCLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVnQixPQUFPO29CQUVyRixJQUFJa29CLFNBQVMsR0FBRzt3QkFDZCxZQUFZO3dCQUNaLElBQUs1dUIsSUFBSTBHLFFBQVFnckIsS0FBSzF4QixJQUFJeXhCLEtBQUt6eEIsS0FBSzB4QixJQUFLOzRCQUN2Q2paLEtBQUssSUFBSSxDQUFDbVosdUJBQXVCLENBQUNsc0IsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRTFGLEdBQUc7NEJBQ2pGaUUsT0FBTyxJQUFJLENBQUNxdEIsYUFBYSxDQUFDOVksR0FBR3ZULENBQUMsRUFBRXVULEdBQUd0VCxDQUFDLEVBQUV1VCxHQUFHeFQsQ0FBQyxFQUFFd1QsR0FBR3ZULENBQUM7NEJBQ2hEc1QsS0FBS0M7d0JBQ1A7b0JBQ0YsT0FBTzt3QkFDTCxvQkFBb0I7d0JBQ3BCLElBQUt6WSxJQUFJMEcsUUFBUWdyQixLQUFLMXhCLElBQUl5eEIsS0FBS3p4QixLQUFLMHhCLElBQUs7NEJBQ3ZDalosS0FBSyxJQUFJLENBQUNtWix1QkFBdUIsQ0FBQ2xzQixNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFMUYsR0FBRzs0QkFDakZpRSxPQUFPLElBQUksQ0FBQ3F0QixhQUFhLENBQUM5WSxHQUFHdlQsQ0FBQyxFQUFFdVQsR0FBR3RULENBQUMsRUFBRXVULEdBQUd4VCxDQUFDLEVBQUV3VCxHQUFHdlQsQ0FBQzs0QkFDaERzVCxLQUFLQzt3QkFDUDtvQkFDRjtvQkFFQUEsS0FBSyxJQUFJLENBQUNtWix1QkFBdUIsQ0FBQ2xzQixNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFK3JCLEtBQUs7b0JBQ25GeHRCLE9BQU8sSUFBSSxDQUFDcXRCLGFBQWEsQ0FBQzlZLEdBQUd2VCxDQUFDLEVBQUV1VCxHQUFHdFQsQ0FBQyxFQUFFdVQsR0FBR3hULENBQUMsRUFBRXdULEdBQUd2VCxDQUFDO29CQUNoRCxPQUFPakI7Z0JBQ1Q7UUFDSjtRQUVBLE9BQU87SUFDVDtJQUVBNHRCLGVBQWVDLElBQUksRUFBRTNZLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRTtRQUN2QyxJQUFJeVksUUFBUWgzQixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBR29lO1FBQ2hGLElBQUk2WSxRQUFRajNCLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHcWU7UUFDaEYsSUFBSTZZLElBQUksQ0FBQzNZLE1BQU1GLEdBQUUsSUFBTUMsQ0FBQUEsTUFBTUYsTUFBTTdaLFdBQVU7UUFDN0MsSUFBSTZILE1BQU05SSxLQUFLb0IsSUFBSSxDQUFDcXlCLE9BQU9BLE9BQVEsS0FBSUcsSUFBSUEsQ0FBQUE7UUFFM0MsSUFBSTVZLE1BQU1GLEtBQUs7WUFDYmhTLE9BQU8sQ0FBQztRQUNWO1FBRUEsSUFBSStxQixPQUFPRCxJQUFJOXFCO1FBQ2YsSUFBSWdyQixLQUFLO1FBRVQsSUFBSTlZLFFBQVFGLEtBQUs7WUFDZixnQkFBZ0I7WUFDaEJnWixLQUFLO2dCQUNIbHRCLEdBQUc4c0I7Z0JBQ0g3c0IsR0FBRzhzQixRQUFRRTtZQUNiO1FBQ0YsT0FBTyxJQUFJLENBQUNGLFFBQVE1WSxHQUFFLElBQU0yWSxDQUFBQSxRQUFRNVksTUFBTTdaLFdBQVUsTUFBTzJ5QixHQUFHO1lBQzVERSxLQUFLO2dCQUNIbHRCLEdBQUc4c0IsUUFBUTVxQjtnQkFDWGpDLEdBQUc4c0IsUUFBUUU7WUFDYjtRQUNGLE9BQU87WUFDTCxJQUFJRSxLQUFLO1lBQ1QsSUFBSUMsS0FBSztZQUNULElBQUlwdUIsTUFBTSxJQUFJLENBQUNxdEIsYUFBYSxDQUFDblksS0FBS0MsS0FBS0MsS0FBS0M7WUFFNUMsSUFBSXJWLE1BQU0zRSxhQUFhO2dCQUNyQixPQUFPO1lBQ1Q7WUFFQSxJQUFJTSxJQUFJLENBQUNteUIsUUFBUTVZLEdBQUUsSUFBTUUsQ0FBQUEsTUFBTUYsR0FBRSxJQUFLLENBQUM2WSxRQUFRNVksR0FBRSxJQUFNRSxDQUFBQSxNQUFNRixHQUFFO1lBQy9EeFosS0FBS3FFLE1BQU1BO1lBQ1htdUIsS0FBS2paLE1BQU12WixJQUFLeVosQ0FBQUEsTUFBTUYsR0FBRTtZQUN4QmtaLEtBQUtqWixNQUFNeFosSUFBSzBaLENBQUFBLE1BQU1GLEdBQUU7WUFDeEIsSUFBSWtaLFFBQVEsSUFBSSxDQUFDaEIsYUFBYSxDQUFDUyxPQUFPQyxPQUFPSSxJQUFJQztZQUNqRCxJQUFJRSxPQUFPbDBCLEtBQUtvQixJQUFJLENBQUNxeUIsT0FBT0EsT0FBT1EsUUFBUUE7WUFDM0NuckIsTUFBTTlJLEtBQUtvQixJQUFJLENBQUM4eUIsT0FBT0EsT0FBUSxLQUFJTixJQUFJQSxDQUFBQTtZQUV2QyxJQUFJNVksTUFBTUYsS0FBSztnQkFDYmhTLE9BQU8sQ0FBQztZQUNWO1lBRUErcUIsT0FBT0QsSUFBSTlxQjtZQUNYZ3JCLEtBQUs7Z0JBQ0hsdEIsR0FBR210QixLQUFLanJCO2dCQUNSakMsR0FBR210QixLQUFLSDtZQUNWO1FBQ0Y7UUFFQSxPQUFPQztJQUNUO0lBRUFLLGVBQWVDLFFBQVEsRUFBRTtRQUN2QixJQUFJQyxVQUFVLElBQUksQ0FBQzdCLGFBQWE7UUFDaEMsSUFBSThCLHVCQUF1QjtRQUMzQixJQUFJaEgsSUFBSTtRQUVSLElBQUk4RyxXQUFXLENBQUMsV0FBV0EsV0FBVyxVQUFVQyxTQUFTO1lBQ3ZELE9BQU87UUFDVDtRQUVBLElBQUksRUFDRmpFLFNBQVMsRUFDVixHQUFHLElBQUk7UUFFUixLQUFLLElBQUl4VSxXQUFXd1UsVUFBVztZQUM3QixJQUFJeFUsV0FBWUEsQ0FBQUEsUUFBUWtVLFVBQVUsR0FBRyxXQUFXd0UsdUJBQXVCMVksUUFBUWtVLFVBQVUsR0FBRyxVQUFVc0UsUUFBTyxHQUFJO2dCQUMvR0Usd0JBQXdCMVksUUFBUWtVLFVBQVU7Z0JBQzFDO1lBQ0Y7WUFFQSxJQUFJL3VCLFFBQVFxekIsV0FBV0U7WUFDdkIsSUFBSUMsV0FBVztZQUVmLE9BQVEzWSxRQUFRNVIsSUFBSTtnQkFDbEIsS0FBS3lSLFdBQVd3RSxPQUFPO29CQUNyQnFOLElBQUksSUFBSSxDQUFDa0csY0FBYyxDQUFDenlCLE9BQU82YSxRQUFRdlQsS0FBSyxDQUFDekIsQ0FBQyxFQUFFZ1YsUUFBUXZULEtBQUssQ0FBQ3hCLENBQUMsRUFBRStVLFFBQVF2VSxNQUFNLENBQUMsRUFBRSxFQUFFdVUsUUFBUXZVLE1BQU0sQ0FBQyxFQUFFLEVBQUV1VSxRQUFRdlQsS0FBSyxDQUFDekIsQ0FBQyxFQUFFZ1YsUUFBUXZULEtBQUssQ0FBQ3hCLENBQUM7b0JBQ3ZJO2dCQUVGLEtBQUs0VSxXQUFXa0YsR0FBRztvQkFDakI7d0JBQ0UsSUFBSXRZLFFBQVF1VCxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsRUFBRSxZQUFZO3dCQUUzQyxJQUFJa3BCLFNBQVMzVSxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsRUFBRSxhQUFhO3dCQUU3QyxJQUFJK3JCLE1BQU14WCxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsR0FBR2twQjt3QkFDOUJnRSxXQUFXbHNCLFFBQVF0SCxRQUFRNmEsUUFBUWtVLFVBQVUsR0FBR1M7d0JBRWhELElBQUlBLFNBQVMsS0FBS2dFLFdBQVduQixPQUFPN0MsVUFBVSxLQUFLZ0UsV0FBV25CLEtBQUs7NEJBQ2pFO3dCQUNGO3dCQUVBOUYsSUFBSSxJQUFJLENBQUNpRyx1QkFBdUIsQ0FBQzNYLFFBQVF2VSxNQUFNLENBQUMsRUFBRSxFQUFFdVUsUUFBUXZVLE1BQU0sQ0FBQyxFQUFFLEVBQUV1VSxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsRUFBRXVVLFFBQVF2VSxNQUFNLENBQUMsRUFBRSxFQUFFa3RCLFVBQVUzWSxRQUFRdlUsTUFBTSxDQUFDLEVBQUU7d0JBQ3hJO29CQUNGO2dCQUVGLEtBQUtvVSxXQUFXaUIsUUFBUTtvQkFDdEI2WCxXQUFXeHpCLFFBQVE2YSxRQUFRa1UsVUFBVTtvQkFFckMsSUFBSXlFLFdBQVcsR0FBRzt3QkFDaEJBLFdBQVc7b0JBQ2I7b0JBRUFqSCxJQUFJLElBQUksQ0FBQzRGLHFCQUFxQixDQUFDcUIsVUFBVTNZLFFBQVF2VCxLQUFLLENBQUN6QixDQUFDLEVBQUVnVixRQUFRdlQsS0FBSyxDQUFDeEIsQ0FBQyxFQUFFK1UsUUFBUXZVLE1BQU0sQ0FBQyxFQUFFLEVBQUV1VSxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsRUFBRXVVLFFBQVF2VSxNQUFNLENBQUMsRUFBRSxFQUFFdVUsUUFBUXZVLE1BQU0sQ0FBQyxFQUFFLEVBQUV1VSxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsRUFBRXVVLFFBQVF2VSxNQUFNLENBQUMsRUFBRTtvQkFDM0w7Z0JBRUYsS0FBS29VLFdBQVdtQixPQUFPO29CQUNyQjJYLFdBQVd4ekIsUUFBUTZhLFFBQVFrVSxVQUFVO29CQUVyQyxJQUFJeUUsV0FBVyxHQUFHO3dCQUNoQkEsV0FBVztvQkFDYjtvQkFFQWpILElBQUksSUFBSSxDQUFDNkYseUJBQXlCLENBQUNvQixVQUFVM1ksUUFBUXZULEtBQUssQ0FBQ3pCLENBQUMsRUFBRWdWLFFBQVF2VCxLQUFLLENBQUN4QixDQUFDLEVBQUUrVSxRQUFRdlUsTUFBTSxDQUFDLEVBQUUsRUFBRXVVLFFBQVF2VSxNQUFNLENBQUMsRUFBRSxFQUFFdVUsUUFBUXZVLE1BQU0sQ0FBQyxFQUFFLEVBQUV1VSxRQUFRdlUsTUFBTSxDQUFDLEVBQUU7b0JBQ3pKO1lBQ0o7WUFFQSxJQUFJaW1CLEdBQUc7Z0JBQ0wsT0FBT0E7WUFDVDtZQUVBO1FBQ0Y7UUFFQSxPQUFPO0lBQ1Q7SUFFQTJGLGNBQWMxWixFQUFFLEVBQUVHLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxFQUFFLEVBQUU7UUFDNUIsT0FBTzVaLEtBQUtvQixJQUFJLENBQUMsQ0FBQ3VZLEtBQUtKLEVBQUMsSUFBTUksQ0FBQUEsS0FBS0osRUFBQyxJQUFLLENBQUNLLEtBQUtGLEVBQUMsSUFBTUUsQ0FBQUEsS0FBS0YsRUFBQztJQUM5RDtJQUVBOFksZ0JBQWdCO1FBQ2QsSUFBSSxJQUFJLENBQUMxQyxVQUFVLEtBQUssQ0FBQyxHQUFHO1lBQzFCLElBQUksQ0FBQ0EsVUFBVSxHQUFHLElBQUksQ0FBQ00sU0FBUyxDQUFDbGhCLE1BQU0sQ0FBQyxDQUFDdlMsUUFBUWlmLFVBQVlBLFFBQVFrVSxVQUFVLEdBQUcsSUFBSW56QixTQUFTaWYsUUFBUWtVLFVBQVUsR0FBR256QixRQUFRO1FBQzlIO1FBRUEsT0FBTyxJQUFJLENBQUNtekIsVUFBVTtJQUN4QjtJQUVBb0Qsc0JBQXNCc0IsR0FBRyxFQUFFMVosR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRXNaLEdBQUcsRUFBRUMsR0FBRyxFQUFFO1FBQ2pFLElBQUk5dEIsSUFBSTZ0QixNQUFNL3lCLElBQUk4eUIsT0FBT3RaLE1BQU10WixJQUFJNHlCLE9BQU94WixNQUFNblosSUFBSTJ5QixPQUFPMVosTUFBTWhaLElBQUkweUI7UUFDckUsSUFBSTN0QixJQUFJNnRCLE1BQU1oekIsSUFBSTh5QixPQUFPclosTUFBTXZaLElBQUk0eUIsT0FBT3ZaLE1BQU1wWixJQUFJMnlCLE9BQU96WixNQUFNalosSUFBSTB5QjtRQUNyRSxPQUFPO1lBQ0w1dEI7WUFDQUM7UUFDRjtJQUNGO0lBRUFzc0IsMEJBQTBCcUIsR0FBRyxFQUFFMVosR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLEdBQUcsRUFBRTtRQUMzRCxJQUFJdlUsSUFBSXNVLE1BQU1uWixJQUFJeXlCLE9BQU94WixNQUFNaFosSUFBSXd5QixPQUFPMVosTUFBTTdZLElBQUl1eUI7UUFDcEQsSUFBSTN0QixJQUFJc1UsTUFBTXBaLElBQUl5eUIsT0FBT3ZaLE1BQU1qWixJQUFJd3lCLE9BQU96WixNQUFNOVksSUFBSXV5QjtRQUNwRCxPQUFPO1lBQ0w1dEI7WUFDQUM7UUFDRjtJQUNGO0lBRUEwc0Isd0JBQXdCdmhCLEVBQUUsRUFBRUMsRUFBRSxFQUFFNlcsRUFBRSxFQUFFQyxFQUFFLEVBQUV1SCxLQUFLLEVBQUVFLEdBQUcsRUFBRTtRQUNsRCxJQUFJbUUsU0FBUzMwQixLQUFLc1MsR0FBRyxDQUFDa2U7UUFDdEIsSUFBSW9FLFNBQVM1MEIsS0FBS3VTLEdBQUcsQ0FBQ2llO1FBQ3RCLElBQUlzRCxLQUFLO1lBQ1BsdEIsR0FBR2tpQixLQUFLOW9CLEtBQUtzUyxHQUFHLENBQUNnZTtZQUNqQnpwQixHQUFHa2lCLEtBQUsvb0IsS0FBS3VTLEdBQUcsQ0FBQytkO1FBQ25CO1FBQ0EsT0FBTztZQUNMMXBCLEdBQUdvTCxLQUFNOGhCLENBQUFBLEdBQUdsdEIsQ0FBQyxHQUFHK3RCLFNBQVNiLEdBQUdqdEIsQ0FBQyxHQUFHK3RCLE1BQUs7WUFDckMvdEIsR0FBR29MLEtBQU02aEIsQ0FBQUEsR0FBR2x0QixDQUFDLEdBQUdndUIsU0FBU2QsR0FBR2p0QixDQUFDLEdBQUc4dEIsTUFBSztRQUN2QztJQUNGO0lBR0FFLHNCQUFzQkMsU0FBUyxFQUFFQyxjQUFjLEVBQUU7UUFDL0MsSUFBSVYsVUFBVSxJQUFJLENBQUM3QixhQUFhO1FBQ2hDLElBQUl3QyxZQUFZRCxrQkFBa0IsTUFBTSwwQkFBMEI7UUFFbEUsSUFBSUUsT0FBT0gsYUFBYVQsVUFBVTtRQUVsQyxJQUFJLENBQUMsSUFBSSxDQUFDYSxnQkFBZ0IsSUFBSSxJQUFJLENBQUNBLGdCQUFnQixDQUFDRCxJQUFJLEtBQUtBLFFBQVEsSUFBSSxDQUFDQyxnQkFBZ0IsQ0FBQ0YsU0FBUyxLQUFLQSxXQUFXO1lBQ2xILGdCQUFnQjtZQUNoQixJQUFJLENBQUNFLGdCQUFnQixHQUFHO2dCQUN0QkQ7Z0JBQ0FEO2dCQUNBM3RCLFFBQVEsRUFBRTtZQUNaLEdBQUcsbUJBQW1CO1lBRXRCLElBQUl3YixJQUFJO1lBRVIsSUFBSyxJQUFJRCxJQUFJLEdBQUdBLEtBQUt5UixTQUFTelIsS0FBS29TLFVBQVc7Z0JBQzVDLElBQUk5YSxLQUFLLElBQUksQ0FBQ2lhLGNBQWMsQ0FBQ3ZSO2dCQUM3QixJQUFJekksS0FBSyxJQUFJLENBQUNnYSxjQUFjLENBQUN2UixJQUFJb1M7Z0JBRWpDLElBQUksQ0FBQzlhLE1BQU0sQ0FBQ0MsSUFBSTtvQkFDZDtnQkFDRjtnQkFFQTBJLEtBQUssSUFBSSxDQUFDb1EsYUFBYSxDQUFDL1ksR0FBR3RULENBQUMsRUFBRXNULEdBQUdyVCxDQUFDLEVBQUVzVCxHQUFHdlQsQ0FBQyxFQUFFdVQsR0FBR3RULENBQUM7Z0JBRTlDLElBQUlnYyxLQUFLb1MsTUFBTTtvQkFDYixJQUFJLENBQUNDLGdCQUFnQixDQUFDN3RCLE1BQU0sQ0FBQ2YsSUFBSSxDQUFDO3dCQUNoQ00sR0FBR3NULEdBQUd0VCxDQUFDO3dCQUNQQyxHQUFHcVQsR0FBR3JULENBQUM7d0JBQ1B1dEIsVUFBVXhSO29CQUNaO29CQUNBQyxLQUFLb1M7Z0JBQ1A7WUFDRjtRQUNGO0lBQ0Y7SUFFQXZELDBCQUEwQnlELGNBQWMsRUFBRUYsSUFBSSxFQUFFRCxTQUFTLEVBQUU7UUFDekQsSUFBSSxDQUFDSCxxQkFBcUIsQ0FBQ0ksTUFBTUQ7UUFFakMsSUFBSUcsaUJBQWlCLEtBQUtBLGlCQUFpQixJQUFJLENBQUMzQyxhQUFhLEtBQUssU0FBUztZQUN6RSxPQUFPO1FBQ1Q7UUFFQSxJQUFJekIsTUFBTS93QixLQUFLQyxLQUFLLENBQUNrMUIsaUJBQWlCLElBQUksQ0FBQzNDLGFBQWEsS0FBTSxLQUFJLENBQUMwQyxnQkFBZ0IsQ0FBQzd0QixNQUFNLENBQUMxSyxNQUFNLEdBQUc7UUFDcEcsT0FBTyxJQUFJLENBQUN1NEIsZ0JBQWdCLENBQUM3dEIsTUFBTSxDQUFDMHBCLElBQUksSUFBSTtJQUM5QztBQUVGO0FBRUEsSUFBSXFFLGVBQWU7QUFDbkIsTUFBTUMscUJBQXFCOVg7SUFDekJwYixZQUFZQyxTQUFRLEVBQUV0RSxJQUFJLEVBQUV3VyxnQkFBZ0IsQ0FBRTtRQUM1QyxLQUFLLENBQUNsUyxXQUFVdEUsTUFBTXdXO1FBQ3RCLElBQUksQ0FBQ3RLLElBQUksR0FBRztRQUNaLElBQUksQ0FBQ3NyQixNQUFNLEdBQUc7UUFDZCxJQUFJQyxPQUFPLElBQUksQ0FBQ2p3QixnQkFBZ0IsR0FBRzVDLFNBQVM7UUFFNUMsSUFBSSxDQUFDNnlCLE1BQU07WUFDVDtRQUNGO1FBRUEsSUFBSUMsUUFBUUQsS0FBS255QixRQUFRLENBQUMsV0FBVyw0QkFBNEJqRSxJQUFJLENBQUNvMkI7UUFDdEVuekIsVUFBU3F6QixNQUFNLENBQUNudkIsSUFBSSxDQUFDLElBQUk7UUFFekIsSUFBSSxDQUFDa3ZCLE9BQU87WUFDVixLQUFLLElBQUksQ0FBQ3YzQixTQUFTLENBQUNzM0I7UUFDdEIsT0FBTztZQUNMLEtBQUssSUFBSSxDQUFDRyxPQUFPLENBQUNIO1FBQ3BCO1FBRUEsSUFBSSxDQUFDQyxLQUFLLEdBQUdBO0lBQ2Y7SUFFQXYzQixVQUFVczNCLElBQUksRUFBRTtRQUNkLElBQUk5a0IsUUFBUSxJQUFJO1FBRWhCLE9BQU94VSxvRUFBaUJBLENBQUM7WUFDdkIsSUFBSTtnQkFDRixJQUFJMDVCLFFBQVEsTUFBTWxsQixNQUFNck8sUUFBUSxDQUFDL0UsV0FBVyxDQUFDazRCO2dCQUM3QzlrQixNQUFNa2xCLEtBQUssR0FBR0E7WUFDaEIsRUFBRSxPQUFPNWtCLEtBQUs7Z0JBQ1o2a0IsUUFBUUMsS0FBSyxDQUFDLDhCQUErQnJtQixNQUFNLENBQUMrbEIsTUFBTSxPQUFReGtCO1lBQ3BFO1lBRUFOLE1BQU02a0IsTUFBTSxHQUFHO1FBQ2pCO0lBQ0Y7SUFFQUksUUFBUUgsSUFBSSxFQUFFO1FBQ1osSUFBSW5rQixTQUFTLElBQUk7UUFFakIsT0FBT25WLG9FQUFpQkEsQ0FBQztZQUN2QixJQUFJNEMsUUFBUXUyQixhQUFhNzFCLElBQUksQ0FBQ2cyQjtZQUU5QixJQUFJMTJCLE9BQU87Z0JBQ1QsSUFBSWdWLE9BQU9oVixLQUFLLENBQUMsRUFBRTtnQkFFbkIsSUFBSUEsS0FBSyxDQUFDLEVBQUUsS0FBSyxVQUFVO29CQUN6QnVTLE9BQU91a0IsS0FBSyxHQUFHRyxLQUFLamlCO2dCQUN0QixPQUFPO29CQUNMekMsT0FBT3VrQixLQUFLLEdBQUdJLG1CQUFtQmxpQjtnQkFDcEM7WUFDRixPQUFPO2dCQUNMLElBQUk7b0JBQ0YsSUFBSXRXLFdBQVcsTUFBTTZULE9BQU9oUCxRQUFRLENBQUM1RSxLQUFLLENBQUMrM0I7b0JBQzNDLElBQUlTLE1BQU0sTUFBTXo0QixTQUFTOFQsSUFBSTtvQkFDN0JELE9BQU91a0IsS0FBSyxHQUFHSztnQkFDakIsRUFBRSxPQUFPamxCLEtBQUs7b0JBQ1o2a0IsUUFBUUMsS0FBSyxDQUFDLDhCQUErQnJtQixNQUFNLENBQUMrbEIsTUFBTSxPQUFReGtCO2dCQUNwRTtZQUNGO1lBRUFLLE9BQU9ra0IsTUFBTSxHQUFHO1FBQ2xCO0lBQ0Y7SUFFQS9lLGVBQWVuUixHQUFHLEVBQUU7UUFDbEIsSUFBSSxFQUNGaEQsVUFBQUEsU0FBUSxFQUNSdXpCLEtBQUssRUFDTEwsTUFBTSxFQUNQLEdBQUcsSUFBSTtRQUNSLElBQUkxdUIsSUFBSSxJQUFJLENBQUNwQixZQUFZLENBQUMsS0FBS3ZCLFNBQVMsQ0FBQztRQUN6QyxJQUFJNEMsSUFBSSxJQUFJLENBQUNyQixZQUFZLENBQUMsS0FBS3ZCLFNBQVMsQ0FBQztRQUN6QyxJQUFJL0csUUFBUSxJQUFJLENBQUNvUyxRQUFRLENBQUMsU0FBU3JMLFNBQVMsQ0FBQztRQUM3QyxJQUFJOUcsU0FBUyxJQUFJLENBQUNtUyxRQUFRLENBQUMsVUFBVXJMLFNBQVMsQ0FBQztRQUUvQyxJQUFJLENBQUNxeEIsVUFBVSxDQUFDSyxTQUFTLENBQUN6NEIsU0FBUyxDQUFDQyxRQUFRO1lBQzFDO1FBQ0Y7UUFFQWlJLElBQUk4USxJQUFJO1FBQ1I5USxJQUFJb0ksU0FBUyxDQUFDNUcsR0FBR0M7UUFFakIsSUFBSSxJQUFJLENBQUMydUIsS0FBSyxFQUFFO1lBQ2QsSUFBSVMsY0FBYzd6QixVQUFTOHpCLEtBQUssQ0FBQ0MsVUFBVSxDQUFDL3dCLEtBQUssSUFBSSxDQUFDdXdCLEtBQUssRUFBRTtnQkFDM0QzNEIsYUFBYTtnQkFDYkQsaUJBQWlCO2dCQUNqQnFSLGtCQUFrQjtnQkFDbEJDLGFBQWE7Z0JBQ2JJLFNBQVM7Z0JBQ1RDLFNBQVM7Z0JBQ1RILFlBQVlyUjtnQkFDWnNSLGFBQWFyUjtZQUNmO1lBQ0E4NEIsWUFBWTd6QixRQUFRLENBQUNnMEIsZUFBZSxDQUFDcnRCLE1BQU0sR0FBRyxJQUFJO1lBQ2xELEtBQUtrdEIsWUFBWXRuQixNQUFNO1FBQ3pCLE9BQU87WUFDTCxJQUFJMG5CLFNBQVMsSUFBSSxDQUFDVixLQUFLO1lBQ3ZCdnpCLFVBQVMySixVQUFVLENBQUM7Z0JBQ2xCM0c7Z0JBQ0E0RyxhQUFhLElBQUksQ0FBQ3hHLFlBQVksQ0FBQyx1QkFBdUI5QyxTQUFTO2dCQUMvRHhGO2dCQUNBK08sY0FBY29xQixPQUFPbjVCLEtBQUs7Z0JBQzFCQztnQkFDQStPLGVBQWVtcUIsT0FBT2w1QixNQUFNO1lBQzlCO1lBRUEsSUFBSSxJQUFJLENBQUNtNEIsTUFBTSxFQUFFO2dCQUNmLElBQUksT0FBT2UsT0FBT0MsUUFBUSxLQUFLLGVBQWVELE9BQU9DLFFBQVEsRUFBRTtvQkFDN0RseEIsSUFBSW14QixTQUFTLENBQUNGLFFBQVEsR0FBRztnQkFDM0I7WUFDRjtRQUNGO1FBRUFqeEIsSUFBSXFSLE9BQU87SUFDYjtJQUVBc0ssaUJBQWlCO1FBQ2YsSUFBSW5hLElBQUksSUFBSSxDQUFDcEIsWUFBWSxDQUFDLEtBQUt2QixTQUFTLENBQUM7UUFDekMsSUFBSTRDLElBQUksSUFBSSxDQUFDckIsWUFBWSxDQUFDLEtBQUt2QixTQUFTLENBQUM7UUFDekMsSUFBSS9HLFFBQVEsSUFBSSxDQUFDb1MsUUFBUSxDQUFDLFNBQVNyTCxTQUFTLENBQUM7UUFDN0MsSUFBSTlHLFNBQVMsSUFBSSxDQUFDbVMsUUFBUSxDQUFDLFVBQVVyTCxTQUFTLENBQUM7UUFDL0MsT0FBTyxJQUFJcVYsWUFBWTFTLEdBQUdDLEdBQUdELElBQUkxSixPQUFPMkosSUFBSTFKO0lBQzlDO0FBRUY7QUFFQSxNQUFNcTVCLHNCQUFzQmpaO0lBQzFCcGIsYUFBYztRQUNaLEtBQUssSUFBSXpGO1FBQ1QsSUFBSSxDQUFDc04sSUFBSSxHQUFHO0lBQ2Q7SUFFQTJFLE9BQU9uRCxDQUFDLEVBQUUsQ0FDVjtBQUVGO0FBRUEsTUFBTWlyQjtJQUNKdDBCLFlBQVlDLFNBQVEsQ0FBRTtRQUNwQixJQUFJLENBQUNBLFFBQVEsR0FBR0E7UUFDaEIsSUFBSSxDQUFDa3pCLE1BQU0sR0FBRztRQUNkbHpCLFVBQVNzMEIsS0FBSyxDQUFDcHdCLElBQUksQ0FBQyxJQUFJO0lBQzFCO0lBRUFxSyxLQUFLcUgsVUFBVSxFQUFFMWEsR0FBRyxFQUFFO1FBQ3BCLElBQUltVCxRQUFRLElBQUk7UUFFaEIsT0FBT3hVLG9FQUFpQkEsQ0FBQztZQUN2QixJQUFJO2dCQUNGLElBQUksRUFDRm1HLFVBQUFBLFNBQVEsRUFDVCxHQUFHcU87Z0JBQ0osSUFBSWttQixjQUFjLE1BQU12MEIsVUFBUzh6QixLQUFLLENBQUNybEIsTUFBTSxDQUFDRixJQUFJLENBQUNyVDtnQkFDbkQsSUFBSW81QixRQUFRQyxZQUFZMWxCLG9CQUFvQixDQUFDO2dCQUM3QzhELE1BQU1DLElBQUksQ0FBQzBoQixPQUFPN3RCLE9BQU8sQ0FBQyt0QixDQUFBQTtvQkFDeEIsSUFBSTdkLE9BQU8zVyxVQUFTd1UsYUFBYSxDQUFDZ2dCO29CQUNsQ3gwQixVQUFTMkMsV0FBVyxDQUFDaVQsV0FBVyxHQUFHZTtnQkFDckM7WUFDRixFQUFFLE9BQU9oSSxLQUFLO2dCQUNaNmtCLFFBQVFDLEtBQUssQ0FBQyw2QkFBOEJybUIsTUFBTSxDQUFDbFMsS0FBSyxPQUFReVQ7WUFDbEU7WUFFQU4sTUFBTTZrQixNQUFNLEdBQUc7UUFDakI7SUFDRjtBQUVGO0FBRUEsTUFBTXVCLHFCQUFxQnhpQjtJQUN6QmxTLFlBQVlDLFNBQVEsRUFBRXRFLElBQUksRUFBRXdXLGdCQUFnQixDQUFFO1FBQzVDLEtBQUssQ0FBQ2xTLFdBQVV0RSxNQUFNd1c7UUFDdEIsSUFBSSxDQUFDdEssSUFBSSxHQUFHO1FBQ1osSUFBSThzQixNQUFNeDRCLGVBQWV5VyxNQUFNQyxJQUFJLENBQUNsWCxLQUFLdVgsVUFBVSxFQUFFLFlBQVk7U0FDaEV2VyxHQUFHLENBQUMwTSxDQUFBQSxJQUFLQSxFQUFFMkYsV0FBVyxFQUFFblEsSUFBSSxDQUFDLElBQUl4QyxPQUFPLENBQUMsa0VBQWtFLElBQUksa0JBQWtCO1NBQ2pJQSxPQUFPLENBQUMsZUFBZSxJQUFJLGlCQUFpQjs7UUFFN0MsSUFBSXU0QixVQUFVRCxJQUFJdDBCLEtBQUssQ0FBQztRQUN4QnUwQixRQUFRbHVCLE9BQU8sQ0FBQzJDLENBQUFBO1lBQ2QsSUFBSWpJLE1BQU1pSSxFQUFFN0ksSUFBSTtZQUVoQixJQUFJLENBQUNZLEtBQUs7Z0JBQ1I7WUFDRjtZQUVBLElBQUl5ekIsV0FBV3p6QixJQUFJZixLQUFLLENBQUM7WUFDekIsSUFBSXkwQixhQUFhRCxRQUFRLENBQUMsRUFBRSxDQUFDeDBCLEtBQUssQ0FBQztZQUNuQyxJQUFJMDBCLFdBQVdGLFFBQVEsQ0FBQyxFQUFFLENBQUN4MEIsS0FBSyxDQUFDO1lBQ2pDeTBCLFdBQVdwdUIsT0FBTyxDQUFDMkMsQ0FBQUE7Z0JBQ2pCLElBQUkyckIsV0FBVzNyQixFQUFFN0ksSUFBSTtnQkFFckIsSUFBSSxDQUFDdzBCLFVBQVU7b0JBQ2I7Z0JBQ0Y7Z0JBRUEsSUFBSUMsUUFBUWgxQixVQUFTcVMsTUFBTSxDQUFDMGlCLFNBQVMsSUFBSSxDQUFDO2dCQUMxQ0QsU0FBU3J1QixPQUFPLENBQUN3dUIsQ0FBQUE7b0JBQ2YsSUFBSWxLLE9BQU9rSyxRQUFReGYsT0FBTyxDQUFDO29CQUMzQixJQUFJM1ksT0FBT200QixRQUFRQyxNQUFNLENBQUMsR0FBR25LLE1BQU14cUIsSUFBSTtvQkFDdkMsSUFBSU4sUUFBUWcxQixRQUFRQyxNQUFNLENBQUNuSyxPQUFPLEdBQUdrSyxRQUFRMTZCLE1BQU0sR0FBR3d3QixNQUFNeHFCLElBQUk7b0JBRWhFLElBQUl6RCxRQUFRbUQsT0FBTzt3QkFDakIrMEIsS0FBSyxDQUFDbDRCLEtBQUssR0FBRyxJQUFJZ0QsU0FBU0UsV0FBVWxELE1BQU1tRDtvQkFDN0M7Z0JBQ0Y7Z0JBQ0FELFVBQVNxUyxNQUFNLENBQUMwaUIsU0FBUyxHQUFHQztnQkFDNUJoMUIsVUFBU3NTLGlCQUFpQixDQUFDeWlCLFNBQVMsR0FBR3YyQix1QkFBdUJ1MkI7Z0JBRTlELElBQUlBLGFBQWEsY0FBYztvQkFDN0IsZUFBZTtvQkFDZixJQUFJbmYsYUFBYW9mLEtBQUssQ0FBQyxjQUFjLENBQUMxMEIsU0FBUyxHQUFHbEUsT0FBTyxDQUFDLFFBQVE7b0JBQ2xFLElBQUkrNEIsT0FBT0gsTUFBTUksR0FBRyxDQUFDOTBCLFNBQVMsR0FBR0YsS0FBSyxDQUFDO29CQUN2QyswQixLQUFLMXVCLE9BQU8sQ0FBQzJ1QixDQUFBQTt3QkFDWCxJQUFJQSxJQUFJM2YsT0FBTyxDQUFDLG1CQUFtQixHQUFHOzRCQUNwQyxJQUFJdmEsTUFBTStCLGlCQUFpQm00Qjs0QkFFM0IsSUFBSWw2QixLQUFLO2dDQUNQLEtBQUssSUFBSW01QixjQUFjcjBCLFdBQVV1TyxJQUFJLENBQUNxSCxZQUFZMWE7NEJBQ3BEO3dCQUNGO29CQUNGO2dCQUNGO1lBQ0Y7UUFDRjtJQUNGO0FBRUY7QUFDQXU1QixhQUFheDNCLGdCQUFnQixHQUFHQTtBQUVoQyxNQUFNbzRCLG1CQUFtQmxhO0lBQ3ZCcGIsYUFBYztRQUNaLEtBQUssSUFBSXpGO1FBQ1QsSUFBSSxDQUFDc04sSUFBSSxHQUFHO0lBQ2Q7SUFFQXNNLFdBQVdsUixHQUFHLEVBQUU7UUFDZCxLQUFLLENBQUNrUixXQUFXbFI7UUFDakIsSUFBSTBoQixRQUFRLElBQUksQ0FBQ3RoQixZQUFZLENBQUM7UUFDOUIsSUFBSXVoQixRQUFRLElBQUksQ0FBQ3ZoQixZQUFZLENBQUM7UUFFOUIsSUFBSXNoQixNQUFNbGtCLFFBQVEsSUFBSTtZQUNwQndDLElBQUlvSSxTQUFTLENBQUNzWixNQUFNN2lCLFNBQVMsQ0FBQyxNQUFNO1FBQ3RDO1FBRUEsSUFBSThpQixNQUFNbmtCLFFBQVEsSUFBSTtZQUNwQndDLElBQUlvSSxTQUFTLENBQUMsR0FBR3VaLE1BQU05aUIsU0FBUyxDQUFDO1FBQ25DO0lBQ0Y7SUFFQW1ELEtBQUtoQyxHQUFHLEVBQUU7UUFDUixJQUFJLEVBQ0ZILE9BQU8sRUFDUixHQUFHLElBQUk7UUFFUixJQUFJQSxTQUFTO1lBQ1hBLFFBQVFtQyxJQUFJLENBQUNoQztRQUNmO0lBQ0Y7SUFFQW1SLGVBQWVuUixHQUFHLEVBQUU7UUFDbEIsSUFBSSxFQUNGaEQsVUFBQUEsU0FBUSxFQUNSNkMsT0FBTyxFQUNSLEdBQUcsSUFBSTtRQUVSLElBQUlBLFNBQVM7WUFDWCxJQUFJeXlCLFVBQVV6eUI7WUFFZCxJQUFJQSxRQUFRK0UsSUFBSSxLQUFLLFVBQVU7Z0JBQzdCLDRHQUE0RztnQkFDNUcwdEIsVUFBVSxJQUFJaFEsV0FBV3RsQixXQUFVO2dCQUNuQ3MxQixRQUFRbmpCLFVBQVUsQ0FBQzFFLE9BQU8sR0FBRyxJQUFJM04sU0FBU0UsV0FBVSxXQUFXNkMsUUFBUU8sWUFBWSxDQUFDLFdBQVc5QyxTQUFTO2dCQUN4R2cxQixRQUFRbmpCLFVBQVUsQ0FBQzZULG1CQUFtQixHQUFHLElBQUlsbUIsU0FBU0UsV0FBVSx1QkFBdUI2QyxRQUFRTyxZQUFZLENBQUMsdUJBQXVCOUMsU0FBUztnQkFDNUlnMUIsUUFBUW5qQixVQUFVLENBQUM2VixRQUFRLEdBQUcsSUFBSWxvQixTQUFTRSxXQUFVLFlBQVk2QyxRQUFRTyxZQUFZLENBQUMsWUFBWTlDLFNBQVM7Z0JBQzNHZzFCLFFBQVE3aUIsUUFBUSxHQUFHNVAsUUFBUTRQLFFBQVEsRUFBRSw4Q0FBOEM7Z0JBRW5GNVAsUUFBUXdQLE1BQU0sQ0FBQ3ZQLE9BQU8sR0FBRyxJQUFJaEQsU0FBU0UsV0FBVSxXQUFXLElBQUksQ0FBQ3FiLGdCQUFnQjtZQUNsRjtZQUVBLElBQUlpYSxRQUFRMXRCLElBQUksS0FBSyxPQUFPO2dCQUMxQixJQUFJcUYsYUFBYSxJQUFJLENBQUNDLFFBQVEsQ0FBQyxTQUFTLE9BQU87Z0JBQy9DLElBQUlDLGNBQWMsSUFBSSxDQUFDRCxRQUFRLENBQUMsVUFBVSxPQUFPLE9BQU8saURBQWlEO2dCQUV6RyxJQUFJRCxXQUFXek0sUUFBUSxJQUFJO29CQUN6QjgwQixRQUFRbmpCLFVBQVUsQ0FBQ3JYLEtBQUssR0FBRyxJQUFJZ0YsU0FBU0UsV0FBVSxTQUFTaU4sV0FBVzNNLFNBQVM7Z0JBQ2pGO2dCQUVBLElBQUk2TSxZQUFZM00sUUFBUSxJQUFJO29CQUMxQjgwQixRQUFRbmpCLFVBQVUsQ0FBQ3BYLE1BQU0sR0FBRyxJQUFJK0UsU0FBU0UsV0FBVSxVQUFVbU4sWUFBWTdNLFNBQVM7Z0JBQ3BGO1lBQ0Y7WUFFQSxJQUFJaTFCLFlBQVlELFFBQVEzdUIsTUFBTTtZQUM5QjJ1QixRQUFRM3VCLE1BQU0sR0FBRyxJQUFJO1lBQ3JCMnVCLFFBQVEvb0IsTUFBTSxDQUFDdko7WUFDZnN5QixRQUFRM3VCLE1BQU0sR0FBRzR1QjtRQUNuQjtJQUNGO0lBRUE1VyxlQUFlM2IsR0FBRyxFQUFFO1FBQ2xCLElBQUksRUFDRkgsT0FBTyxFQUNSLEdBQUcsSUFBSTtRQUVSLElBQUlBLFNBQVM7WUFDWCxPQUFPQSxRQUFROGIsY0FBYyxDQUFDM2I7UUFDaEM7UUFFQSxPQUFPO0lBQ1Q7SUFFQXd5QixtQkFBbUI7UUFDakIsSUFBSSxFQUNGeDFCLFVBQUFBLFNBQVEsRUFDUjZDLE9BQU8sRUFDUixHQUFHLElBQUk7UUFDUixPQUFPME8sVUFBVUssV0FBVyxDQUFDNVIsV0FBVTZDO0lBQ3pDO0lBRUEsSUFBSUEsVUFBVTtRQUNaLElBQUksQ0FBQyxJQUFJLENBQUM0eUIsYUFBYSxFQUFFO1lBQ3ZCLElBQUksQ0FBQ0EsYUFBYSxHQUFHLElBQUksQ0FBQ3Z5QixnQkFBZ0IsR0FBR1IsYUFBYTtRQUM1RDtRQUVBLE9BQU8sSUFBSSxDQUFDK3lCLGFBQWE7SUFDM0I7QUFFRjtBQUVBLFNBQVNDLE1BQU1wNkIsR0FBRyxFQUFFa0osQ0FBQyxFQUFFQyxDQUFDLEVBQUUzSixLQUFLLEVBQUU2NkIsT0FBTyxFQUFFQyxJQUFJO0lBQzVDLE9BQU90NkIsR0FBRyxDQUFDbUosSUFBSTNKLFFBQVEsSUFBSTBKLElBQUksSUFBSW94QixLQUFLO0FBQzFDO0FBRUEsU0FBU0MsTUFBTXY2QixHQUFHLEVBQUVrSixDQUFDLEVBQUVDLENBQUMsRUFBRTNKLEtBQUssRUFBRTY2QixPQUFPLEVBQUVDLElBQUksRUFBRUUsR0FBRztJQUNqRHg2QixHQUFHLENBQUNtSixJQUFJM0osUUFBUSxJQUFJMEosSUFBSSxJQUFJb3hCLEtBQUssR0FBR0U7QUFDdEM7QUFFQSxTQUFTdEUsRUFBRWpoQixNQUFNLEVBQUU3TSxDQUFDLEVBQUUzRSxDQUFDO0lBQ3JCLElBQUlnM0IsS0FBS3hsQixNQUFNLENBQUM3TSxFQUFFO0lBQ2xCLE9BQU9xeUIsS0FBS2gzQjtBQUNkO0FBRUEsU0FBUzJSLEVBQUVGLENBQUMsRUFBRXdsQixFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRTtJQUN0QixPQUFPRixLQUFLcDRCLEtBQUtzUyxHQUFHLENBQUNNLEtBQUt5bEIsS0FBS3I0QixLQUFLdVMsR0FBRyxDQUFDSyxLQUFLMGxCO0FBQy9DO0FBRUEsTUFBTUMsNkJBQTZCbGtCO0lBQ2pDbFMsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJMkksU0FBU2hVLFVBQVUsSUFBSSxDQUFDNkcsWUFBWSxDQUFDLFVBQVU5QyxTQUFTO1FBRTVELE9BQVEsSUFBSSxDQUFDOEMsWUFBWSxDQUFDLFFBQVE5QyxTQUFTLENBQUM7WUFDMUMsNkRBQTZEO1lBQzdELEtBQUs7Z0JBQ0g7b0JBQ0UsSUFBSW1nQixJQUFJbFEsTUFBTSxDQUFDLEVBQUU7b0JBQ2pCLHdDQUF3QyxHQUV4Q0EsU0FBUzt3QkFBQyxRQUFRLFFBQVFrUTt3QkFBRyxRQUFRLFFBQVFBO3dCQUFHLFFBQVEsUUFBUUE7d0JBQUc7d0JBQUc7d0JBQUcsUUFBUSxRQUFRQTt3QkFBRyxRQUFRLFFBQVFBO3dCQUFHLFFBQVEsUUFBUUE7d0JBQUc7d0JBQUc7d0JBQUcsUUFBUSxRQUFRQTt3QkFBRyxRQUFRLFFBQVFBO3dCQUFHLFFBQVEsUUFBUUE7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7d0JBQUc7cUJBQUU7b0JBR3BPO2dCQUNGO1lBRUYsS0FBSztnQkFDSDtvQkFDRSxJQUFJalEsSUFBSUQsTUFBTSxDQUFDLEVBQUUsR0FBRzNTLEtBQUs2RSxFQUFFLEdBQUc7b0JBQzlCLHdDQUF3QyxHQUV4QzhOLFNBQVM7d0JBQUNHLEVBQUVGLEdBQUcsT0FBTyxPQUFPLENBQUM7d0JBQVFFLEVBQUVGLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQzt3QkFBUUUsRUFBRUYsR0FBRyxPQUFPLENBQUMsT0FBTzt3QkFBUTt3QkFBRzt3QkFBR0UsRUFBRUYsR0FBRyxPQUFPLENBQUMsT0FBTzt3QkFBUUUsRUFBRUYsR0FBRyxPQUFPLE9BQU87d0JBQVFFLEVBQUVGLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQzt3QkFBUTt3QkFBRzt3QkFBR0UsRUFBRUYsR0FBRyxPQUFPLENBQUMsT0FBTyxDQUFDO3dCQUFRRSxFQUFFRixHQUFHLE9BQU8sQ0FBQyxPQUFPO3dCQUFRRSxFQUFFRixHQUFHLE9BQU8sT0FBTzt3QkFBUTt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRzt3QkFBRztxQkFBRTtvQkFHdFQ7Z0JBQ0Y7WUFFRixLQUFLO2dCQUNILHdDQUF3QyxHQUN4Q0QsU0FBUztvQkFBQztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBUTtvQkFBUTtvQkFBUTtvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztvQkFBRztpQkFBRTtnQkFHbkc7UUFDSjtRQUVBLElBQUksQ0FBQ0EsTUFBTSxHQUFHQTtRQUNkLElBQUksQ0FBQzZsQixjQUFjLEdBQUcsSUFBSSxDQUFDaHpCLFlBQVksQ0FBQyxrQkFBa0I1QyxRQUFRO0lBQ3BFO0lBRUEyTyxNQUFNbk0sR0FBRyxFQUFFcXpCLEVBQUUsRUFBRUMsRUFBRSxFQUFFeDdCLEtBQUssRUFBRUMsTUFBTSxFQUFFO1FBQ2hDLGdDQUFnQztRQUNoQyxJQUFJLEVBQ0ZxN0IsY0FBYyxFQUNkN2xCLE1BQU0sRUFDUCxHQUFHLElBQUk7UUFDUixJQUFJZ21CLFVBQVV2ekIsSUFBSXd6QixZQUFZLENBQUMsR0FBRyxHQUFHMTdCLE9BQU9DO1FBRTVDLElBQUssSUFBSTBKLElBQUksR0FBR0EsSUFBSTFKLFFBQVEwSixJQUFLO1lBQy9CLElBQUssSUFBSUQsSUFBSSxHQUFHQSxJQUFJMUosT0FBTzBKLElBQUs7Z0JBQzlCLElBQUl5YyxJQUFJeVUsTUFBTWEsUUFBUTlrQixJQUFJLEVBQUVqTixHQUFHQyxHQUFHM0osT0FBT0MsUUFBUTtnQkFDakQsSUFBSThWLElBQUk2a0IsTUFBTWEsUUFBUTlrQixJQUFJLEVBQUVqTixHQUFHQyxHQUFHM0osT0FBT0MsUUFBUTtnQkFDakQsSUFBSTBWLElBQUlpbEIsTUFBTWEsUUFBUTlrQixJQUFJLEVBQUVqTixHQUFHQyxHQUFHM0osT0FBT0MsUUFBUTtnQkFDakQsSUFBSXlWLElBQUlrbEIsTUFBTWEsUUFBUTlrQixJQUFJLEVBQUVqTixHQUFHQyxHQUFHM0osT0FBT0MsUUFBUTtnQkFDakQsSUFBSTA3QixLQUFLakYsRUFBRWpoQixRQUFRLEdBQUcwUSxLQUFLdVEsRUFBRWpoQixRQUFRLEdBQUdNLEtBQUsyZ0IsRUFBRWpoQixRQUFRLEdBQUdFLEtBQUsrZ0IsRUFBRWpoQixRQUFRLEdBQUdDLEtBQUtnaEIsRUFBRWpoQixRQUFRLEdBQUc7Z0JBQzlGLElBQUltbUIsS0FBS2xGLEVBQUVqaEIsUUFBUSxHQUFHMFEsS0FBS3VRLEVBQUVqaEIsUUFBUSxHQUFHTSxLQUFLMmdCLEVBQUVqaEIsUUFBUSxHQUFHRSxLQUFLK2dCLEVBQUVqaEIsUUFBUSxHQUFHQyxLQUFLZ2hCLEVBQUVqaEIsUUFBUSxHQUFHO2dCQUM5RixJQUFJb21CLEtBQUtuRixFQUFFamhCLFFBQVEsSUFBSTBRLEtBQUt1USxFQUFFamhCLFFBQVEsSUFBSU0sS0FBSzJnQixFQUFFamhCLFFBQVEsSUFBSUUsS0FBSytnQixFQUFFamhCLFFBQVEsSUFBSUMsS0FBS2doQixFQUFFamhCLFFBQVEsSUFBSTtnQkFDbkcsSUFBSXFtQixLQUFLcEYsRUFBRWpoQixRQUFRLElBQUkwUSxLQUFLdVEsRUFBRWpoQixRQUFRLElBQUlNLEtBQUsyZ0IsRUFBRWpoQixRQUFRLElBQUlFLEtBQUsrZ0IsRUFBRWpoQixRQUFRLElBQUlDLEtBQUtnaEIsRUFBRWpoQixRQUFRLElBQUk7Z0JBRW5HLElBQUk2bEIsZ0JBQWdCO29CQUNsQkssS0FBSztvQkFDTEMsS0FBSztvQkFDTEMsS0FBSztvQkFDTEMsTUFBTXBtQixJQUFJO2dCQUNaO2dCQUVBcWxCLE1BQU1VLFFBQVE5a0IsSUFBSSxFQUFFak4sR0FBR0MsR0FBRzNKLE9BQU9DLFFBQVEsR0FBRzA3QjtnQkFDNUNaLE1BQU1VLFFBQVE5a0IsSUFBSSxFQUFFak4sR0FBR0MsR0FBRzNKLE9BQU9DLFFBQVEsR0FBRzI3QjtnQkFDNUNiLE1BQU1VLFFBQVE5a0IsSUFBSSxFQUFFak4sR0FBR0MsR0FBRzNKLE9BQU9DLFFBQVEsR0FBRzQ3QjtnQkFDNUNkLE1BQU1VLFFBQVE5a0IsSUFBSSxFQUFFak4sR0FBR0MsR0FBRzNKLE9BQU9DLFFBQVEsR0FBRzY3QjtZQUM5QztRQUNGO1FBRUE1ekIsSUFBSWdMLFNBQVMsQ0FBQyxHQUFHLEdBQUdsVCxPQUFPQztRQUMzQmlJLElBQUk2ekIsWUFBWSxDQUFDTixTQUFTLEdBQUc7SUFDL0I7QUFFRjtBQUVBLE1BQU1PLG9CQUFvQjdrQjtJQUN4QmxTLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUF1SCxNQUFNbk0sR0FBRyxFQUFFSCxPQUFPLEVBQUU7UUFDbEIsSUFBSSxFQUNGN0MsVUFBQUEsU0FBUSxFQUNULEdBQUcsSUFBSSxFQUFFLHFCQUFxQjtRQUUvQixJQUFJd0UsSUFBSSxJQUFJLENBQUNwQixZQUFZLENBQUMsS0FBS3ZCLFNBQVMsQ0FBQztRQUN6QyxJQUFJNEMsSUFBSSxJQUFJLENBQUNyQixZQUFZLENBQUMsS0FBS3ZCLFNBQVMsQ0FBQztRQUN6QyxJQUFJL0csUUFBUSxJQUFJLENBQUNvUyxRQUFRLENBQUMsU0FBU3JMLFNBQVMsQ0FBQztRQUM3QyxJQUFJOUcsU0FBUyxJQUFJLENBQUNtUyxRQUFRLENBQUMsVUFBVXJMLFNBQVMsQ0FBQztRQUUvQyxJQUFJLENBQUMvRyxTQUFTLENBQUNDLFFBQVE7WUFDckIsSUFBSWlNLGNBQWMsSUFBSWtRO1lBQ3RCLElBQUksQ0FBQ3pFLFFBQVEsQ0FBQ2hNLE9BQU8sQ0FBQzhOLENBQUFBO2dCQUNwQnZOLFlBQVk0USxjQUFjLENBQUNyRCxNQUFNb0ssY0FBYyxDQUFDM2I7WUFDbEQ7WUFDQXdCLElBQUk1RyxLQUFLd3RCLEtBQUssQ0FBQ3BrQixZQUFZbVEsRUFBRTtZQUM3QjFTLElBQUk3RyxLQUFLd3RCLEtBQUssQ0FBQ3BrQixZQUFZc1EsRUFBRTtZQUM3QnhjLFFBQVE4QyxLQUFLd3RCLEtBQUssQ0FBQ3BrQixZQUFZbE0sS0FBSztZQUNwQ0MsU0FBUzZDLEtBQUt3dEIsS0FBSyxDQUFDcGtCLFlBQVlqTSxNQUFNO1FBQ3hDO1FBRUEsSUFBSWc4QixnQkFBZ0IsSUFBSSxDQUFDN2hCLFlBQVksQ0FBQ3JTLFNBQVNpMEIsWUFBWTNoQixZQUFZO1FBQ3ZFLElBQUk2aEIsYUFBYWgzQixVQUFTbkYsWUFBWSxDQUFDMkosSUFBSTFKLE9BQU8ySixJQUFJMUo7UUFDdEQsSUFBSWs4QixVQUFVRCxXQUFXdFAsVUFBVSxDQUFDO1FBQ3BDMW5CLFVBQVNtQyxNQUFNLENBQUNtSCxXQUFXLENBQUMydEI7UUFDNUIsSUFBSSxDQUFDOWlCLGNBQWMsQ0FBQzhpQixVQUFVLHlDQUF5QztRQUN2RSw4Q0FBOEM7UUFFOUMsSUFBSWQscUJBQXFCbjJCLFdBQVU7WUFDakMwUyxVQUFVO1lBQ1ZPLFlBQVksRUFBRTtZQUNkZCxZQUFZO2dCQUFDO29CQUNYVyxVQUFVO29CQUNWN1MsT0FBTztnQkFDVDtnQkFBRztvQkFDRDZTLFVBQVU7b0JBQ1Y3UyxPQUFPO2dCQUNUO2FBQUU7UUFDSixHQUFHa1AsS0FBSyxDQUFDOG5CLFNBQVMsR0FBRyxHQUFHenlCLElBQUkxSixPQUFPMkosSUFBSTFKO1FBQ3ZDLElBQUltOEIsWUFBWWwzQixVQUFTbkYsWUFBWSxDQUFDMkosSUFBSTFKLE9BQU8ySixJQUFJMUo7UUFDckQsSUFBSW84QixTQUFTRCxVQUFVeFAsVUFBVSxDQUFDO1FBQ2xDMW5CLFVBQVNtQyxNQUFNLENBQUNtSCxXQUFXLENBQUM2dEI7UUFDNUJ0MEIsUUFBUTBKLE1BQU0sQ0FBQzRxQjtRQUNmQSxPQUFPQyx3QkFBd0IsR0FBRztRQUNsQ0QsT0FBT3ZiLFNBQVMsR0FBR3FiLFFBQVFoMEIsYUFBYSxDQUFDK3pCLFlBQVk7UUFDckRHLE9BQU9FLFFBQVEsQ0FBQyxHQUFHLEdBQUc3eUIsSUFBSTFKLE9BQU8ySixJQUFJMUo7UUFDckNpSSxJQUFJNFksU0FBUyxHQUFHdWIsT0FBT2wwQixhQUFhLENBQUNpMEIsV0FBVztRQUNoRGwwQixJQUFJcTBCLFFBQVEsQ0FBQyxHQUFHLEdBQUc3eUIsSUFBSTFKLE9BQU8ySixJQUFJMUosU0FBUyxnQkFBZ0I7UUFFM0QsSUFBSSxDQUFDdWEsYUFBYSxDQUFDelMsU0FBU2swQjtJQUM5QjtJQUVBeHFCLE9BQU9uRCxDQUFDLEVBQUUsQ0FDVjtBQUVGO0FBQ0EwdEIsWUFBWTNoQixZQUFZLEdBQUc7SUFBQztJQUFRO0lBQWE7Q0FBWTtBQUU3RCxJQUFJbWlCLE9BQU8sS0FDWDtBQUVBLE1BQU1DLHdCQUF3QnRsQjtJQUM1QmxTLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUF1SCxNQUFNbk0sR0FBRyxFQUFFO1FBQ1QsSUFBSSxFQUNGaEQsVUFBQUEsU0FBUSxFQUNULEdBQUcsSUFBSTtRQUNSLElBQUl3M0IsZUFBZWg4QixRQUFRaThCLGNBQWMsQ0FBQ3owQjtRQUMxQyxJQUFJLEVBQ0Z1SSxTQUFTLEVBQ1RHLFNBQVMsRUFDVixHQUFHMUk7UUFFSixJQUFJdzBCLGNBQWM7WUFDaEJBLGFBQWFqc0IsU0FBUyxHQUFHK3JCO1lBQ3pCRSxhQUFhOXJCLFNBQVMsR0FBRzRyQjtRQUMzQjtRQUVBOTdCLFFBQVEyVCxLQUFLLENBQUM1RCxXQUFXdkksS0FBSyxFQUFFO1FBQ2hDLElBQUksQ0FBQ3lQLFFBQVEsQ0FBQ2hNLE9BQU8sQ0FBQzhOLENBQUFBO1lBQ3BCLElBQUksT0FBT0EsTUFBTXZQLElBQUksS0FBSyxhQUFhO2dCQUNyQztZQUNGO1lBRUEsSUFBSU0sWUFBWSxPQUFPaVAsTUFBTWloQixnQkFBZ0IsS0FBSyxjQUFjamhCLE1BQU1paEIsZ0JBQWdCLEtBQUssTUFBTSxpQkFBaUI7WUFFbEgsSUFBSSxDQUFDbHdCLFdBQVc7Z0JBQ2RBLFlBQVlpTSxVQUFVSyxXQUFXLENBQUM1UixXQUFVdVU7WUFDOUM7WUFFQSxJQUFJalAsV0FBVztnQkFDYkEsVUFBVTZKLEtBQUssQ0FBQ25NO1lBQ2xCO1lBRUF1UixNQUFNdlAsSUFBSSxDQUFDaEM7WUFFWCxJQUFJdzBCLGNBQWM7Z0JBQ2hCQSxhQUFhOXJCLFNBQVMsR0FBR0E7WUFDM0I7WUFFQSxJQUFJcEcsV0FBVztnQkFDYkEsVUFBVThKLE9BQU8sQ0FBQ3BNO1lBQ3BCO1FBQ0Y7UUFDQXhILFFBQVEyVCxLQUFLLENBQUN6RCxXQUFXMUksS0FBSyxFQUFFO1FBQ2hDQSxJQUFJbUgsSUFBSTtRQUVSLElBQUlxdEIsY0FBYztZQUNoQkEsYUFBYWpzQixTQUFTLEdBQUdBO1lBQ3pCaXNCLGFBQWE5ckIsU0FBUyxHQUFHQTtRQUMzQjtJQUNGO0lBRUFhLE9BQU9uRCxDQUFDLEVBQUUsQ0FDVjtBQUVGO0FBRUEsTUFBTXN1QixzQkFBc0J6bEI7SUFDMUJsUyxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtJQUVBdUgsTUFBTW5NLEdBQUcsRUFBRUgsT0FBTyxFQUFFO1FBQ2xCLHFCQUFxQjtRQUNyQixJQUFJLEVBQ0Y3QyxVQUFBQSxTQUFRLEVBQ1J5UyxRQUFRLEVBQ1QsR0FBRyxJQUFJO1FBQ1IsSUFBSXpMLGNBQWNuRSxRQUFROGIsY0FBYyxDQUFDM2I7UUFFekMsSUFBSSxDQUFDZ0UsYUFBYTtZQUNoQjtRQUNGO1FBRUEsSUFBSTJ3QixLQUFLO1FBQ1QsSUFBSUMsS0FBSztRQUNUbmxCLFNBQVNoTSxPQUFPLENBQUM4TixDQUFBQTtZQUNmLElBQUlzakIsTUFBTXRqQixNQUFNdWpCLG1CQUFtQixJQUFJO1lBQ3ZDSCxLQUFLLzVCLEtBQUswRSxHQUFHLENBQUNxMUIsSUFBSUU7WUFDbEJELEtBQUtoNkIsS0FBSzBFLEdBQUcsQ0FBQ3MxQixJQUFJQztRQUNwQjtRQUNBLElBQUkvOEIsUUFBUThDLEtBQUt3dEIsS0FBSyxDQUFDcGtCLFlBQVlsTSxLQUFLO1FBQ3hDLElBQUlDLFNBQVM2QyxLQUFLd3RCLEtBQUssQ0FBQ3BrQixZQUFZak0sTUFBTTtRQUMxQyxJQUFJZzlCLGlCQUFpQmo5QixRQUFRLElBQUk2OEI7UUFDakMsSUFBSUssa0JBQWtCajlCLFNBQVMsSUFBSTY4QjtRQUVuQyxJQUFJRyxpQkFBaUIsS0FBS0Msa0JBQWtCLEdBQUc7WUFDN0M7UUFDRjtRQUVBLElBQUl4ekIsSUFBSTVHLEtBQUt3dEIsS0FBSyxDQUFDcGtCLFlBQVl4QyxDQUFDO1FBQ2hDLElBQUlDLElBQUk3RyxLQUFLd3RCLEtBQUssQ0FBQ3BrQixZQUFZdkMsQ0FBQztRQUNoQyxJQUFJc3lCLGdCQUFnQixJQUFJLENBQUM3aEIsWUFBWSxDQUFDclMsU0FBUzYwQixjQUFjdmlCLFlBQVk7UUFDekUsSUFBSStoQixZQUFZbDNCLFVBQVNuRixZQUFZLENBQUNrOUIsZ0JBQWdCQztRQUN0RCxJQUFJYixTQUFTRCxVQUFVeFAsVUFBVSxDQUFDO1FBQ2xDMW5CLFVBQVNtQyxNQUFNLENBQUNtSCxXQUFXLENBQUM2dEI7UUFDNUJBLE9BQU8vckIsU0FBUyxDQUFDLENBQUM1RyxJQUFJbXpCLElBQUksQ0FBQ2x6QixJQUFJbXpCO1FBQy9CLzBCLFFBQVEwSixNQUFNLENBQUM0cUIsU0FBUyxnQkFBZ0I7UUFFeEMxa0IsU0FBU2hNLE9BQU8sQ0FBQzhOLENBQUFBO1lBQ2YsSUFBSSxPQUFPQSxNQUFNcEYsS0FBSyxLQUFLLFlBQVk7Z0JBQ3JDb0YsTUFBTXBGLEtBQUssQ0FBQ2dvQixRQUFRLEdBQUcsR0FBR1ksZ0JBQWdCQztZQUM1QztRQUNGLElBQUksZUFBZTtRQUVuQmgxQixJQUFJbXhCLFNBQVMsQ0FBQytDLFdBQVcsR0FBRyxHQUFHYSxnQkFBZ0JDLGlCQUFpQnh6QixJQUFJbXpCLElBQUlsekIsSUFBSW16QixJQUFJRyxnQkFBZ0JDO1FBQ2hHLElBQUksQ0FBQzFpQixhQUFhLENBQUN6UyxTQUFTazBCO0lBQzlCO0lBRUF4cUIsT0FBT25ELENBQUMsRUFBRSxDQUNWO0FBRUY7QUFDQXN1QixjQUFjdmlCLFlBQVksR0FBRztJQUFDO0lBQVU7SUFBYTtDQUFZO0FBRWpFLE1BQU04aUIsNEJBQTRCaG1CO0lBQ2hDbFMsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUNtTCw0QkFBNEI7SUFDbkM7SUFFQTVELE1BQU0vRixDQUFDLEVBQUVpdEIsRUFBRSxFQUFFQyxFQUFFLEVBQUU0QixNQUFNLEVBQUV2QyxPQUFPLEVBQUUsQ0FDbEM7QUFFRjtBQUVBLE1BQU13Qyw0QkFBNEJsbUI7SUFDaENsUyxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtJQUVBdUgsTUFBTS9GLENBQUMsRUFBRWl0QixFQUFFLEVBQUVDLEVBQUUsRUFBRTRCLE1BQU0sRUFBRXZDLE9BQU8sRUFBRSxDQUNsQztBQUVGO0FBRUEsTUFBTXlDLDJCQUEyQm5tQjtJQUMvQmxTLGFBQWM7UUFDWixLQUFLLElBQUl6RjtRQUNULElBQUksQ0FBQ3NOLElBQUksR0FBRztJQUNkO0lBRUF1SCxNQUFNL0YsQ0FBQyxFQUFFaXRCLEVBQUUsRUFBRUMsRUFBRSxFQUFFNEIsTUFBTSxFQUFFdkMsT0FBTyxFQUFFLENBQ2xDO0FBRUY7QUFFQSxNQUFNMEMsOEJBQThCcG1CO0lBQ2xDbFMsWUFBWUMsU0FBUSxFQUFFdEUsSUFBSSxFQUFFd1csZ0JBQWdCLENBQUU7UUFDNUMsS0FBSyxDQUFDbFMsV0FBVXRFLE1BQU13VztRQUN0QixJQUFJLENBQUN0SyxJQUFJLEdBQUc7UUFDWixJQUFJLENBQUMwd0IsVUFBVSxHQUFHMTZCLEtBQUt3dEIsS0FBSyxDQUFDLElBQUksQ0FBQ2hvQixZQUFZLENBQUMsZ0JBQWdCaEMsU0FBUztRQUN4RSxJQUFJLENBQUMwMkIsbUJBQW1CLEdBQUcsSUFBSSxDQUFDUSxVQUFVO0lBQzVDO0lBRUFucEIsTUFBTW5NLEdBQUcsRUFBRXdCLENBQUMsRUFBRUMsQ0FBQyxFQUFFM0osS0FBSyxFQUFFQyxNQUFNLEVBQUU7UUFDOUIsSUFBSSxFQUNGaUYsVUFBQUEsU0FBUSxFQUNSczRCLFVBQVUsRUFDWCxHQUFHLElBQUk7UUFDUixJQUFJQyxPQUFPdjRCLFVBQVN0RixNQUFNLEdBQUdzRixVQUFTdEYsTUFBTSxDQUFDc0YsUUFBUSxDQUFDdTRCLElBQUksR0FBRztRQUM3RCxJQUFJMzhCLFNBQVNvSCxJQUFJcEgsTUFBTSxFQUFFLDJDQUEyQztRQUVwRUEsT0FBT29YLEVBQUUsR0FBR2hULFVBQVN3NEIsV0FBVztRQUVoQyxJQUFJRCxNQUFNO1lBQ1IzOEIsT0FBTzJLLEtBQUssQ0FBQ2t5QixPQUFPLEdBQUc7WUFDdkJGLEtBQUtHLFdBQVcsQ0FBQzk4QjtRQUNuQjtRQUVBMUIsNkRBQVVBLENBQUMwQixRQUFRNEksR0FBR0MsR0FBRzNKLE9BQU9DLFFBQVF1OUI7UUFFeEMsSUFBSUMsTUFBTTtZQUNSQSxLQUFLSSxXQUFXLENBQUMvOEI7UUFDbkI7SUFDRjtBQUVGO0FBRUEsTUFBTWc5QixxQkFBcUIzbUI7SUFDekJsUyxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtBQUVGO0FBRUEsTUFBTWl4QixvQkFBb0I1bUI7SUFDeEJsUyxhQUFjO1FBQ1osS0FBSyxJQUFJekY7UUFDVCxJQUFJLENBQUNzTixJQUFJLEdBQUc7SUFDZDtBQUVGO0FBRUEsSUFBSWt4QixXQUFXO0lBQ2IsT0FBT3hUO0lBQ1AsUUFBUWlCO0lBQ1IsVUFBVU07SUFDVixXQUFXQztJQUNYLFFBQVFDO0lBQ1IsWUFBWUk7SUFDWixXQUFXQztJQUNYLFFBQVEzSjtJQUNSLFdBQVc0SjtJQUNYLFVBQVVPO0lBQ1YsUUFBUUs7SUFDUixrQkFBa0JpQjtJQUNsQixrQkFBa0JHO0lBQ2xCLFFBQVFLO0lBQ1IsV0FBV0c7SUFDWCxnQkFBZ0IwQjtJQUNoQixvQkFBb0JHO0lBQ3BCLFFBQVFHO0lBQ1IsYUFBYUU7SUFDYixpQkFBaUJHO0lBQ2pCLFNBQVM1SztJQUNULFFBQVFJO0lBQ1IsU0FBUzBEO0lBQ1QsUUFBUStHO0lBQ1IsS0FBS0U7SUFDTCxZQUFZa0I7SUFDWixTQUFTMEY7SUFDVCxLQUFLL0s7SUFDTCxVQUFVa007SUFDVixTQUFTSztJQUNULE9BQU9ZO0lBQ1AsUUFBUXlCO0lBQ1IsWUFBWVM7SUFDWixVQUFVRztJQUNWLGdCQUFnQk87SUFDaEIsZ0JBQWdCRTtJQUNoQixlQUFlQztJQUNmLGlCQUFpQmpDO0lBQ2pCLGtCQUFrQmtDO0lBQ2xCLFNBQVNPO0lBQ1QsUUFBUUM7QUFDVjtBQUVBLFNBQVNFLFVBQVV0TSxNQUFNLEVBQUVDLGNBQWM7SUFBSSxJQUFJQyxPQUFPNXdCLE9BQU80d0IsSUFBSSxDQUFDRjtJQUFTLElBQUkxd0IsT0FBTzZ3QixxQkFBcUIsRUFBRTtRQUFFLElBQUlDLFVBQVU5d0IsT0FBTzZ3QixxQkFBcUIsQ0FBQ0g7UUFBUyxJQUFJQyxnQkFBZ0I7WUFBRUcsVUFBVUEsUUFBUTVZLE1BQU0sQ0FBQyxTQUFVNlksR0FBRztnQkFBSSxPQUFPL3dCLE9BQU9neEIsd0JBQXdCLENBQUNOLFFBQVFLLEtBQUtFLFVBQVU7WUFBRTtRQUFJO1FBQUVMLEtBQUt6b0IsSUFBSSxDQUFDaUwsS0FBSyxDQUFDd2QsTUFBTUU7SUFBVTtJQUFFLE9BQU9GO0FBQU07QUFFMVYsU0FBU3FNLGdCQUFnQjlMLE1BQU07SUFBSSxJQUFLLElBQUl4cEIsSUFBSSxHQUFHQSxJQUFJcEosVUFBVUMsTUFBTSxFQUFFbUosSUFBSztRQUFFLElBQUl5cEIsU0FBUzd5QixTQUFTLENBQUNvSixFQUFFLElBQUksT0FBT3BKLFNBQVMsQ0FBQ29KLEVBQUUsR0FBRyxDQUFDO1FBQUcsSUFBSUEsSUFBSSxHQUFHO1lBQUVxMUIsVUFBVWg5QixPQUFPb3hCLFNBQVMsTUFBTTFtQixPQUFPLENBQUMsU0FBVWlOLEdBQUc7Z0JBQUk1WixrRUFBZUEsQ0FBQ296QixRQUFReFosS0FBS3laLE1BQU0sQ0FBQ3paLElBQUk7WUFBRztRQUFJLE9BQU8sSUFBSTNYLE9BQU9xeEIseUJBQXlCLEVBQUU7WUFBRXJ4QixPQUFPc3hCLGdCQUFnQixDQUFDSCxRQUFRbnhCLE9BQU9xeEIseUJBQXlCLENBQUNEO1FBQVUsT0FBTztZQUFFNEwsVUFBVWg5QixPQUFPb3hCLFNBQVMxbUIsT0FBTyxDQUFDLFNBQVVpTixHQUFHO2dCQUFJM1gsT0FBT3V4QixjQUFjLENBQUNKLFFBQVF4WixLQUFLM1gsT0FBT2d4Qix3QkFBd0IsQ0FBQ0ksUUFBUXpaO1lBQU87UUFBSTtJQUFFO0lBQUUsT0FBT3daO0FBQVE7QUFFM2hCLFNBQVNyeUIsYUFBYUMsS0FBSyxFQUFFQyxNQUFNO0lBQ2pDLElBQUlhLFNBQVNvRSxTQUFTd1UsYUFBYSxDQUFDO0lBQ3BDNVksT0FBT2QsS0FBSyxHQUFHQTtJQUNmYyxPQUFPYixNQUFNLEdBQUdBO0lBQ2hCLE9BQU9hO0FBQ1Q7QUFFQSxTQUFTWCxZQUFZbzdCLEVBQUU7SUFDckIsT0FBTzRDLGFBQWE5cEIsS0FBSyxDQUFDLElBQUksRUFBRTdVO0FBQ2xDO0FBRUEsU0FBUzIrQjtJQUNQQSxlQUFlcC9CLG9FQUFpQkEsQ0FBQyxVQUFXdTdCLEdBQUc7UUFDN0MsSUFBSThELHVCQUF1QjUrQixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUMvRixJQUFJaTVCLFFBQVF2ekIsU0FBU3dVLGFBQWEsQ0FBQztRQUVuQyxJQUFJMGtCLHNCQUFzQjtZQUN4QjNGLE1BQU00RixXQUFXLEdBQUc7UUFDdEI7UUFFQSxPQUFPLElBQUlud0IsUUFBUSxDQUFDQyxTQUFTbXdCO1lBQzNCN0YsTUFBTThGLE1BQU0sR0FBRztnQkFDYnB3QixRQUFRc3FCO1lBQ1Y7WUFFQUEsTUFBTStGLE9BQU8sR0FBRyxDQUFDQyxRQUFRQyxTQUFTQyxTQUFTQyxRQUFRakc7Z0JBQ2pEMkYsT0FBTzNGO1lBQ1Q7WUFFQUYsTUFBTTZCLEdBQUcsR0FBR0E7UUFDZDtJQUNGO0lBQ0EsT0FBTzZELGFBQWE5cEIsS0FBSyxDQUFDLElBQUksRUFBRTdVO0FBQ2xDO0FBRUEsTUFBTXEvQjtJQUNKNTVCLFlBQVkrekIsS0FBSyxDQUFFO1FBQ2pCLElBQUksRUFDRnJ5QixhQUFhLEVBQUUsRUFDZkUsU0FBUyxFQUFFLEVBQ1g5RyxlQUFlOCtCLFNBQVM5K0IsWUFBWSxFQUNwQ0ksY0FBYzArQixTQUFTMStCLFdBQVcsRUFDbENpK0Isb0JBQW9CLEVBQ3JCLEdBQUc1K0IsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUN6RSxJQUFJLENBQUN3NUIsS0FBSyxHQUFHQTtRQUNiLElBQUksQ0FBQ254QixXQUFXLEdBQUc1RyxPQUFPcVcsTUFBTSxDQUFDO1FBQ2pDLElBQUksQ0FBQ0MsTUFBTSxHQUFHdFcsT0FBT3FXLE1BQU0sQ0FBQztRQUM1QixJQUFJLENBQUNFLGlCQUFpQixHQUFHdlcsT0FBT3FXLE1BQU0sQ0FBQztRQUN2QyxJQUFJLENBQUNpaEIsTUFBTSxHQUFHLEVBQUU7UUFDaEIsSUFBSSxDQUFDaUIsS0FBSyxHQUFHLEVBQUU7UUFDZixJQUFJLENBQUNzRixXQUFXLEdBQUcsRUFBRTtRQUNyQixJQUFJLENBQUNDLFFBQVEsR0FBRztRQUNoQixJQUFJLENBQUMxM0IsTUFBTSxHQUFHMnhCLE1BQU0zeEIsTUFBTTtRQUMxQixJQUFJLENBQUNWLFVBQVUsR0FBR0E7UUFDbEIsSUFBSSxDQUFDRSxNQUFNLEdBQUdBO1FBQ2QsSUFBSSxDQUFDOUcsWUFBWSxHQUFHQTtRQUNwQixJQUFJLENBQUNJLFdBQVcsR0FBRyxJQUFJLENBQUM2K0IsZUFBZSxDQUFDNytCLGFBQWFpK0I7UUFDckQsSUFBSSxDQUFDLzJCLE1BQU0sQ0FBQ3lHLElBQUksQ0FBQyxJQUFJLENBQUNteEIsY0FBYyxDQUFDajBCLElBQUksQ0FBQyxJQUFJO1FBQzlDLElBQUksQ0FBQzNELE1BQU0sQ0FBQ3lHLElBQUksQ0FBQyxJQUFJLENBQUNveEIsYUFBYSxDQUFDbDBCLElBQUksQ0FBQyxJQUFJO0lBQy9DO0lBRUFnMEIsZ0JBQWdCNytCLFdBQVcsRUFBRWkrQixvQkFBb0IsRUFBRTtRQUNqRCxJQUFJLE9BQU9BLHlCQUF5QixXQUFXO1lBQzdDLE9BQU8sQ0FBQy9MLFFBQVE4TSw0QkFBOEJoL0IsWUFBWWt5QixRQUFRLE9BQU84TSw4QkFBOEIsWUFBWUEsNEJBQTRCZjtRQUNqSjtRQUVBLE9BQU9qK0I7SUFDVDtJQUVBLElBQUlQLFNBQVM7UUFDWCxPQUFPLElBQUksQ0FBQ3lILE1BQU0sQ0FBQ3pILE1BQU07SUFDM0I7SUFFQSxJQUFJVSxRQUFRO1FBQ1YsT0FBTyxJQUFJLENBQUMrRyxNQUFNLENBQUMvRyxLQUFLO0lBQzFCO0lBRUEsSUFBSTRILE1BQU07UUFDUixPQUFPLElBQUksQ0FBQ2IsTUFBTSxDQUFDYSxHQUFHO0lBQ3hCO0lBRUEsSUFBSXJCLFNBQVM7UUFDWCxJQUFJLEVBQ0ZpNEIsV0FBVyxFQUNaLEdBQUcsSUFBSTtRQUNSLE9BQU9BLFdBQVcsQ0FBQ0EsWUFBWXIvQixNQUFNLEdBQUcsRUFBRTtJQUM1QztJQUVBLElBQUlvSCxPQUFPMUIsS0FBSyxFQUFFO1FBQ2hCLElBQUksRUFDRjI1QixXQUFXLEVBQ1osR0FBRyxJQUFJO1FBQ1JBLFlBQVkxMUIsSUFBSSxDQUFDakU7SUFDbkI7SUFFQXVkLFlBQVk7UUFDVixJQUFJLEVBQ0ZvYyxXQUFXLEVBQ1osR0FBRyxJQUFJO1FBQ1JBLFlBQVl4MUIsR0FBRztJQUNqQjtJQUVBbzBCLGNBQWM7UUFDWixPQUFPLFFBQVFwckIsTUFBTSxDQUFDLEVBQUUsSUFBSSxDQUFDeXNCLFFBQVE7SUFDdkM7SUFFQUUsaUJBQWlCO1FBQ2YsT0FBTyxJQUFJLENBQUMxRyxNQUFNLENBQUNscUIsS0FBSyxDQUFDQyxDQUFBQSxJQUFLQSxFQUFFOHBCLE1BQU07SUFDeEM7SUFFQThHLGdCQUFnQjtRQUNkLE9BQU8sSUFBSSxDQUFDMUYsS0FBSyxDQUFDbnJCLEtBQUssQ0FBQ0MsQ0FBQUEsSUFBS0EsRUFBRThwQixNQUFNO0lBQ3ZDO0lBRUFnSCxzQkFBc0JsNkIsU0FBUSxFQUFFO1FBQzlCLElBQUlnMEIsa0JBQWtCLElBQUksQ0FBQ3hmLGFBQWEsQ0FBQ3hVLFVBQVNnMEIsZUFBZTtRQUNqRUEsZ0JBQWdCek8sSUFBSSxHQUFHO1FBQ3ZCeU8sZ0JBQWdCamhCLDRCQUE0QjtRQUM1QyxJQUFJLENBQUNpaEIsZUFBZSxHQUFHQTtRQUN2QixPQUFPQTtJQUNUO0lBRUF4ZixjQUFjOVksSUFBSSxFQUFFO1FBQ2xCLElBQUl5K0IsY0FBY3orQixLQUFLb1gsUUFBUSxDQUFDMVcsT0FBTyxDQUFDLFdBQVc7UUFDbkQsSUFBSWcrQixjQUFjVCxTQUFTVSxZQUFZLENBQUNGLFlBQVk7UUFFcEQsSUFBSSxPQUFPQyxnQkFBZ0IsYUFBYTtZQUN0QyxPQUFPLElBQUlBLFlBQVksSUFBSSxFQUFFMStCO1FBQy9CO1FBRUEsT0FBTyxJQUFJZ2EsZUFBZSxJQUFJLEVBQUVoYTtJQUNsQztJQUVBMlgsZUFBZTNYLElBQUksRUFBRTtRQUNuQixPQUFPLElBQUkycEIsU0FBUyxJQUFJLEVBQUUzcEI7SUFDNUI7SUFFQWlPLFdBQVcyd0IsTUFBTSxFQUFFO1FBQ2pCLElBQUksQ0FBQ240QixNQUFNLENBQUN3SCxVQUFVLENBQUNxdkIsZ0JBQWdCO1lBQ3JDaDVCLFVBQVUsSUFBSTtRQUNoQixHQUFHczZCO0lBQ0w7QUFFRjtBQUNBWCxTQUFTOStCLFlBQVksR0FBR0E7QUFDeEI4K0IsU0FBUzErQixXQUFXLEdBQUdBO0FBQ3ZCMCtCLFNBQVNVLFlBQVksR0FBR3ZCO0FBRXhCLFNBQVN5QixRQUFROU4sTUFBTSxFQUFFQyxjQUFjO0lBQUksSUFBSUMsT0FBTzV3QixPQUFPNHdCLElBQUksQ0FBQ0Y7SUFBUyxJQUFJMXdCLE9BQU82d0IscUJBQXFCLEVBQUU7UUFBRSxJQUFJQyxVQUFVOXdCLE9BQU82d0IscUJBQXFCLENBQUNIO1FBQVMsSUFBSUMsZ0JBQWdCO1lBQUVHLFVBQVVBLFFBQVE1WSxNQUFNLENBQUMsU0FBVTZZLEdBQUc7Z0JBQUksT0FBTy93QixPQUFPZ3hCLHdCQUF3QixDQUFDTixRQUFRSyxLQUFLRSxVQUFVO1lBQUU7UUFBSTtRQUFFTCxLQUFLem9CLElBQUksQ0FBQ2lMLEtBQUssQ0FBQ3dkLE1BQU1FO0lBQVU7SUFBRSxPQUFPRjtBQUFNO0FBRXhWLFNBQVM2TixjQUFjdE4sTUFBTTtJQUFJLElBQUssSUFBSXhwQixJQUFJLEdBQUdBLElBQUlwSixVQUFVQyxNQUFNLEVBQUVtSixJQUFLO1FBQUUsSUFBSXlwQixTQUFTN3lCLFNBQVMsQ0FBQ29KLEVBQUUsSUFBSSxPQUFPcEosU0FBUyxDQUFDb0osRUFBRSxHQUFHLENBQUM7UUFBRyxJQUFJQSxJQUFJLEdBQUc7WUFBRTYyQixRQUFReCtCLE9BQU9veEIsU0FBUyxNQUFNMW1CLE9BQU8sQ0FBQyxTQUFVaU4sR0FBRztnQkFBSTVaLGtFQUFlQSxDQUFDb3pCLFFBQVF4WixLQUFLeVosTUFBTSxDQUFDelosSUFBSTtZQUFHO1FBQUksT0FBTyxJQUFJM1gsT0FBT3F4Qix5QkFBeUIsRUFBRTtZQUFFcnhCLE9BQU9zeEIsZ0JBQWdCLENBQUNILFFBQVFueEIsT0FBT3F4Qix5QkFBeUIsQ0FBQ0Q7UUFBVSxPQUFPO1lBQUVvTixRQUFReCtCLE9BQU9veEIsU0FBUzFtQixPQUFPLENBQUMsU0FBVWlOLEdBQUc7Z0JBQUkzWCxPQUFPdXhCLGNBQWMsQ0FBQ0osUUFBUXhaLEtBQUszWCxPQUFPZ3hCLHdCQUF3QixDQUFDSSxRQUFRelo7WUFBTztRQUFJO0lBQUU7SUFBRSxPQUFPd1o7QUFBUTtBQUNyaEI7O0NBRUMsR0FFRCxNQUFNdU47SUFDSjs7Ozs7R0FLQyxHQUNEMTZCLFlBQVlpRCxHQUFHLEVBQUU0d0IsR0FBRyxDQUFFO1FBQ3BCLElBQUk4RyxVQUFVcGdDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSSxDQUFDbVUsTUFBTSxHQUFHLElBQUlOLE9BQU91c0I7UUFDekIsSUFBSSxDQUFDdjRCLE1BQU0sR0FBRyxJQUFJNkYsT0FBT2hGLEtBQUswM0I7UUFDOUIsSUFBSSxDQUFDQSxPQUFPLEdBQUdBO1FBQ2YsSUFBSTE2QixZQUFXLElBQUkyNUIsU0FBUyxJQUFJLEVBQUVlO1FBQ2xDLElBQUkxRyxrQkFBa0JoMEIsVUFBU2s2QixxQkFBcUIsQ0FBQ3RHO1FBQ3JELElBQUksQ0FBQzV6QixRQUFRLEdBQUdBO1FBQ2hCLElBQUksQ0FBQ2cwQixlQUFlLEdBQUdBO0lBQ3pCO0lBQ0E7Ozs7OztHQU1DLEdBR0QsT0FBT3BoQixLQUFLNVAsR0FBRyxFQUFFNHdCLEdBQUcsRUFBRTtRQUNwQixJQUFJK0csYUFBYXJnQztRQUNqQixPQUFPVCxvRUFBaUJBLENBQUM7WUFDdkIsSUFBSTZnQyxVQUFVQyxXQUFXcGdDLE1BQU0sR0FBRyxLQUFLb2dDLFVBQVUsQ0FBQyxFQUFFLEtBQUtuZ0MsWUFBWW1nQyxVQUFVLENBQUMsRUFBRSxHQUFHLENBQUM7WUFDdEYsSUFBSWxzQixTQUFTLElBQUlOLE9BQU91c0I7WUFDeEIsSUFBSW5HLGNBQWMsTUFBTTlsQixPQUFPL0osS0FBSyxDQUFDa3ZCO1lBQ3JDLE9BQU8sSUFBSTZHLE1BQU16M0IsS0FBS3V4QixhQUFhbUc7UUFDckM7SUFDRjtJQUNBOzs7Ozs7R0FNQyxHQUdELE9BQU9FLFdBQVc1M0IsR0FBRyxFQUFFNHdCLEdBQUcsRUFBRTtRQUMxQixJQUFJOEcsVUFBVXBnQyxVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRyxDQUFDO1FBQ25GLElBQUltVSxTQUFTLElBQUlOLE9BQU91c0I7UUFDeEIsSUFBSW5HLGNBQWM5bEIsT0FBT0gsZUFBZSxDQUFDc2xCO1FBQ3pDLE9BQU8sSUFBSTZHLE1BQU16M0IsS0FBS3V4QixhQUFhbUc7SUFDckM7SUFDQTs7Ozs7O0dBTUMsR0FHREcsS0FBSzczQixHQUFHLEVBQUU0d0IsR0FBRyxFQUFFO1FBQ2IsSUFBSThHLFVBQVVwZ0MsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixPQUFPbWdDLE1BQU03bkIsSUFBSSxDQUFDNVAsS0FBSzR3QixLQUFLNEcsY0FBY0EsY0FBYyxDQUFDLEdBQUcsSUFBSSxDQUFDRSxPQUFPLEdBQUdBO0lBQzdFO0lBQ0E7Ozs7OztHQU1DLEdBR0QzRyxXQUFXL3dCLEdBQUcsRUFBRTR3QixHQUFHLEVBQUU7UUFDbkIsSUFBSThHLFVBQVVwZ0MsVUFBVUMsTUFBTSxHQUFHLEtBQUtELFNBQVMsQ0FBQyxFQUFFLEtBQUtFLFlBQVlGLFNBQVMsQ0FBQyxFQUFFLEdBQUcsQ0FBQztRQUNuRixPQUFPbWdDLE1BQU1HLFVBQVUsQ0FBQzUzQixLQUFLNHdCLEtBQUs0RyxjQUFjQSxjQUFjLENBQUMsR0FBRyxJQUFJLENBQUNFLE9BQU8sR0FBR0E7SUFDbkY7SUFDQTs7O0dBR0MsR0FHRDV4QixRQUFRO1FBQ04sT0FBTyxJQUFJLENBQUMzRyxNQUFNLENBQUMyRyxLQUFLO0lBQzFCO0lBQ0E7OztHQUdDLEdBR0RJLFVBQVU7UUFDUixPQUFPLElBQUksQ0FBQy9HLE1BQU0sQ0FBQytHLE9BQU87SUFDNUI7SUFDQTs7O0dBR0MsR0FHRHFELFNBQVM7UUFDUCxJQUFJdXVCLGNBQWN4Z0MsV0FDZCtULFFBQVEsSUFBSTtRQUVoQixPQUFPeFUsb0VBQWlCQSxDQUFDO1lBQ3ZCLElBQUk2Z0MsVUFBVUksWUFBWXZnQyxNQUFNLEdBQUcsS0FBS3VnQyxXQUFXLENBQUMsRUFBRSxLQUFLdGdDLFlBQVlzZ0MsV0FBVyxDQUFDLEVBQUUsR0FBRyxDQUFDO1lBRXpGenNCLE1BQU1wSSxLQUFLLENBQUN1MEIsY0FBYztnQkFDeEJ6dUIsY0FBYztnQkFDZHBSLGlCQUFpQjtnQkFDakJDLGFBQWE7WUFDZixHQUFHOC9CO1lBRUgsTUFBTXJzQixNQUFNdkYsS0FBSztZQUVqQnVGLE1BQU1qSSxJQUFJO1FBQ1o7SUFDRjtJQUNBOzs7R0FHQyxHQUdESCxRQUFRO1FBQ04sSUFBSXkwQixVQUFVcGdDLFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSSxFQUNGMDVCLGVBQWUsRUFDZjd4QixNQUFNLEVBQ051NEIsU0FBU0ssV0FBVyxFQUNyQixHQUFHLElBQUk7UUFDUjU0QixPQUFPOEQsS0FBSyxDQUFDK3RCLGlCQUFpQndHLGNBQWNBLGNBQWM7WUFDeER6dUIsY0FBYztRQUNoQixHQUFHZ3ZCLGNBQWNMO0lBQ25CO0lBQ0E7O0dBRUMsR0FHRHQwQixPQUFPO1FBQ0wsSUFBSSxDQUFDakUsTUFBTSxDQUFDaUUsSUFBSTtJQUNsQjtJQUNBOzs7OztHQUtDLEdBR0QyZixPQUFPanJCLEtBQUssRUFBRTtRQUNaLElBQUlDLFNBQVNULFVBQVVDLE1BQU0sR0FBRyxLQUFLRCxTQUFTLENBQUMsRUFBRSxLQUFLRSxZQUFZRixTQUFTLENBQUMsRUFBRSxHQUFHUTtRQUNqRixJQUFJa3JCLHNCQUFzQjFyQixVQUFVQyxNQUFNLEdBQUcsS0FBS0QsU0FBUyxDQUFDLEVBQUUsS0FBS0UsWUFBWUYsU0FBUyxDQUFDLEVBQUUsR0FBRztRQUM5RixJQUFJLENBQUMwNUIsZUFBZSxDQUFDak8sTUFBTSxDQUFDanJCLE9BQU9DLFFBQVFpckI7SUFDN0M7QUFFRjtBQUUwb0MsQ0FDMW9DLDR0UkFBNHRSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQtbmV3Ly4vbm9kZV9tb2R1bGVzL2NhbnZnL2xpYi9pbmRleC5lcy5qcz8wZGQxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnByb21pc2UuanMnO1xuaW1wb3J0IF9hc3luY1RvR2VuZXJhdG9yIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvYXN5bmNUb0dlbmVyYXRvcic7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcubWF0Y2guanMnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnJlcGxhY2UuanMnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLnN0YXJ0cy13aXRoLmpzJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5Lml0ZXJhdG9yLmpzJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL3dlYi5kb20tY29sbGVjdGlvbnMuaXRlcmF0b3IuanMnO1xuaW1wb3J0IF9kZWZpbmVQcm9wZXJ0eSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2RlZmluZVByb3BlcnR5JztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJlZHVjZS5qcyc7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcuZW5kcy13aXRoLmpzJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLnN0cmluZy5zcGxpdC5qcyc7XG5pbXBvcnQgcmVxdWVzdEFuaW1hdGlvbkZyYW1lIGZyb20gJ3JhZic7XG5pbXBvcnQgJ2NvcmUtanMvbW9kdWxlcy9lcy5zdHJpbmcudHJpbS5qcyc7XG5pbXBvcnQgUkdCQ29sb3IgZnJvbSAncmdiY29sb3InO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuYXJyYXkuaW5kZXgtb2YuanMnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMuc3RyaW5nLmluY2x1ZGVzLmpzJztcbmltcG9ydCAnY29yZS1qcy9tb2R1bGVzL2VzLmFycmF5LnJldmVyc2UuanMnO1xuaW1wb3J0IHsgU1ZHUGF0aERhdGEgfSBmcm9tICdzdmctcGF0aGRhdGEnO1xuaW1wb3J0ICdjb3JlLWpzL21vZHVsZXMvZXMucmVnZXhwLnRvLXN0cmluZy5qcyc7XG5pbXBvcnQgeyBjYW52YXNSR0JBIH0gZnJvbSAnc3RhY2tibHVyLWNhbnZhcyc7XG5cbi8qKlxyXG4gKiBPcHRpb25zIHByZXNldCBmb3IgYE9mZnNjcmVlbkNhbnZhc2AuXHJcbiAqIEBwYXJhbSBjb25maWcgLSBQcmVzZXQgcmVxdWlyZW1lbnRzLlxyXG4gKiBAcGFyYW0gY29uZmlnLkRPTVBhcnNlciAtIFhNTC9IVE1MIHBhcnNlciBmcm9tIHN0cmluZyBpbnRvIERPTSBEb2N1bWVudC5cclxuICogQHJldHVybnMgUHJlc2V0IG9iamVjdC5cclxuICovXG5mdW5jdGlvbiBvZmZzY3JlZW4oKSB7XG4gIHZhciB7XG4gICAgRE9NUGFyc2VyOiBET01QYXJzZXJGYWxsYmFja1xuICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgdmFyIHByZXNldCA9IHtcbiAgICB3aW5kb3c6IG51bGwsXG4gICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlLFxuICAgIGlnbm9yZU1vdXNlOiB0cnVlLFxuICAgIERPTVBhcnNlcjogRE9NUGFyc2VyRmFsbGJhY2ssXG5cbiAgICBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIG5ldyBPZmZzY3JlZW5DYW52YXMod2lkdGgsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIGNyZWF0ZUltYWdlKHVybCkge1xuICAgICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHZhciByZXNwb25zZSA9IHlpZWxkIGZldGNoKHVybCk7XG4gICAgICAgIHZhciBibG9iID0geWllbGQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgICB2YXIgaW1nID0geWllbGQgY3JlYXRlSW1hZ2VCaXRtYXAoYmxvYik7XG4gICAgICAgIHJldHVybiBpbWc7XG4gICAgICB9KSgpO1xuICAgIH1cblxuICB9O1xuXG4gIGlmICh0eXBlb2YgRE9NUGFyc2VyICE9PSAndW5kZWZpbmVkJyB8fCB0eXBlb2YgRE9NUGFyc2VyRmFsbGJhY2sgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgUmVmbGVjdC5kZWxldGVQcm9wZXJ0eShwcmVzZXQsICdET01QYXJzZXInKTtcbiAgfVxuXG4gIHJldHVybiBwcmVzZXQ7XG59XG5cbi8qKlxyXG4gKiBPcHRpb25zIHByZXNldCBmb3IgYG5vZGUtY2FudmFzYC5cclxuICogQHBhcmFtIGNvbmZpZyAtIFByZXNldCByZXF1aXJlbWVudHMuXHJcbiAqIEBwYXJhbSBjb25maWcuRE9NUGFyc2VyIC0gWE1ML0hUTUwgcGFyc2VyIGZyb20gc3RyaW5nIGludG8gRE9NIERvY3VtZW50LlxyXG4gKiBAcGFyYW0gY29uZmlnLmNhbnZhcyAtIGBub2RlLWNhbnZhc2AgZXhwb3J0cy5cclxuICogQHBhcmFtIGNvbmZpZy5mZXRjaCAtIFdIQVRXRy1jb21wYXRpYmxlIGBmZXRjaGAgZnVuY3Rpb24uXHJcbiAqIEByZXR1cm5zIFByZXNldCBvYmplY3QuXHJcbiAqL1xuZnVuY3Rpb24gbm9kZShfcmVmKSB7XG4gIHZhciB7XG4gICAgRE9NUGFyc2VyLFxuICAgIGNhbnZhcyxcbiAgICBmZXRjaFxuICB9ID0gX3JlZjtcbiAgcmV0dXJuIHtcbiAgICB3aW5kb3c6IG51bGwsXG4gICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlLFxuICAgIGlnbm9yZU1vdXNlOiB0cnVlLFxuICAgIERPTVBhcnNlcixcbiAgICBmZXRjaCxcbiAgICBjcmVhdGVDYW52YXM6IGNhbnZhcy5jcmVhdGVDYW52YXMsXG4gICAgY3JlYXRlSW1hZ2U6IGNhbnZhcy5sb2FkSW1hZ2VcbiAgfTtcbn1cblxudmFyIGluZGV4ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuXHRfX3Byb3RvX186IG51bGwsXG5cdG9mZnNjcmVlbjogb2Zmc2NyZWVuLFxuXHRub2RlOiBub2RlXG59KTtcblxuLyoqXHJcbiAqIEhUTUwtc2FmZSBjb21wcmVzcyB3aGl0ZS1zcGFjZXMuXHJcbiAqIEBwYXJhbSBzdHIgLSBTdHJpbmcgdG8gY29tcHJlc3MuXHJcbiAqIEByZXR1cm5zIFN0cmluZy5cclxuICovXG5mdW5jdGlvbiBjb21wcmVzc1NwYWNlcyhzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC8oPyFcXHUzMDAwKVxccysvZ20sICcgJyk7XG59XG4vKipcclxuICogSFRNTC1zYWZlIGxlZnQgdHJpbS5cclxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byB0cmltLlxyXG4gKiBAcmV0dXJucyBTdHJpbmcuXHJcbiAqL1xuXG5mdW5jdGlvbiB0cmltTGVmdChzdHIpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9eW1xcbiBcXHRdKy8sICcnKTtcbn1cbi8qKlxyXG4gKiBIVE1MLXNhZmUgcmlnaHQgdHJpbS5cclxuICogQHBhcmFtIHN0ciAtIFN0cmluZyB0byB0cmltLlxyXG4gKiBAcmV0dXJucyBTdHJpbmcuXHJcbiAqL1xuXG5mdW5jdGlvbiB0cmltUmlnaHQoc3RyKSB7XG4gIHJldHVybiBzdHIucmVwbGFjZSgvW1xcbiBcXHRdKyQvLCAnJyk7XG59XG4vKipcclxuICogU3RyaW5nIHRvIG51bWJlcnMgYXJyYXkuXHJcbiAqIEBwYXJhbSBzdHIgLSBOdW1iZXJzIHN0cmluZy5cclxuICogQHJldHVybnMgTnVtYmVycyBhcnJheS5cclxuICovXG5cbmZ1bmN0aW9uIHRvTnVtYmVycyhzdHIpIHtcbiAgdmFyIG1hdGNoZXMgPSAoc3RyIHx8ICcnKS5tYXRjaCgvLT8oXFxkKyg/OlxcLlxcZCooPzpbZUVdWystXT9cXGQrKT8pP3xcXC5cXGQrKSg/PVxcRHwkKS9nbSkgfHwgW107XG4gIHJldHVybiBtYXRjaGVzLm1hcChwYXJzZUZsb2F0KTtcbn0gLy8gTWljcm9zb2Z0IEVkZ2UgZml4XG5cbnZhciBhbGxVcHBlcmNhc2UgPSAvXltBLVotXSskLztcbi8qKlxyXG4gKiBOb3JtYWxpemUgYXR0cmlidXRlIG5hbWUuXHJcbiAqIEBwYXJhbSBuYW1lIC0gQXR0cmlidXRlIG5hbWUuXHJcbiAqIEByZXR1cm5zIE5vcm1hbGl6ZWQgYXR0cmlidXRlIG5hbWUuXHJcbiAqL1xuXG5mdW5jdGlvbiBub3JtYWxpemVBdHRyaWJ1dGVOYW1lKG5hbWUpIHtcbiAgaWYgKGFsbFVwcGVyY2FzZS50ZXN0KG5hbWUpKSB7XG4gICAgcmV0dXJuIG5hbWUudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lO1xufVxuLyoqXHJcbiAqIFBhcnNlIGV4dGVybmFsIFVSTC5cclxuICogQHBhcmFtIHVybCAtIENTUyB1cmwgc3RyaW5nLlxyXG4gKiBAcmV0dXJucyBQYXJzZWQgVVJMLlxyXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VFeHRlcm5hbFVybCh1cmwpIHtcbiAgLy8gICAgICAgICAgICAgICAgICAgICAgc2luZ2xlIHF1b3RlcyBbMl1cbiAgLy8gICAgICAgICAgICAgICAgICAgICAgdiAgICAgICAgIGRvdWJsZSBxdW90ZXMgWzNdXG4gIC8vICAgICAgICAgICAgICAgICAgICAgIHYgICAgICAgICB2ICAgICAgICAgbm8gcXVvdGVzIFs0XVxuICAvLyAgICAgICAgICAgICAgICAgICAgICB2ICAgICAgICAgdiAgICAgICAgIHZcbiAgdmFyIHVybE1hdGNoID0gL3VybFxcKCgnKFteJ10rKSd8XCIoW15cIl0rKVwifChbXidcIildKykpXFwpLy5leGVjKHVybCkgfHwgW107XG4gIHJldHVybiB1cmxNYXRjaFsyXSB8fCB1cmxNYXRjaFszXSB8fCB1cmxNYXRjaFs0XTtcbn1cbi8qKlxyXG4gKiBUcmFuc2Zvcm0gZmxvYXRzIHRvIGludGVnZXJzIGluIHJnYiBjb2xvcnMuXHJcbiAqIEBwYXJhbSBjb2xvciAtIENvbG9yIHRvIG5vcm1hbGl6ZS5cclxuICogQHJldHVybnMgTm9ybWFsaXplZCBjb2xvci5cclxuICovXG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZUNvbG9yKGNvbG9yKSB7XG4gIGlmICghY29sb3Iuc3RhcnRzV2l0aCgncmdiJykpIHtcbiAgICByZXR1cm4gY29sb3I7XG4gIH1cblxuICB2YXIgcmdiUGFydHMgPSAzO1xuICB2YXIgbm9ybWFsaXplZENvbG9yID0gY29sb3IucmVwbGFjZSgvXFxkKyhcXC5cXGQrKT8vZywgKG51bSwgaXNGbG9hdCkgPT4gcmdiUGFydHMtLSAmJiBpc0Zsb2F0ID8gU3RyaW5nKE1hdGgucm91bmQocGFyc2VGbG9hdChudW0pKSkgOiBudW0pO1xuICByZXR1cm4gbm9ybWFsaXplZENvbG9yO1xufVxuXG4vLyBzbGlnaHRseSBtb2RpZmllZCB2ZXJzaW9uIG9mIGh0dHBzOi8vZ2l0aHViLmNvbS9rZWVnYW5zdHJlZXQvc3BlY2lmaWNpdHkvYmxvYi9tYXN0ZXIvc3BlY2lmaWNpdHkuanNcbnZhciBhdHRyaWJ1dGVSZWdleCA9IC8oXFxbW15cXF1dK1xcXSkvZztcbnZhciBpZFJlZ2V4ID0gLygjW15cXHMrPn4uWzpdKykvZztcbnZhciBjbGFzc1JlZ2V4ID0gLyhcXC5bXlxccys+fi5bOl0rKS9nO1xudmFyIHBzZXVkb0VsZW1lbnRSZWdleCA9IC8oOjpbXlxccys+fi5bOl0rfDpmaXJzdC1saW5lfDpmaXJzdC1sZXR0ZXJ8OmJlZm9yZXw6YWZ0ZXIpL2dpO1xudmFyIHBzZXVkb0NsYXNzV2l0aEJyYWNrZXRzUmVnZXggPSAvKDpbXFx3LV0rXFwoW14pXSpcXCkpL2dpO1xudmFyIHBzZXVkb0NsYXNzUmVnZXggPSAvKDpbXlxccys+fi5bOl0rKS9nO1xudmFyIGVsZW1lbnRSZWdleCA9IC8oW15cXHMrPn4uWzpdKykvZztcblxuZnVuY3Rpb24gZmluZFNlbGVjdG9yTWF0Y2goc2VsZWN0b3IsIHJlZ2V4KSB7XG4gIHZhciBtYXRjaGVzID0gcmVnZXguZXhlYyhzZWxlY3Rvcik7XG5cbiAgaWYgKCFtYXRjaGVzKSB7XG4gICAgcmV0dXJuIFtzZWxlY3RvciwgMF07XG4gIH1cblxuICByZXR1cm4gW3NlbGVjdG9yLnJlcGxhY2UocmVnZXgsICcgJyksIG1hdGNoZXMubGVuZ3RoXTtcbn1cbi8qKlxyXG4gKiBNZWFzdXJlIHNlbGVjdG9yIHNwZWNpZmljaXR5LlxyXG4gKiBAcGFyYW0gc2VsZWN0b3IgLSBTZWxlY3RvciB0byBtZWFzdXJlLlxyXG4gKiBAcmV0dXJucyBTcGVjaWZpY2l0eS5cclxuICovXG5cblxuZnVuY3Rpb24gZ2V0U2VsZWN0b3JTcGVjaWZpY2l0eShzZWxlY3Rvcikge1xuICB2YXIgc3BlY2lmaWNpdHkgPSBbMCwgMCwgMF07XG4gIHZhciBjdXJyZW50U2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC86bm90XFwoKFteKV0qKVxcKS9nLCAnICAgICAkMSAnKS5yZXBsYWNlKC97W1xcc1xcU10qL2dtLCAnICcpO1xuICB2YXIgZGVsdGEgPSAwO1xuICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIGF0dHJpYnV0ZVJlZ2V4KTtcbiAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG4gIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgaWRSZWdleCk7XG4gIHNwZWNpZmljaXR5WzBdICs9IGRlbHRhO1xuICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIGNsYXNzUmVnZXgpO1xuICBzcGVjaWZpY2l0eVsxXSArPSBkZWx0YTtcbiAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBwc2V1ZG9FbGVtZW50UmVnZXgpO1xuICBzcGVjaWZpY2l0eVsyXSArPSBkZWx0YTtcbiAgW2N1cnJlbnRTZWxlY3RvciwgZGVsdGFdID0gZmluZFNlbGVjdG9yTWF0Y2goY3VycmVudFNlbGVjdG9yLCBwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4KTtcbiAgc3BlY2lmaWNpdHlbMV0gKz0gZGVsdGE7XG4gIFtjdXJyZW50U2VsZWN0b3IsIGRlbHRhXSA9IGZpbmRTZWxlY3Rvck1hdGNoKGN1cnJlbnRTZWxlY3RvciwgcHNldWRvQ2xhc3NSZWdleCk7XG4gIHNwZWNpZmljaXR5WzFdICs9IGRlbHRhO1xuICBjdXJyZW50U2VsZWN0b3IgPSBjdXJyZW50U2VsZWN0b3IucmVwbGFjZSgvWypcXHMrPn5dL2csICcgJykucmVwbGFjZSgvWyMuXS9nLCAnICcpO1xuICBbY3VycmVudFNlbGVjdG9yLCBkZWx0YV0gPSBmaW5kU2VsZWN0b3JNYXRjaChjdXJyZW50U2VsZWN0b3IsIGVsZW1lbnRSZWdleCk7IC8vIGxndG0gW2pzL3VzZWxlc3MtYXNzaWdubWVudC10by1sb2NhbF1cblxuICBzcGVjaWZpY2l0eVsyXSArPSBkZWx0YTtcbiAgcmV0dXJuIHNwZWNpZmljaXR5LmpvaW4oJycpO1xufVxuXG52YXIgUFNFVURPX1pFUk8gPSAuMDAwMDAwMDE7XG4vKipcclxuICogVmVjdG9yIG1hZ25pdHVkZS5cclxuICogQHBhcmFtIHZcclxuICogQHJldHVybnMgTnVtYmVyIHJlc3VsdC5cclxuICovXG5cbmZ1bmN0aW9uIHZlY3Rvck1hZ25pdHVkZSh2KSB7XG4gIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codlswXSwgMikgKyBNYXRoLnBvdyh2WzFdLCAyKSk7XG59XG4vKipcclxuICogUmF0aW8gYmV0d2VlbiB0d28gdmVjdG9ycy5cclxuICogQHBhcmFtIHVcclxuICogQHBhcmFtIHZcclxuICogQHJldHVybnMgTnVtYmVyIHJlc3VsdC5cclxuICovXG5cbmZ1bmN0aW9uIHZlY3RvcnNSYXRpbyh1LCB2KSB7XG4gIHJldHVybiAodVswXSAqIHZbMF0gKyB1WzFdICogdlsxXSkgLyAodmVjdG9yTWFnbml0dWRlKHUpICogdmVjdG9yTWFnbml0dWRlKHYpKTtcbn1cbi8qKlxyXG4gKiBBbmdsZSBiZXR3ZWVuIHR3byB2ZWN0b3JzLlxyXG4gKiBAcGFyYW0gdVxyXG4gKiBAcGFyYW0gdlxyXG4gKiBAcmV0dXJucyBOdW1iZXIgcmVzdWx0LlxyXG4gKi9cblxuZnVuY3Rpb24gdmVjdG9yc0FuZ2xlKHUsIHYpIHtcbiAgcmV0dXJuICh1WzBdICogdlsxXSA8IHVbMV0gKiB2WzBdID8gLTEgOiAxKSAqIE1hdGguYWNvcyh2ZWN0b3JzUmF0aW8odSwgdikpO1xufVxuZnVuY3Rpb24gQ0IxKHQpIHtcbiAgcmV0dXJuIHQgKiB0ICogdDtcbn1cbmZ1bmN0aW9uIENCMih0KSB7XG4gIHJldHVybiAzICogdCAqIHQgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gQ0IzKHQpIHtcbiAgcmV0dXJuIDMgKiB0ICogKDEgLSB0KSAqICgxIC0gdCk7XG59XG5mdW5jdGlvbiBDQjQodCkge1xuICByZXR1cm4gKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpO1xufVxuZnVuY3Rpb24gUUIxKHQpIHtcbiAgcmV0dXJuIHQgKiB0O1xufVxuZnVuY3Rpb24gUUIyKHQpIHtcbiAgcmV0dXJuIDIgKiB0ICogKDEgLSB0KTtcbn1cbmZ1bmN0aW9uIFFCMyh0KSB7XG4gIHJldHVybiAoMSAtIHQpICogKDEgLSB0KTtcbn1cblxuY2xhc3MgUHJvcGVydHkge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgdGhpcy5pc05vcm1hbGl6ZWRDb2xvciA9IGZhbHNlO1xuICB9XG5cbiAgc3RhdGljIGVtcHR5KGRvY3VtZW50KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ0VNUFRZJywgJycpO1xuICB9XG5cbiAgc3BsaXQoKSB7XG4gICAgdmFyIHNlcGFyYXRvciA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyAnO1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIG5hbWVcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gY29tcHJlc3NTcGFjZXModGhpcy5nZXRTdHJpbmcoKSkudHJpbSgpLnNwbGl0KHNlcGFyYXRvcikubWFwKHZhbHVlID0+IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgbmFtZSwgdmFsdWUpKTtcbiAgfVxuXG4gIGhhc1ZhbHVlKHplcm9Jc1ZhbHVlKSB7XG4gICAgdmFyIHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSAnJyAmJiAoemVyb0lzVmFsdWUgfHwgdmFsdWUgIT09IDApICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIH1cblxuICBpc1N0cmluZyhyZWdleHApIHtcbiAgICB2YXIge1xuICAgICAgdmFsdWVcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgcmVzdWx0ID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJztcblxuICAgIGlmICghcmVzdWx0IHx8ICFyZWdleHApIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZ2V4cC50ZXN0KHZhbHVlKTtcbiAgfVxuXG4gIGlzVXJsRGVmaW5pdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5pc1N0cmluZygvXnVybFxcKC8pO1xuICB9XG5cbiAgaXNQaXhlbHMoKSB7XG4gICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgYXNTdHJpbmcgPSB0aGlzLmdldFN0cmluZygpO1xuXG4gICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICBjYXNlIGFzU3RyaW5nLmVuZHNXaXRoKCdweCcpOlxuICAgICAgY2FzZSAvXlswLTldKyQvLnRlc3QoYXNTdHJpbmcpOlxuICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgZ2V0VmFsdWUoZGVmKSB7XG4gICAgaWYgKHR5cGVvZiBkZWYgPT09ICd1bmRlZmluZWQnIHx8IHRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlZjtcbiAgfVxuXG4gIGdldE51bWJlcihkZWYpIHtcbiAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgaWYgKHR5cGVvZiBkZWYgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFyc2VGbG9hdChkZWYpO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICB2YWx1ZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBuID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG5cbiAgICBpZiAodGhpcy5pc1N0cmluZygvJSQvKSkge1xuICAgICAgbiAvPSAxMDAuMDtcbiAgICB9XG5cbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIGdldFN0cmluZyhkZWYpIHtcbiAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ3VuZGVmaW5lZCcgfHwgdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIHRoaXMudmFsdWUgPT09ICd1bmRlZmluZWQnID8gJycgOiBTdHJpbmcodGhpcy52YWx1ZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFN0cmluZyhkZWYpO1xuICB9XG5cbiAgZ2V0Q29sb3IoZGVmKSB7XG4gICAgdmFyIGNvbG9yID0gdGhpcy5nZXRTdHJpbmcoZGVmKTtcblxuICAgIGlmICh0aGlzLmlzTm9ybWFsaXplZENvbG9yKSB7XG4gICAgICByZXR1cm4gY29sb3I7XG4gICAgfVxuXG4gICAgdGhpcy5pc05vcm1hbGl6ZWRDb2xvciA9IHRydWU7XG4gICAgY29sb3IgPSBub3JtYWxpemVDb2xvcihjb2xvcik7XG4gICAgdGhpcy52YWx1ZSA9IGNvbG9yO1xuICAgIHJldHVybiBjb2xvcjtcbiAgfVxuXG4gIGdldERwaSgpIHtcbiAgICByZXR1cm4gOTYuMDsgLy8gVE9ETzogY29tcHV0ZT9cbiAgfVxuXG4gIGdldFJlbSgpIHtcbiAgICByZXR1cm4gdGhpcy5kb2N1bWVudC5yb290RW1TaXplO1xuICB9XG5cbiAgZ2V0RW0oKSB7XG4gICAgcmV0dXJuIHRoaXMuZG9jdW1lbnQuZW1TaXplO1xuICB9XG5cbiAgZ2V0VW5pdHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0U3RyaW5nKCkucmVwbGFjZSgvWzAtOS4tXS9nLCAnJyk7XG4gIH1cblxuICBnZXRQaXhlbHMoYXhpc09ySXNGb250U2l6ZSkge1xuICAgIHZhciBwcm9jZXNzUGVyY2VudCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgdmFyIFtheGlzLCBpc0ZvbnRTaXplXSA9IHR5cGVvZiBheGlzT3JJc0ZvbnRTaXplID09PSAnYm9vbGVhbicgPyBbdW5kZWZpbmVkLCBheGlzT3JJc0ZvbnRTaXplXSA6IFtheGlzT3JJc0ZvbnRTaXplXTtcbiAgICB2YXIge1xuICAgICAgdmlld1BvcnRcbiAgICB9ID0gdGhpcy5kb2N1bWVudC5zY3JlZW47XG5cbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvdm1pbiQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgLyAxMDAuMCAqIE1hdGgubWluKHZpZXdQb3J0LmNvbXB1dGVTaXplKCd4JyksIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd5JykpO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3ZtYXgkLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpIC8gMTAwLjAgKiBNYXRoLm1heCh2aWV3UG9ydC5jb21wdXRlU2l6ZSgneCcpLCB2aWV3UG9ydC5jb21wdXRlU2l6ZSgneScpKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC92dyQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgLyAxMDAuMCAqIHZpZXdQb3J0LmNvbXB1dGVTaXplKCd4Jyk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvdmgkLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpIC8gMTAwLjAgKiB2aWV3UG9ydC5jb21wdXRlU2l6ZSgneScpO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3JlbSQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldFJlbSgpO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2VtJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RW0oKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC9leCQvKTpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiB0aGlzLmdldEVtKCkgLyAyLjA7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcHgkLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL3B0JC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIHRoaXMuZ2V0RHBpKCkgKiAoMS4wIC8gNzIuMCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcGMkLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogMTU7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvY20kLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXREcGkoKSAvIDIuNTQ7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvbW0kLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXREcGkoKSAvIDI1LjQ7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvaW4kLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXREcGkoKTtcblxuICAgICAgY2FzZSB0aGlzLmlzU3RyaW5nKC8lJC8pICYmIGlzRm9udFNpemU6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdGhpcy5nZXRFbSgpO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoLyUkLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogdmlld1BvcnQuY29tcHV0ZVNpemUoYXhpcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbiA9IHRoaXMuZ2V0TnVtYmVyKCk7XG5cbiAgICAgICAgICBpZiAocHJvY2Vzc1BlcmNlbnQgJiYgbiA8IDEuMCkge1xuICAgICAgICAgICAgcmV0dXJuIG4gKiB2aWV3UG9ydC5jb21wdXRlU2l6ZShheGlzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldE1pbGxpc2Vjb25kcygpIHtcbiAgICBpZiAoIXRoaXMuaGFzVmFsdWUoKSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaXNTdHJpbmcoL21zJC8pKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIDEwMDA7XG4gIH1cblxuICBnZXRSYWRpYW5zKCkge1xuICAgIGlmICghdGhpcy5oYXNWYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvZGVnJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKSAqIChNYXRoLlBJIC8gMTgwLjApO1xuXG4gICAgICBjYXNlIHRoaXMuaXNTdHJpbmcoL2dyYWQkLyk6XG4gICAgICAgIHJldHVybiB0aGlzLmdldE51bWJlcigpICogKE1hdGguUEkgLyAyMDAuMCk7XG5cbiAgICAgIGNhc2UgdGhpcy5pc1N0cmluZygvcmFkJC8pOlxuICAgICAgICByZXR1cm4gdGhpcy5nZXROdW1iZXIoKTtcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TnVtYmVyKCkgKiAoTWF0aC5QSSAvIDE4MC4wKTtcbiAgICB9XG4gIH1cblxuICBnZXREZWZpbml0aW9uKCkge1xuICAgIHZhciBhc1N0cmluZyA9IHRoaXMuZ2V0U3RyaW5nKCk7XG4gICAgdmFyIG5hbWUgPSAvIyhbXiknXCJdKykvLmV4ZWMoYXNTdHJpbmcpO1xuXG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIG5hbWUgPSBuYW1lWzFdO1xuICAgIH1cblxuICAgIGlmICghbmFtZSkge1xuICAgICAgbmFtZSA9IGFzU3RyaW5nO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmRvY3VtZW50LmRlZmluaXRpb25zW25hbWVdO1xuICB9XG5cbiAgZ2V0RmlsbFN0eWxlRGVmaW5pdGlvbihlbGVtZW50LCBvcGFjaXR5KSB7XG4gICAgdmFyIGRlZiA9IHRoaXMuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgaWYgKCFkZWYpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gZ3JhZGllbnRcblxuXG4gICAgaWYgKHR5cGVvZiBkZWYuY3JlYXRlR3JhZGllbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBkZWYuY3JlYXRlR3JhZGllbnQodGhpcy5kb2N1bWVudC5jdHgsIGVsZW1lbnQsIG9wYWNpdHkpO1xuICAgIH0gLy8gcGF0dGVyblxuXG5cbiAgICBpZiAodHlwZW9mIGRlZi5jcmVhdGVQYXR0ZXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGVmLmdldEhyZWZBdHRyaWJ1dGUoKS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHZhciBwYXR0ZXJuVHJhbnNmb3JtID0gZGVmLmdldEF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScpO1xuICAgICAgICBkZWYgPSBkZWYuZ2V0SHJlZkF0dHJpYnV0ZSgpLmdldERlZmluaXRpb24oKTtcblxuICAgICAgICBpZiAocGF0dGVyblRyYW5zZm9ybS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgZGVmLmdldEF0dHJpYnV0ZSgncGF0dGVyblRyYW5zZm9ybScsIHRydWUpLnNldFZhbHVlKHBhdHRlcm5UcmFuc2Zvcm0udmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWYuY3JlYXRlUGF0dGVybih0aGlzLmRvY3VtZW50LmN0eCwgZWxlbWVudCwgb3BhY2l0eSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRUZXh0QmFzZWxpbmUoKSB7XG4gICAgaWYgKCF0aGlzLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBQcm9wZXJ0eS50ZXh0QmFzZWxpbmVNYXBwaW5nW3RoaXMuZ2V0U3RyaW5nKCldO1xuICB9XG5cbiAgYWRkT3BhY2l0eShvcGFjaXR5KSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXRDb2xvcigpO1xuICAgIHZhciBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgdmFyIGNvbW1hcyA9IDA7IC8vIFNpbXVsYXRlIG9sZCBSR0JDb2xvciB2ZXJzaW9uLCB3aGljaCBjYW4ndCBwYXJzZSByZ2JhLlxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKHZhbHVlW2ldID09PSAnLCcpIHtcbiAgICAgICAgY29tbWFzKys7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21tYXMgPT09IDMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wYWNpdHkuaGFzVmFsdWUoKSAmJiB0aGlzLmlzU3RyaW5nKCkgJiYgY29tbWFzICE9PSAzKSB7XG4gICAgICB2YXIgY29sb3IgPSBuZXcgUkdCQ29sb3IodmFsdWUpO1xuXG4gICAgICBpZiAoY29sb3Iub2spIHtcbiAgICAgICAgY29sb3IuYWxwaGEgPSBvcGFjaXR5LmdldE51bWJlcigpO1xuICAgICAgICB2YWx1ZSA9IGNvbG9yLnRvUkdCQSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgdGhpcy5uYW1lLCB2YWx1ZSk7XG4gIH1cblxufVxuUHJvcGVydHkudGV4dEJhc2VsaW5lTWFwcGluZyA9IHtcbiAgJ2Jhc2VsaW5lJzogJ2FscGhhYmV0aWMnLFxuICAnYmVmb3JlLWVkZ2UnOiAndG9wJyxcbiAgJ3RleHQtYmVmb3JlLWVkZ2UnOiAndG9wJyxcbiAgJ21pZGRsZSc6ICdtaWRkbGUnLFxuICAnY2VudHJhbCc6ICdtaWRkbGUnLFxuICAnYWZ0ZXItZWRnZSc6ICdib3R0b20nLFxuICAndGV4dC1hZnRlci1lZGdlJzogJ2JvdHRvbScsXG4gICdpZGVvZ3JhcGhpYyc6ICdpZGVvZ3JhcGhpYycsXG4gICdhbHBoYWJldGljJzogJ2FscGhhYmV0aWMnLFxuICAnaGFuZ2luZyc6ICdoYW5naW5nJyxcbiAgJ21hdGhlbWF0aWNhbCc6ICdhbHBoYWJldGljJ1xufTtcblxuY2xhc3MgVmlld1BvcnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnZpZXdQb3J0cyA9IFtdO1xuICB9XG5cbiAgY2xlYXIoKSB7XG4gICAgdGhpcy52aWV3UG9ydHMgPSBbXTtcbiAgfVxuXG4gIHNldEN1cnJlbnQod2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMudmlld1BvcnRzLnB1c2goe1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9KTtcbiAgfVxuXG4gIHJlbW92ZUN1cnJlbnQoKSB7XG4gICAgdGhpcy52aWV3UG9ydHMucG9wKCk7XG4gIH1cblxuICBnZXRDdXJyZW50KCkge1xuICAgIHZhciB7XG4gICAgICB2aWV3UG9ydHNcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4gdmlld1BvcnRzW3ZpZXdQb3J0cy5sZW5ndGggLSAxXTtcbiAgfVxuXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRDdXJyZW50KCkud2lkdGg7XG4gIH1cblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLmdldEN1cnJlbnQoKS5oZWlnaHQ7XG4gIH1cblxuICBjb21wdXRlU2l6ZShkKSB7XG4gICAgaWYgKHR5cGVvZiBkID09PSAnbnVtYmVyJykge1xuICAgICAgcmV0dXJuIGQ7XG4gICAgfVxuXG4gICAgaWYgKGQgPT09ICd4Jykge1xuICAgICAgcmV0dXJuIHRoaXMud2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKGQgPT09ICd5Jykge1xuICAgICAgcmV0dXJuIHRoaXMuaGVpZ2h0O1xuICAgIH1cblxuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3codGhpcy53aWR0aCwgMikgKyBNYXRoLnBvdyh0aGlzLmhlaWdodCwgMikpIC8gTWF0aC5zcXJ0KDIpO1xuICB9XG5cbn1cblxuY2xhc3MgUG9pbnQge1xuICBjb25zdHJ1Y3Rvcih4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgc3RhdGljIHBhcnNlKHBvaW50KSB7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICB2YXIgW3ggPSBkZWZhdWx0VmFsdWUsIHkgPSBkZWZhdWx0VmFsdWVdID0gdG9OdW1iZXJzKHBvaW50KTtcbiAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlU2NhbGUoc2NhbGUpIHtcbiAgICB2YXIgZGVmYXVsdFZhbHVlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAxO1xuICAgIHZhciBbeCA9IGRlZmF1bHRWYWx1ZSwgeSA9IHhdID0gdG9OdW1iZXJzKHNjYWxlKTtcbiAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICB9XG5cbiAgc3RhdGljIHBhcnNlUGF0aChwYXRoKSB7XG4gICAgdmFyIHBvaW50cyA9IHRvTnVtYmVycyhwYXRoKTtcbiAgICB2YXIgbGVuID0gcG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgcGF0aFBvaW50cyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgICAgcGF0aFBvaW50cy5wdXNoKG5ldyBQb2ludChwb2ludHNbaV0sIHBvaW50c1tpICsgMV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGF0aFBvaW50cztcbiAgfVxuXG4gIGFuZ2xlVG8ocG9pbnQpIHtcbiAgICByZXR1cm4gTWF0aC5hdGFuMihwb2ludC55IC0gdGhpcy55LCBwb2ludC54IC0gdGhpcy54KTtcbiAgfVxuXG4gIGFwcGx5VHJhbnNmb3JtKHRyYW5zZm9ybSkge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB4cCA9IHggKiB0cmFuc2Zvcm1bMF0gKyB5ICogdHJhbnNmb3JtWzJdICsgdHJhbnNmb3JtWzRdO1xuICAgIHZhciB5cCA9IHggKiB0cmFuc2Zvcm1bMV0gKyB5ICogdHJhbnNmb3JtWzNdICsgdHJhbnNmb3JtWzVdO1xuICAgIHRoaXMueCA9IHhwO1xuICAgIHRoaXMueSA9IHlwO1xuICB9XG5cbn1cblxuY2xhc3MgTW91c2Uge1xuICBjb25zdHJ1Y3RvcihzY3JlZW4pIHtcbiAgICB0aGlzLnNjcmVlbiA9IHNjcmVlbjtcbiAgICB0aGlzLndvcmtpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmV2ZW50cyA9IFtdO1xuICAgIHRoaXMuZXZlbnRFbGVtZW50cyA9IFtdOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1hc3NpZ25tZW50XG5cbiAgICB0aGlzLm9uQ2xpY2sgPSB0aGlzLm9uQ2xpY2suYmluZCh0aGlzKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnNhZmUtYXNzaWdubWVudFxuXG4gICAgdGhpcy5vbk1vdXNlTW92ZSA9IHRoaXMub25Nb3VzZU1vdmUuYmluZCh0aGlzKTtcbiAgfVxuXG4gIGlzV29ya2luZygpIHtcbiAgICByZXR1cm4gdGhpcy53b3JraW5nO1xuICB9XG5cbiAgc3RhcnQoKSB7XG4gICAgaWYgKHRoaXMud29ya2luZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBzY3JlZW4sXG4gICAgICBvbkNsaWNrLFxuICAgICAgb25Nb3VzZU1vdmVcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgY2FudmFzID0gc2NyZWVuLmN0eC5jYW52YXM7XG4gICAgY2FudmFzLm9uY2xpY2sgPSBvbkNsaWNrO1xuICAgIGNhbnZhcy5vbm1vdXNlbW92ZSA9IG9uTW91c2VNb3ZlO1xuICAgIHRoaXMud29ya2luZyA9IHRydWU7XG4gIH1cblxuICBzdG9wKCkge1xuICAgIGlmICghdGhpcy53b3JraW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGNhbnZhcyA9IHRoaXMuc2NyZWVuLmN0eC5jYW52YXM7XG4gICAgdGhpcy53b3JraW5nID0gZmFsc2U7XG4gICAgY2FudmFzLm9uY2xpY2sgPSBudWxsO1xuICAgIGNhbnZhcy5vbm1vdXNlbW92ZSA9IG51bGw7XG4gIH1cblxuICBoYXNFdmVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMud29ya2luZyAmJiB0aGlzLmV2ZW50cy5sZW5ndGggPiAwO1xuICB9XG5cbiAgcnVuRXZlbnRzKCkge1xuICAgIGlmICghdGhpcy53b3JraW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHNjcmVlbjogZG9jdW1lbnQsXG4gICAgICBldmVudHMsXG4gICAgICBldmVudEVsZW1lbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRvY3VtZW50LmN0eC5jYW52YXM7XG5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHN0eWxlLmN1cnNvciA9ICcnO1xuICAgIH1cblxuICAgIGV2ZW50cy5mb3JFYWNoKChfcmVmLCBpKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBydW5cbiAgICAgIH0gPSBfcmVmO1xuICAgICAgdmFyIGVsZW1lbnQgPSBldmVudEVsZW1lbnRzW2ldO1xuXG4gICAgICB3aGlsZSAoZWxlbWVudCkge1xuICAgICAgICBydW4oZWxlbWVudCk7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudDtcbiAgICAgIH1cbiAgICB9KTsgLy8gZG9uZSBydW5uaW5nLCBjbGVhclxuXG4gICAgdGhpcy5ldmVudHMgPSBbXTtcbiAgICB0aGlzLmV2ZW50RWxlbWVudHMgPSBbXTtcbiAgfVxuXG4gIGNoZWNrUGF0aChlbGVtZW50LCBjdHgpIHtcbiAgICBpZiAoIXRoaXMud29ya2luZyB8fCAhY3R4KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGV2ZW50cyxcbiAgICAgIGV2ZW50RWxlbWVudHNcbiAgICB9ID0gdGhpcztcbiAgICBldmVudHMuZm9yRWFjaCgoX3JlZjIsIGkpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSBfcmVmMjtcblxuICAgICAgaWYgKCFldmVudEVsZW1lbnRzW2ldICYmIGN0eC5pc1BvaW50SW5QYXRoICYmIGN0eC5pc1BvaW50SW5QYXRoKHgsIHkpKSB7XG4gICAgICAgIGV2ZW50RWxlbWVudHNbaV0gPSBlbGVtZW50O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY2hlY2tCb3VuZGluZ0JveChlbGVtZW50LCBib3VuZGluZ0JveCkge1xuICAgIGlmICghdGhpcy53b3JraW5nIHx8ICFib3VuZGluZ0JveCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBldmVudHMsXG4gICAgICBldmVudEVsZW1lbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgZXZlbnRzLmZvckVhY2goKF9yZWYzLCBpKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gX3JlZjM7XG5cbiAgICAgIGlmICghZXZlbnRFbGVtZW50c1tpXSAmJiBib3VuZGluZ0JveC5pc1BvaW50SW5Cb3goeCwgeSkpIHtcbiAgICAgICAgZXZlbnRFbGVtZW50c1tpXSA9IGVsZW1lbnQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBtYXBYWSh4LCB5KSB7XG4gICAgdmFyIHtcbiAgICAgIHdpbmRvdyxcbiAgICAgIGN0eFxuICAgIH0gPSB0aGlzLnNjcmVlbjtcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoeCwgeSk7XG4gICAgdmFyIGVsZW1lbnQgPSBjdHguY2FudmFzO1xuXG4gICAgd2hpbGUgKGVsZW1lbnQpIHtcbiAgICAgIHBvaW50LnggLT0gZWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgICAgcG9pbnQueSAtPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAod2luZG93LnNjcm9sbFgpIHtcbiAgICAgIHBvaW50LnggKz0gd2luZG93LnNjcm9sbFg7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5zY3JvbGxZKSB7XG4gICAgICBwb2ludC55ICs9IHdpbmRvdy5zY3JvbGxZO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludDtcbiAgfVxuXG4gIG9uQ2xpY2soZXZlbnQpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcy5tYXBYWShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgIHR5cGU6ICdvbmNsaWNrJyxcbiAgICAgIHgsXG4gICAgICB5LFxuXG4gICAgICBydW4oZXZlbnRUYXJnZXQpIHtcbiAgICAgICAgaWYgKGV2ZW50VGFyZ2V0Lm9uQ2xpY2spIHtcbiAgICAgICAgICBldmVudFRhcmdldC5vbkNsaWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0pO1xuICB9XG5cbiAgb25Nb3VzZU1vdmUoZXZlbnQpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcy5tYXBYWShldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICB0aGlzLmV2ZW50cy5wdXNoKHtcbiAgICAgIHR5cGU6ICdvbm1vdXNlbW92ZScsXG4gICAgICB4LFxuICAgICAgeSxcblxuICAgICAgcnVuKGV2ZW50VGFyZ2V0KSB7XG4gICAgICAgIGlmIChldmVudFRhcmdldC5vbk1vdXNlTW92ZSkge1xuICAgICAgICAgIGV2ZW50VGFyZ2V0Lm9uTW91c2VNb3ZlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIH0pO1xuICB9XG5cbn1cblxudmFyIGRlZmF1bHRXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IG51bGw7XG52YXIgZGVmYXVsdEZldGNoJDEgPSB0eXBlb2YgZmV0Y2ggIT09ICd1bmRlZmluZWQnID8gZmV0Y2guYmluZCh1bmRlZmluZWQpIC8vIGBmZXRjaGAgZGVwZW5kcyBvbiBjb250ZXh0OiBgc29tZU9iamVjdC5mZXRjaCguLi4pYCB3aWxsIHRocm93IGVycm9yLlxuOiBudWxsO1xuY2xhc3MgU2NyZWVuIHtcbiAgY29uc3RydWN0b3IoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGZldGNoID0gZGVmYXVsdEZldGNoJDEsXG4gICAgICB3aW5kb3cgPSBkZWZhdWx0V2luZG93XG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy5jdHggPSBjdHg7XG4gICAgdGhpcy5GUkFNRVJBVEUgPSAzMDtcbiAgICB0aGlzLk1BWF9WSVJUVUFMX1BJWEVMUyA9IDMwMDAwO1xuICAgIHRoaXMuQ0xJRU5UX1dJRFRIID0gODAwO1xuICAgIHRoaXMuQ0xJRU5UX0hFSUdIVCA9IDYwMDtcbiAgICB0aGlzLnZpZXdQb3J0ID0gbmV3IFZpZXdQb3J0KCk7XG4gICAgdGhpcy5tb3VzZSA9IG5ldyBNb3VzZSh0aGlzKTtcbiAgICB0aGlzLmFuaW1hdGlvbnMgPSBbXTtcbiAgICB0aGlzLndhaXRzID0gW107XG4gICAgdGhpcy5mcmFtZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLmlzUmVhZHlMb2NrID0gZmFsc2U7XG4gICAgdGhpcy5pc0ZpcnN0UmVuZGVyID0gdHJ1ZTtcbiAgICB0aGlzLmludGVydmFsSWQgPSBudWxsO1xuICAgIHRoaXMud2luZG93ID0gd2luZG93O1xuICAgIHRoaXMuZmV0Y2ggPSBmZXRjaDtcbiAgfVxuXG4gIHdhaXQoY2hlY2tlcikge1xuICAgIHRoaXMud2FpdHMucHVzaChjaGVja2VyKTtcbiAgfVxuXG4gIHJlYWR5KCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbWlzdXNlZC1wcm9taXNlc1xuICAgIGlmICghdGhpcy5yZWFkeVByb21pc2UpIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWFkeVByb21pc2U7XG4gIH1cblxuICBpc1JlYWR5KCkge1xuICAgIGlmICh0aGlzLmlzUmVhZHlMb2NrKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZWFkeUxvY2sgPSB0aGlzLndhaXRzLmV2ZXJ5KF8gPT4gXygpKTtcblxuICAgIGlmIChpc1JlYWR5TG9jaykge1xuICAgICAgdGhpcy53YWl0cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5yZXNvbHZlUmVhZHkpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlUmVhZHkoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmlzUmVhZHlMb2NrID0gaXNSZWFkeUxvY2s7XG4gICAgcmV0dXJuIGlzUmVhZHlMb2NrO1xuICB9XG5cbiAgc2V0RGVmYXVsdHMoY3R4KSB7XG4gICAgLy8gaW5pdGlhbCB2YWx1ZXMgYW5kIGRlZmF1bHRzXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuICAgIGN0eC5saW5lQ2FwID0gJ2J1dHQnO1xuICAgIGN0eC5saW5lSm9pbiA9ICdtaXRlcic7XG4gICAgY3R4Lm1pdGVyTGltaXQgPSA0O1xuICB9XG5cbiAgc2V0Vmlld0JveChfcmVmKSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgY3R4LFxuICAgICAgYXNwZWN0UmF0aW8sXG4gICAgICB3aWR0aCxcbiAgICAgIGRlc2lyZWRXaWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIGRlc2lyZWRIZWlnaHQsXG4gICAgICBtaW5YID0gMCxcbiAgICAgIG1pblkgPSAwLFxuICAgICAgcmVmWCxcbiAgICAgIHJlZlksXG4gICAgICBjbGlwID0gZmFsc2UsXG4gICAgICBjbGlwWCA9IDAsXG4gICAgICBjbGlwWSA9IDBcbiAgICB9ID0gX3JlZjtcbiAgICAvLyBhc3BlY3QgcmF0aW8gLSBodHRwOi8vd3d3LnczLm9yZy9UUi9TVkcvY29vcmRzLmh0bWwjUHJlc2VydmVBc3BlY3RSYXRpb0F0dHJpYnV0ZVxuICAgIHZhciBjbGVhbkFzcGVjdFJhdGlvID0gY29tcHJlc3NTcGFjZXMoYXNwZWN0UmF0aW8pLnJlcGxhY2UoL15kZWZlclxccy8sICcnKTsgLy8gaWdub3JlIGRlZmVyXG5cbiAgICB2YXIgW2FzcGVjdFJhdGlvQWxpZ24sIGFzcGVjdFJhdGlvTWVldE9yU2xpY2VdID0gY2xlYW5Bc3BlY3RSYXRpby5zcGxpdCgnICcpO1xuICAgIHZhciBhbGlnbiA9IGFzcGVjdFJhdGlvQWxpZ24gfHwgJ3hNaWRZTWlkJztcbiAgICB2YXIgbWVldE9yU2xpY2UgPSBhc3BlY3RSYXRpb01lZXRPclNsaWNlIHx8ICdtZWV0JzsgLy8gY2FsY3VsYXRlIHNjYWxlXG5cbiAgICB2YXIgc2NhbGVYID0gd2lkdGggLyBkZXNpcmVkV2lkdGg7XG4gICAgdmFyIHNjYWxlWSA9IGhlaWdodCAvIGRlc2lyZWRIZWlnaHQ7XG4gICAgdmFyIHNjYWxlTWluID0gTWF0aC5taW4oc2NhbGVYLCBzY2FsZVkpO1xuICAgIHZhciBzY2FsZU1heCA9IE1hdGgubWF4KHNjYWxlWCwgc2NhbGVZKTtcbiAgICB2YXIgZmluYWxEZXNpcmVkV2lkdGggPSBkZXNpcmVkV2lkdGg7XG4gICAgdmFyIGZpbmFsRGVzaXJlZEhlaWdodCA9IGRlc2lyZWRIZWlnaHQ7XG5cbiAgICBpZiAobWVldE9yU2xpY2UgPT09ICdtZWV0Jykge1xuICAgICAgZmluYWxEZXNpcmVkV2lkdGggKj0gc2NhbGVNaW47XG4gICAgICBmaW5hbERlc2lyZWRIZWlnaHQgKj0gc2NhbGVNaW47XG4gICAgfVxuXG4gICAgaWYgKG1lZXRPclNsaWNlID09PSAnc2xpY2UnKSB7XG4gICAgICBmaW5hbERlc2lyZWRXaWR0aCAqPSBzY2FsZU1heDtcbiAgICAgIGZpbmFsRGVzaXJlZEhlaWdodCAqPSBzY2FsZU1heDtcbiAgICB9XG5cbiAgICB2YXIgcmVmWFByb3AgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdyZWZYJywgcmVmWCk7XG4gICAgdmFyIHJlZllQcm9wID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAncmVmWScsIHJlZlkpO1xuICAgIHZhciBoYXNSZWZzID0gcmVmWFByb3AuaGFzVmFsdWUoKSAmJiByZWZZUHJvcC5oYXNWYWx1ZSgpO1xuXG4gICAgaWYgKGhhc1JlZnMpIHtcbiAgICAgIGN0eC50cmFuc2xhdGUoLXNjYWxlTWluICogcmVmWFByb3AuZ2V0UGl4ZWxzKCd4JyksIC1zY2FsZU1pbiAqIHJlZllQcm9wLmdldFBpeGVscygneScpKTtcbiAgICB9XG5cbiAgICBpZiAoY2xpcCkge1xuICAgICAgdmFyIHNjYWxlZENsaXBYID0gc2NhbGVNaW4gKiBjbGlwWDtcbiAgICAgIHZhciBzY2FsZWRDbGlwWSA9IHNjYWxlTWluICogY2xpcFk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHNjYWxlZENsaXBYLCBzY2FsZWRDbGlwWSk7XG4gICAgICBjdHgubGluZVRvKHdpZHRoLCBzY2FsZWRDbGlwWSk7XG4gICAgICBjdHgubGluZVRvKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY3R4LmxpbmVUbyhzY2FsZWRDbGlwWCwgaGVpZ2h0KTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIGN0eC5jbGlwKCk7XG4gICAgfVxuXG4gICAgaWYgKCFoYXNSZWZzKSB7XG4gICAgICB2YXIgaXNNZWV0TWluWSA9IG1lZXRPclNsaWNlID09PSAnbWVldCcgJiYgc2NhbGVNaW4gPT09IHNjYWxlWTtcbiAgICAgIHZhciBpc1NsaWNlTWF4WSA9IG1lZXRPclNsaWNlID09PSAnc2xpY2UnICYmIHNjYWxlTWF4ID09PSBzY2FsZVk7XG4gICAgICB2YXIgaXNNZWV0TWluWCA9IG1lZXRPclNsaWNlID09PSAnbWVldCcgJiYgc2NhbGVNaW4gPT09IHNjYWxlWDtcbiAgICAgIHZhciBpc1NsaWNlTWF4WCA9IG1lZXRPclNsaWNlID09PSAnc2xpY2UnICYmIHNjYWxlTWF4ID09PSBzY2FsZVg7XG5cbiAgICAgIGlmIChhbGlnbi5zdGFydHNXaXRoKCd4TWlkJykgJiYgKGlzTWVldE1pblkgfHwgaXNTbGljZU1heFkpKSB7XG4gICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGggLyAyLjAgLSBmaW5hbERlc2lyZWRXaWR0aCAvIDIuMCwgMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGlnbi5lbmRzV2l0aCgnWU1pZCcpICYmIChpc01lZXRNaW5YIHx8IGlzU2xpY2VNYXhYKSkge1xuICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGhlaWdodCAvIDIuMCAtIGZpbmFsRGVzaXJlZEhlaWdodCAvIDIuMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGlnbi5zdGFydHNXaXRoKCd4TWF4JykgJiYgKGlzTWVldE1pblkgfHwgaXNTbGljZU1heFkpKSB7XG4gICAgICAgIGN0eC50cmFuc2xhdGUod2lkdGggLSBmaW5hbERlc2lyZWRXaWR0aCwgMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhbGlnbi5lbmRzV2l0aCgnWU1heCcpICYmIChpc01lZXRNaW5YIHx8IGlzU2xpY2VNYXhYKSkge1xuICAgICAgICBjdHgudHJhbnNsYXRlKDAsIGhlaWdodCAtIGZpbmFsRGVzaXJlZEhlaWdodCk7XG4gICAgICB9XG4gICAgfSAvLyBzY2FsZVxuXG5cbiAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgIGNhc2UgYWxpZ24gPT09ICdub25lJzpcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlWCwgc2NhbGVZKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgbWVldE9yU2xpY2UgPT09ICdtZWV0JzpcbiAgICAgICAgY3R4LnNjYWxlKHNjYWxlTWluLCBzY2FsZU1pbik7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIG1lZXRPclNsaWNlID09PSAnc2xpY2UnOlxuICAgICAgICBjdHguc2NhbGUoc2NhbGVNYXgsIHNjYWxlTWF4KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfSAvLyB0cmFuc2xhdGVcblxuXG4gICAgY3R4LnRyYW5zbGF0ZSgtbWluWCwgLW1pblkpO1xuICB9XG5cbiAgc3RhcnQoZWxlbWVudCkge1xuICAgIHZhciB7XG4gICAgICBlbmFibGVSZWRyYXcgPSBmYWxzZSxcbiAgICAgIGlnbm9yZU1vdXNlID0gZmFsc2UsXG4gICAgICBpZ25vcmVBbmltYXRpb24gPSBmYWxzZSxcbiAgICAgIGlnbm9yZURpbWVuc2lvbnMgPSBmYWxzZSxcbiAgICAgIGlnbm9yZUNsZWFyID0gZmFsc2UsXG4gICAgICBmb3JjZVJlZHJhdyxcbiAgICAgIHNjYWxlV2lkdGgsXG4gICAgICBzY2FsZUhlaWdodCxcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIEZSQU1FUkFURSxcbiAgICAgIG1vdXNlXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGZyYW1lRHVyYXRpb24gPSAxMDAwIC8gRlJBTUVSQVRFO1xuICAgIHRoaXMuZnJhbWVEdXJhdGlvbiA9IGZyYW1lRHVyYXRpb247XG4gICAgdGhpcy5yZWFkeVByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgIHRoaXMucmVzb2x2ZVJlYWR5ID0gcmVzb2x2ZTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLmlzUmVhZHkoKSkge1xuICAgICAgdGhpcy5yZW5kZXIoZWxlbWVudCwgaWdub3JlRGltZW5zaW9ucywgaWdub3JlQ2xlYXIsIHNjYWxlV2lkdGgsIHNjYWxlSGVpZ2h0LCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICB9XG5cbiAgICBpZiAoIWVuYWJsZVJlZHJhdykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgIHZhciB0aGVuID0gbm93O1xuICAgIHZhciBkZWx0YSA9IDA7XG5cbiAgICB2YXIgdGljayA9ICgpID0+IHtcbiAgICAgIG5vdyA9IERhdGUubm93KCk7XG4gICAgICBkZWx0YSA9IG5vdyAtIHRoZW47XG5cbiAgICAgIGlmIChkZWx0YSA+PSBmcmFtZUR1cmF0aW9uKSB7XG4gICAgICAgIHRoZW4gPSBub3cgLSBkZWx0YSAlIGZyYW1lRHVyYXRpb247XG5cbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkVXBkYXRlKGlnbm9yZUFuaW1hdGlvbiwgZm9yY2VSZWRyYXcpKSB7XG4gICAgICAgICAgdGhpcy5yZW5kZXIoZWxlbWVudCwgaWdub3JlRGltZW5zaW9ucywgaWdub3JlQ2xlYXIsIHNjYWxlV2lkdGgsIHNjYWxlSGVpZ2h0LCBvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICBtb3VzZS5ydW5FdmVudHMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLmludGVydmFsSWQgPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGljayk7XG4gICAgfTtcblxuICAgIGlmICghaWdub3JlTW91c2UpIHtcbiAgICAgIG1vdXNlLnN0YXJ0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5pbnRlcnZhbElkID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRpY2spO1xuICB9XG5cbiAgc3RvcCgpIHtcbiAgICBpZiAodGhpcy5pbnRlcnZhbElkKSB7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuY2FuY2VsKHRoaXMuaW50ZXJ2YWxJZCk7XG4gICAgICB0aGlzLmludGVydmFsSWQgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMubW91c2Uuc3RvcCgpO1xuICB9XG5cbiAgc2hvdWxkVXBkYXRlKGlnbm9yZUFuaW1hdGlvbiwgZm9yY2VSZWRyYXcpIHtcbiAgICAvLyBuZWVkIHVwZGF0ZSBmcm9tIGFuaW1hdGlvbnM/XG4gICAgaWYgKCFpZ25vcmVBbmltYXRpb24pIHtcbiAgICAgIHZhciB7XG4gICAgICAgIGZyYW1lRHVyYXRpb25cbiAgICAgIH0gPSB0aGlzO1xuICAgICAgdmFyIHNob3VsZFVwZGF0ZSA9IHRoaXMuYW5pbWF0aW9ucy5yZWR1Y2UoKHNob3VsZFVwZGF0ZSwgYW5pbWF0aW9uKSA9PiBhbmltYXRpb24udXBkYXRlKGZyYW1lRHVyYXRpb24pIHx8IHNob3VsZFVwZGF0ZSwgZmFsc2UpO1xuXG4gICAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gLy8gbmVlZCB1cGRhdGUgZnJvbSByZWRyYXc/XG5cblxuICAgIGlmICh0eXBlb2YgZm9yY2VSZWRyYXcgPT09ICdmdW5jdGlvbicgJiYgZm9yY2VSZWRyYXcoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmlzUmVhZHlMb2NrICYmIHRoaXMuaXNSZWFkeSgpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IC8vIG5lZWQgdXBkYXRlIGZyb20gbW91c2UgZXZlbnRzP1xuXG5cbiAgICBpZiAodGhpcy5tb3VzZS5oYXNFdmVudHMoKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmVuZGVyKGVsZW1lbnQsIGlnbm9yZURpbWVuc2lvbnMsIGlnbm9yZUNsZWFyLCBzY2FsZVdpZHRoLCBzY2FsZUhlaWdodCwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuICAgIHZhciB7XG4gICAgICBDTElFTlRfV0lEVEgsXG4gICAgICBDTElFTlRfSEVJR0hULFxuICAgICAgdmlld1BvcnQsXG4gICAgICBjdHgsXG4gICAgICBpc0ZpcnN0UmVuZGVyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGNhbnZhcyA9IGN0eC5jYW52YXM7XG4gICAgdmlld1BvcnQuY2xlYXIoKTtcblxuICAgIGlmIChjYW52YXMud2lkdGggJiYgY2FudmFzLmhlaWdodCkge1xuICAgICAgdmlld1BvcnQuc2V0Q3VycmVudChjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2aWV3UG9ydC5zZXRDdXJyZW50KENMSUVOVF9XSURUSCwgQ0xJRU5UX0hFSUdIVCk7XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd3aWR0aCcpO1xuICAgIHZhciBoZWlnaHRTdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ2hlaWdodCcpO1xuXG4gICAgaWYgKCFpZ25vcmVEaW1lbnNpb25zICYmIChpc0ZpcnN0UmVuZGVyIHx8IHR5cGVvZiBzY2FsZVdpZHRoICE9PSAnbnVtYmVyJyAmJiB0eXBlb2Ygc2NhbGVIZWlnaHQgIT09ICdudW1iZXInKSkge1xuICAgICAgLy8gc2V0IGNhbnZhcyBzaXplXG4gICAgICBpZiAod2lkdGhTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoU3R5bGUuZ2V0UGl4ZWxzKCd4Jyk7XG5cbiAgICAgICAgaWYgKGNhbnZhcy5zdHlsZSkge1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IFwiXCIuY29uY2F0KGNhbnZhcy53aWR0aCwgXCJweFwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0U3R5bGUuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICAgICAgaWYgKGNhbnZhcy5zdHlsZSkge1xuICAgICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBcIlwiLmNvbmNhdChjYW52YXMuaGVpZ2h0LCBcInB4XCIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNXaWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aCB8fCBjYW52YXMud2lkdGg7XG4gICAgdmFyIGNIZWlnaHQgPSBjYW52YXMuY2xpZW50SGVpZ2h0IHx8IGNhbnZhcy5oZWlnaHQ7XG5cbiAgICBpZiAoaWdub3JlRGltZW5zaW9ucyAmJiB3aWR0aFN0eWxlLmhhc1ZhbHVlKCkgJiYgaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgY1dpZHRoID0gd2lkdGhTdHlsZS5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIGNIZWlnaHQgPSBoZWlnaHRTdHlsZS5nZXRQaXhlbHMoJ3knKTtcbiAgICB9XG5cbiAgICB2aWV3UG9ydC5zZXRDdXJyZW50KGNXaWR0aCwgY0hlaWdodCk7XG5cbiAgICBpZiAodHlwZW9mIG9mZnNldFggPT09ICdudW1iZXInKSB7XG4gICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgneCcsIHRydWUpLnNldFZhbHVlKG9mZnNldFgpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb2Zmc2V0WSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCd5JywgdHJ1ZSkuc2V0VmFsdWUob2Zmc2V0WSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBzY2FsZVdpZHRoID09PSAnbnVtYmVyJyB8fCB0eXBlb2Ygc2NhbGVIZWlnaHQgPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgdmlld0JveCA9IHRvTnVtYmVycyhlbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLmdldFN0cmluZygpKTtcbiAgICAgIHZhciB4UmF0aW8gPSAwO1xuICAgICAgdmFyIHlSYXRpbyA9IDA7XG5cbiAgICAgIGlmICh0eXBlb2Ygc2NhbGVXaWR0aCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgdmFyIF93aWR0aFN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnd2lkdGgnKTtcblxuICAgICAgICBpZiAoX3dpZHRoU3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHhSYXRpbyA9IF93aWR0aFN0eWxlLmdldFBpeGVscygneCcpIC8gc2NhbGVXaWR0aDtcbiAgICAgICAgfSBlbHNlIGlmICghaXNOYU4odmlld0JveFsyXSkpIHtcbiAgICAgICAgICB4UmF0aW8gPSB2aWV3Qm94WzJdIC8gc2NhbGVXaWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHNjYWxlSGVpZ2h0ID09PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgX2hlaWdodFN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnaGVpZ2h0Jyk7XG5cbiAgICAgICAgaWYgKF9oZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgeVJhdGlvID0gX2hlaWdodFN0eWxlLmdldFBpeGVscygneScpIC8gc2NhbGVIZWlnaHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIWlzTmFOKHZpZXdCb3hbM10pKSB7XG4gICAgICAgICAgeVJhdGlvID0gdmlld0JveFszXSAvIHNjYWxlSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICgheFJhdGlvKSB7XG4gICAgICAgIHhSYXRpbyA9IHlSYXRpbztcbiAgICAgIH1cblxuICAgICAgaWYgKCF5UmF0aW8pIHtcbiAgICAgICAgeVJhdGlvID0geFJhdGlvO1xuICAgICAgfVxuXG4gICAgICBlbGVtZW50LmdldEF0dHJpYnV0ZSgnd2lkdGgnLCB0cnVlKS5zZXRWYWx1ZShzY2FsZVdpZHRoKTtcbiAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0cnVlKS5zZXRWYWx1ZShzY2FsZUhlaWdodCk7XG4gICAgICB2YXIgdHJhbnNmb3JtU3R5bGUgPSBlbGVtZW50LmdldFN0eWxlKCd0cmFuc2Zvcm0nLCB0cnVlLCB0cnVlKTtcbiAgICAgIHRyYW5zZm9ybVN0eWxlLnNldFZhbHVlKFwiXCIuY29uY2F0KHRyYW5zZm9ybVN0eWxlLmdldFN0cmluZygpLCBcIiBzY2FsZShcIikuY29uY2F0KDEuMCAvIHhSYXRpbywgXCIsIFwiKS5jb25jYXQoMS4wIC8geVJhdGlvLCBcIilcIikpO1xuICAgIH0gLy8gY2xlYXIgYW5kIHJlbmRlclxuXG5cbiAgICBpZiAoIWlnbm9yZUNsZWFyKSB7XG4gICAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNXaWR0aCwgY0hlaWdodCk7XG4gICAgfVxuXG4gICAgZWxlbWVudC5yZW5kZXIoY3R4KTtcblxuICAgIGlmIChpc0ZpcnN0UmVuZGVyKSB7XG4gICAgICB0aGlzLmlzRmlyc3RSZW5kZXIgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxufVxuU2NyZWVuLmRlZmF1bHRXaW5kb3cgPSBkZWZhdWx0V2luZG93O1xuU2NyZWVuLmRlZmF1bHRGZXRjaCA9IGRlZmF1bHRGZXRjaCQxO1xuXG52YXIge1xuICBkZWZhdWx0RmV0Y2hcbn0gPSBTY3JlZW47XG52YXIgRGVmYXVsdERPTVBhcnNlciA9IHR5cGVvZiBET01QYXJzZXIgIT09ICd1bmRlZmluZWQnID8gRE9NUGFyc2VyIDogbnVsbDtcbmNsYXNzIFBhcnNlciB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHZhciB7XG4gICAgICBmZXRjaCA9IGRlZmF1bHRGZXRjaCxcbiAgICAgIERPTVBhcnNlciA9IERlZmF1bHRET01QYXJzZXJcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB0aGlzLmZldGNoID0gZmV0Y2g7XG4gICAgdGhpcy5ET01QYXJzZXIgPSBET01QYXJzZXI7XG4gIH1cblxuICBwYXJzZShyZXNvdXJjZSkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIGlmIChyZXNvdXJjZS5zdGFydHNXaXRoKCc8JykpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnBhcnNlRnJvbVN0cmluZyhyZXNvdXJjZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5sb2FkKHJlc291cmNlKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgcGFyc2VGcm9tU3RyaW5nKHhtbCkge1xuICAgIHZhciBwYXJzZXIgPSBuZXcgdGhpcy5ET01QYXJzZXIoKTtcblxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGVja0RvY3VtZW50KHBhcnNlci5wYXJzZUZyb21TdHJpbmcoeG1sLCAnaW1hZ2Uvc3ZnK3htbCcpKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoZWNrRG9jdW1lbnQocGFyc2VyLnBhcnNlRnJvbVN0cmluZyh4bWwsICd0ZXh0L3htbCcpKTtcbiAgICB9XG4gIH1cblxuICBjaGVja0RvY3VtZW50KGRvY3VtZW50KSB7XG4gICAgdmFyIHBhcnNlckVycm9yID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3BhcnNlcmVycm9yJylbMF07XG5cbiAgICBpZiAocGFyc2VyRXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihwYXJzZXJFcnJvci50ZXh0Q29udGVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvY3VtZW50O1xuICB9XG5cbiAgbG9hZCh1cmwpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIHJlc3BvbnNlID0geWllbGQgX3RoaXMyLmZldGNoKHVybCk7XG4gICAgICB2YXIgeG1sID0geWllbGQgcmVzcG9uc2UudGV4dCgpO1xuICAgICAgcmV0dXJuIF90aGlzMi5wYXJzZUZyb21TdHJpbmcoeG1sKTtcbiAgICB9KSgpO1xuICB9XG5cbn1cblxuY2xhc3MgVHJhbnNsYXRlIHtcbiAgY29uc3RydWN0b3IoXywgcG9pbnQpIHtcbiAgICB0aGlzLnR5cGUgPSAndHJhbnNsYXRlJztcbiAgICB0aGlzLnBvaW50ID0gbnVsbDtcbiAgICB0aGlzLnBvaW50ID0gUG9pbnQucGFyc2UocG9pbnQpO1xuICB9XG5cbiAgYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXMucG9pbnQ7XG4gICAgY3R4LnRyYW5zbGF0ZSh4IHx8IDAuMCwgeSB8fCAwLjApO1xuICB9XG5cbiAgdW5hcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gdGhpcy5wb2ludDtcbiAgICBjdHgudHJhbnNsYXRlKC0xLjAgKiB4IHx8IDAuMCwgLTEuMCAqIHkgfHwgMC4wKTtcbiAgfVxuXG4gIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzLnBvaW50O1xuICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFsxLCAwLCAwLCAxLCB4IHx8IDAuMCwgeSB8fCAwLjBdKTtcbiAgfVxuXG59XG5cbmNsYXNzIFJvdGF0ZSB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCByb3RhdGUsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHRoaXMudHlwZSA9ICdyb3RhdGUnO1xuICAgIHRoaXMuYW5nbGUgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luWCA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5ZID0gbnVsbDtcbiAgICB0aGlzLmN4ID0gMDtcbiAgICB0aGlzLmN5ID0gMDtcbiAgICB2YXIgbnVtYmVycyA9IHRvTnVtYmVycyhyb3RhdGUpO1xuICAgIHRoaXMuYW5nbGUgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdhbmdsZScsIG51bWJlcnNbMF0pO1xuICAgIHRoaXMub3JpZ2luWCA9IHRyYW5zZm9ybU9yaWdpblswXTtcbiAgICB0aGlzLm9yaWdpblkgPSB0cmFuc2Zvcm1PcmlnaW5bMV07XG4gICAgdGhpcy5jeCA9IG51bWJlcnNbMV0gfHwgMDtcbiAgICB0aGlzLmN5ID0gbnVtYmVyc1syXSB8fCAwO1xuICB9XG5cbiAgYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGN4LFxuICAgICAgY3ksXG4gICAgICBvcmlnaW5YLFxuICAgICAgb3JpZ2luWSxcbiAgICAgIGFuZ2xlXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHR4ID0gY3ggKyBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgIHZhciB0eSA9IGN5ICsgb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgY3R4LnJvdGF0ZShhbmdsZS5nZXRSYWRpYW5zKCkpO1xuICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICB9XG5cbiAgdW5hcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgY3gsXG4gICAgICBjeSxcbiAgICAgIG9yaWdpblgsXG4gICAgICBvcmlnaW5ZLFxuICAgICAgYW5nbGVcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgdHggPSBjeCArIG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHR5ID0gY3kgKyBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICBjdHgucm90YXRlKC0xLjAgKiBhbmdsZS5nZXRSYWRpYW5zKCkpO1xuICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICB9XG5cbiAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgdmFyIHtcbiAgICAgIGN4LFxuICAgICAgY3ksXG4gICAgICBhbmdsZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciByYWQgPSBhbmdsZS5nZXRSYWRpYW5zKCk7XG4gICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0oWzEsIDAsIDAsIDEsIGN4IHx8IDAuMCwgY3kgfHwgMC4wIC8vIHRoaXMucC55XG4gICAgXSk7XG4gICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0oW01hdGguY29zKHJhZCksIE1hdGguc2luKHJhZCksIC1NYXRoLnNpbihyYWQpLCBNYXRoLmNvcyhyYWQpLCAwLCAwXSk7XG4gICAgcG9pbnQuYXBwbHlUcmFuc2Zvcm0oWzEsIDAsIDAsIDEsIC1jeCB8fCAwLjAsIC1jeSB8fCAwLjAgLy8gLXRoaXMucC55XG4gICAgXSk7XG4gIH1cblxufVxuXG5jbGFzcyBTY2FsZSB7XG4gIGNvbnN0cnVjdG9yKF8sIHNjYWxlLCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICB0aGlzLnR5cGUgPSAnc2NhbGUnO1xuICAgIHRoaXMuc2NhbGUgPSBudWxsO1xuICAgIHRoaXMub3JpZ2luWCA9IG51bGw7XG4gICAgdGhpcy5vcmlnaW5ZID0gbnVsbDtcbiAgICB2YXIgc2NhbGVTaXplID0gUG9pbnQucGFyc2VTY2FsZShzY2FsZSk7IC8vIFdvcmthcm91bmQgZm9yIG5vZGUtY2FudmFzXG5cbiAgICBpZiAoc2NhbGVTaXplLnggPT09IDAgfHwgc2NhbGVTaXplLnkgPT09IDApIHtcbiAgICAgIHNjYWxlU2l6ZS54ID0gUFNFVURPX1pFUk87XG4gICAgICBzY2FsZVNpemUueSA9IFBTRVVET19aRVJPO1xuICAgIH1cblxuICAgIHRoaXMuc2NhbGUgPSBzY2FsZVNpemU7XG4gICAgdGhpcy5vcmlnaW5YID0gdHJhbnNmb3JtT3JpZ2luWzBdO1xuICAgIHRoaXMub3JpZ2luWSA9IHRyYW5zZm9ybU9yaWdpblsxXTtcbiAgfVxuXG4gIGFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBzY2FsZToge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9LFxuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpbllcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgdHggPSBvcmlnaW5YLmdldFBpeGVscygneCcpO1xuICAgIHZhciB0eSA9IG9yaWdpblkuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgY3R4LnRyYW5zbGF0ZSh0eCwgdHkpO1xuICAgIGN0eC5zY2FsZSh4LCB5IHx8IHgpO1xuICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICB9XG5cbiAgdW5hcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgc2NhbGU6IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSxcbiAgICAgIG9yaWdpblgsXG4gICAgICBvcmlnaW5ZXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHR4ID0gb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICBjdHguc2NhbGUoMS4wIC8geCwgMS4wIC8geSB8fCB4KTtcbiAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgfVxuXG4gIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzLnNjYWxlO1xuICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKFt4IHx8IDAuMCwgMCwgMCwgeSB8fCAwLjAsIDAsIDBdKTtcbiAgfVxuXG59XG5cbmNsYXNzIE1hdHJpeCB7XG4gIGNvbnN0cnVjdG9yKF8sIG1hdHJpeCwgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgdGhpcy50eXBlID0gJ21hdHJpeCc7XG4gICAgdGhpcy5tYXRyaXggPSBbXTtcbiAgICB0aGlzLm9yaWdpblggPSBudWxsO1xuICAgIHRoaXMub3JpZ2luWSA9IG51bGw7XG4gICAgdGhpcy5tYXRyaXggPSB0b051bWJlcnMobWF0cml4KTtcbiAgICB0aGlzLm9yaWdpblggPSB0cmFuc2Zvcm1PcmlnaW5bMF07XG4gICAgdGhpcy5vcmlnaW5ZID0gdHJhbnNmb3JtT3JpZ2luWzFdO1xuICB9XG5cbiAgYXBwbHkoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIG9yaWdpblgsXG4gICAgICBvcmlnaW5ZLFxuICAgICAgbWF0cml4XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHR4ID0gb3JpZ2luWC5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgdHkgPSBvcmlnaW5ZLmdldFBpeGVscygneScpO1xuICAgIGN0eC50cmFuc2xhdGUodHgsIHR5KTtcbiAgICBjdHgudHJhbnNmb3JtKG1hdHJpeFswXSwgbWF0cml4WzFdLCBtYXRyaXhbMl0sIG1hdHJpeFszXSwgbWF0cml4WzRdLCBtYXRyaXhbNV0pO1xuICAgIGN0eC50cmFuc2xhdGUoLXR4LCAtdHkpO1xuICB9XG5cbiAgdW5hcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgb3JpZ2luWCxcbiAgICAgIG9yaWdpblksXG4gICAgICBtYXRyaXhcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgYSA9IG1hdHJpeFswXTtcbiAgICB2YXIgYiA9IG1hdHJpeFsyXTtcbiAgICB2YXIgYyA9IG1hdHJpeFs0XTtcbiAgICB2YXIgZCA9IG1hdHJpeFsxXTtcbiAgICB2YXIgZSA9IG1hdHJpeFszXTtcbiAgICB2YXIgZiA9IG1hdHJpeFs1XTtcbiAgICB2YXIgZyA9IDAuMDtcbiAgICB2YXIgaCA9IDAuMDtcbiAgICB2YXIgaSA9IDEuMDtcbiAgICB2YXIgZGV0ID0gMSAvIChhICogKGUgKiBpIC0gZiAqIGgpIC0gYiAqIChkICogaSAtIGYgKiBnKSArIGMgKiAoZCAqIGggLSBlICogZykpO1xuICAgIHZhciB0eCA9IG9yaWdpblguZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHR5ID0gb3JpZ2luWS5nZXRQaXhlbHMoJ3knKTtcbiAgICBjdHgudHJhbnNsYXRlKHR4LCB0eSk7XG4gICAgY3R4LnRyYW5zZm9ybShkZXQgKiAoZSAqIGkgLSBmICogaCksIGRldCAqIChmICogZyAtIGQgKiBpKSwgZGV0ICogKGMgKiBoIC0gYiAqIGkpLCBkZXQgKiAoYSAqIGkgLSBjICogZyksIGRldCAqIChiICogZiAtIGMgKiBlKSwgZGV0ICogKGMgKiBkIC0gYSAqIGYpKTtcbiAgICBjdHgudHJhbnNsYXRlKC10eCwgLXR5KTtcbiAgfVxuXG4gIGFwcGx5VG9Qb2ludChwb2ludCkge1xuICAgIHBvaW50LmFwcGx5VHJhbnNmb3JtKHRoaXMubWF0cml4KTtcbiAgfVxuXG59XG5cbmNsYXNzIFNrZXcgZXh0ZW5kcyBNYXRyaXgge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgdGhpcy50eXBlID0gJ3NrZXcnO1xuICAgIHRoaXMuYW5nbGUgPSBudWxsO1xuICAgIHRoaXMuYW5nbGUgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdhbmdsZScsIHNrZXcpO1xuICB9XG5cbn1cblxuY2xhc3MgU2tld1ggZXh0ZW5kcyBTa2V3IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIHNrZXcsIHRyYW5zZm9ybU9yaWdpbikge1xuICAgIHN1cGVyKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pO1xuICAgIHRoaXMudHlwZSA9ICdza2V3WCc7XG4gICAgdGhpcy5tYXRyaXggPSBbMSwgMCwgTWF0aC50YW4odGhpcy5hbmdsZS5nZXRSYWRpYW5zKCkpLCAxLCAwLCAwXTtcbiAgfVxuXG59XG5cbmNsYXNzIFNrZXdZIGV4dGVuZHMgU2tldyB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBza2V3LCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICBzdXBlcihkb2N1bWVudCwgc2tldywgdHJhbnNmb3JtT3JpZ2luKTtcbiAgICB0aGlzLnR5cGUgPSAnc2tld1knO1xuICAgIHRoaXMubWF0cml4ID0gWzEsIE1hdGgudGFuKHRoaXMuYW5nbGUuZ2V0UmFkaWFucygpKSwgMCwgMSwgMCwgMF07XG4gIH1cblxufVxuXG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybXModHJhbnNmb3JtKSB7XG4gIHJldHVybiBjb21wcmVzc1NwYWNlcyh0cmFuc2Zvcm0pLnRyaW0oKS5yZXBsYWNlKC9cXCkoW2EtekEtWl0pL2csICcpICQxJykucmVwbGFjZSgvXFwpKFxccz8sXFxzPykvZywgJykgJykuc3BsaXQoL1xccyg/PVthLXpdKS8pO1xufVxuXG5mdW5jdGlvbiBwYXJzZVRyYW5zZm9ybSh0cmFuc2Zvcm0pIHtcbiAgdmFyIFt0eXBlLCB2YWx1ZV0gPSB0cmFuc2Zvcm0uc3BsaXQoJygnKTtcbiAgcmV0dXJuIFt0eXBlLnRyaW0oKSwgdmFsdWUudHJpbSgpLnJlcGxhY2UoJyknLCAnJyldO1xufVxuXG5jbGFzcyBUcmFuc2Zvcm0ge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgdHJhbnNmb3JtLCB0cmFuc2Zvcm1PcmlnaW4pIHtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy50cmFuc2Zvcm1zID0gW107XG4gICAgdmFyIGRhdGEgPSBwYXJzZVRyYW5zZm9ybXModHJhbnNmb3JtKTtcbiAgICBkYXRhLmZvckVhY2godHJhbnNmb3JtID0+IHtcbiAgICAgIGlmICh0cmFuc2Zvcm0gPT09ICdub25lJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBbdHlwZSwgdmFsdWVdID0gcGFyc2VUcmFuc2Zvcm0odHJhbnNmb3JtKTtcbiAgICAgIHZhciBUcmFuc2Zvcm1UeXBlID0gVHJhbnNmb3JtLnRyYW5zZm9ybVR5cGVzW3R5cGVdO1xuXG4gICAgICBpZiAodHlwZW9mIFRyYW5zZm9ybVR5cGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3Jtcy5wdXNoKG5ldyBUcmFuc2Zvcm1UeXBlKHRoaXMuZG9jdW1lbnQsIHZhbHVlLCB0cmFuc2Zvcm1PcmlnaW4pKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHN0YXRpYyBmcm9tRWxlbWVudChkb2N1bWVudCwgZWxlbWVudCkge1xuICAgIHZhciB0cmFuc2Zvcm1TdHlsZSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3RyYW5zZm9ybScsIGZhbHNlLCB0cnVlKTtcbiAgICB2YXIgW3RyYW5zZm9ybU9yaWdpblhQcm9wZXJ0eSwgdHJhbnNmb3JtT3JpZ2luWVByb3BlcnR5ID0gdHJhbnNmb3JtT3JpZ2luWFByb3BlcnR5XSA9IGVsZW1lbnQuZ2V0U3R5bGUoJ3RyYW5zZm9ybS1vcmlnaW4nLCBmYWxzZSwgdHJ1ZSkuc3BsaXQoKTtcbiAgICB2YXIgdHJhbnNmb3JtT3JpZ2luID0gW3RyYW5zZm9ybU9yaWdpblhQcm9wZXJ0eSwgdHJhbnNmb3JtT3JpZ2luWVByb3BlcnR5XTtcblxuICAgIGlmICh0cmFuc2Zvcm1TdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICByZXR1cm4gbmV3IFRyYW5zZm9ybShkb2N1bWVudCwgdHJhbnNmb3JtU3R5bGUuZ2V0U3RyaW5nKCksIHRyYW5zZm9ybU9yaWdpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBhcHBseShjdHgpIHtcbiAgICB2YXIge1xuICAgICAgdHJhbnNmb3Jtc1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1zLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRyYW5zZm9ybXNbaV0uYXBwbHkoY3R4KTtcbiAgICB9XG4gIH1cblxuICB1bmFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICB0cmFuc2Zvcm1zXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgZm9yICh2YXIgaSA9IGxlbiAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB0cmFuc2Zvcm1zW2ldLnVuYXBwbHkoY3R4KTtcbiAgICB9XG4gIH0gLy8gVE9ETzogYXBwbHlUb1BvaW50IHVudXNlZCAuLi4gcmVtb3ZlP1xuXG5cbiAgYXBwbHlUb1BvaW50KHBvaW50KSB7XG4gICAgdmFyIHtcbiAgICAgIHRyYW5zZm9ybXNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgbGVuID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICB0cmFuc2Zvcm1zW2ldLmFwcGx5VG9Qb2ludChwb2ludCk7XG4gICAgfVxuICB9XG5cbn1cblRyYW5zZm9ybS50cmFuc2Zvcm1UeXBlcyA9IHtcbiAgdHJhbnNsYXRlOiBUcmFuc2xhdGUsXG4gIHJvdGF0ZTogUm90YXRlLFxuICBzY2FsZTogU2NhbGUsXG4gIG1hdHJpeDogTWF0cml4LFxuICBza2V3WDogU2tld1gsXG4gIHNrZXdZOiBTa2V3WVxufTtcblxuY2xhc3MgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlKSB7XG4gICAgdmFyIGNhcHR1cmVUZXh0Tm9kZXMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIHRoaXMuZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICB0aGlzLm5vZGUgPSBub2RlO1xuICAgIHRoaXMuY2FwdHVyZVRleHROb2RlcyA9IGNhcHR1cmVUZXh0Tm9kZXM7XG4gICAgdGhpcy5hdHRyaWJ1dGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0eWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zdHlsZXNTcGVjaWZpY2l0eSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hbmltYXRpb25Gcm96ZW4gPSBmYWxzZTtcbiAgICB0aGlzLmFuaW1hdGlvbkZyb3plblZhbHVlID0gJyc7XG4gICAgdGhpcy5wYXJlbnQgPSBudWxsO1xuICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcblxuICAgIGlmICghbm9kZSB8fCBub2RlLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICAvLyBFTEVNRU5UX05PREVcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGFkZCBhdHRyaWJ1dGVzXG5cblxuICAgIEFycmF5LmZyb20obm9kZS5hdHRyaWJ1dGVzKS5mb3JFYWNoKGF0dHJpYnV0ZSA9PiB7XG4gICAgICB2YXIgbm9kZU5hbWUgPSBub3JtYWxpemVBdHRyaWJ1dGVOYW1lKGF0dHJpYnV0ZS5ub2RlTmFtZSk7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbbm9kZU5hbWVdID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCBub2RlTmFtZSwgYXR0cmlidXRlLnZhbHVlKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKTsgLy8gYWRkIGlubGluZSBzdHlsZXNcblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnc3R5bGUnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICB2YXIgc3R5bGVzID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykuZ2V0U3RyaW5nKCkuc3BsaXQoJzsnKS5tYXAoXyA9PiBfLnRyaW0oKSk7XG4gICAgICBzdHlsZXMuZm9yRWFjaChzdHlsZSA9PiB7XG4gICAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgW25hbWUsIHZhbHVlXSA9IHN0eWxlLnNwbGl0KCc6JykubWFwKF8gPT4gXy50cmltKCkpO1xuICAgICAgICB0aGlzLnN0eWxlc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGRlZmluaXRpb25zXG4gICAgfSA9IGRvY3VtZW50O1xuICAgIHZhciBpZCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdpZCcpOyAvLyBhZGQgaWRcblxuICAgIGlmIChpZC5oYXNWYWx1ZSgpKSB7XG4gICAgICBpZiAoIWRlZmluaXRpb25zW2lkLmdldFN0cmluZygpXSkge1xuICAgICAgICBkZWZpbml0aW9uc1tpZC5nZXRTdHJpbmcoKV0gPSB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIEFycmF5LmZyb20obm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKGNoaWxkTm9kZSA9PiB7XG4gICAgICBpZiAoY2hpbGROb2RlLm5vZGVUeXBlID09PSAxKSB7XG4gICAgICAgIHRoaXMuYWRkQ2hpbGQoY2hpbGROb2RlKTsgLy8gRUxFTUVOVF9OT0RFXG4gICAgICB9IGVsc2UgaWYgKGNhcHR1cmVUZXh0Tm9kZXMgJiYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMyB8fCBjaGlsZE5vZGUubm9kZVR5cGUgPT09IDQpKSB7XG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkTm9kZSk7XG5cbiAgICAgICAgaWYgKHRleHROb2RlLmdldFRleHQoKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdGhpcy5hZGRDaGlsZCh0ZXh0Tm9kZSk7IC8vIFRFWFRfTk9ERVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXRBdHRyaWJ1dGUobmFtZSkge1xuICAgIHZhciBjcmVhdGVJZk5vdEV4aXN0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgdmFyIGF0dHIgPSB0aGlzLmF0dHJpYnV0ZXNbbmFtZV07XG5cbiAgICBpZiAoIWF0dHIgJiYgY3JlYXRlSWZOb3RFeGlzdHMpIHtcbiAgICAgIHZhciBfYXR0ciA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCBuYW1lLCAnJyk7XG5cbiAgICAgIHRoaXMuYXR0cmlidXRlc1tuYW1lXSA9IF9hdHRyO1xuICAgICAgcmV0dXJuIF9hdHRyO1xuICAgIH1cblxuICAgIHJldHVybiBhdHRyIHx8IFByb3BlcnR5LmVtcHR5KHRoaXMuZG9jdW1lbnQpO1xuICB9XG5cbiAgZ2V0SHJlZkF0dHJpYnV0ZSgpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5hdHRyaWJ1dGVzKSB7XG4gICAgICBpZiAoa2V5ID09PSAnaHJlZicgfHwga2V5LmVuZHNXaXRoKCc6aHJlZicpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmF0dHJpYnV0ZXNba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvcGVydHkuZW1wdHkodGhpcy5kb2N1bWVudCk7XG4gIH1cblxuICBnZXRTdHlsZShuYW1lKSB7XG4gICAgdmFyIGNyZWF0ZUlmTm90RXhpc3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICB2YXIgc2tpcEFuY2VzdG9ycyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgdmFyIHN0eWxlID0gdGhpcy5zdHlsZXNbbmFtZV07XG5cbiAgICBpZiAoc3R5bGUpIHtcbiAgICAgIHJldHVybiBzdHlsZTtcbiAgICB9XG5cbiAgICB2YXIgYXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXG4gICAgaWYgKGF0dHIgIT09IG51bGwgJiYgYXR0ciAhPT0gdm9pZCAwICYmIGF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBhdHRyOyAvLyBtb3ZlIHVwIHRvIG1lIHRvIGNhY2hlXG5cbiAgICAgIHJldHVybiBhdHRyO1xuICAgIH1cblxuICAgIGlmICghc2tpcEFuY2VzdG9ycykge1xuICAgICAgdmFyIHtcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gdGhpcztcblxuICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICB2YXIgcGFyZW50U3R5bGUgPSBwYXJlbnQuZ2V0U3R5bGUobmFtZSk7XG5cbiAgICAgICAgaWYgKHBhcmVudFN0eWxlICE9PSBudWxsICYmIHBhcmVudFN0eWxlICE9PSB2b2lkIDAgJiYgcGFyZW50U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICAgIHJldHVybiBwYXJlbnRTdHlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjcmVhdGVJZk5vdEV4aXN0cykge1xuICAgICAgdmFyIF9zdHlsZSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCBuYW1lLCAnJyk7XG5cbiAgICAgIHRoaXMuc3R5bGVzW25hbWVdID0gX3N0eWxlO1xuICAgICAgcmV0dXJuIF9zdHlsZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3R5bGUgfHwgUHJvcGVydHkuZW1wdHkodGhpcy5kb2N1bWVudCk7XG4gIH1cblxuICByZW5kZXIoY3R4KSB7XG4gICAgLy8gZG9uJ3QgcmVuZGVyIGRpc3BsYXk9bm9uZVxuICAgIC8vIGRvbid0IHJlbmRlciB2aXNpYmlsaXR5PWhpZGRlblxuICAgIGlmICh0aGlzLmdldFN0eWxlKCdkaXNwbGF5JykuZ2V0U3RyaW5nKCkgPT09ICdub25lJyB8fCB0aGlzLmdldFN0eWxlKCd2aXNpYmlsaXR5JykuZ2V0U3RyaW5nKCkgPT09ICdoaWRkZW4nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcblxuICAgIGlmICh0aGlzLmdldFN0eWxlKCdtYXNrJykuaGFzVmFsdWUoKSkge1xuICAgICAgLy8gbWFza1xuICAgICAgdmFyIG1hc2sgPSB0aGlzLmdldFN0eWxlKCdtYXNrJykuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICBpZiAobWFzaykge1xuICAgICAgICB0aGlzLmFwcGx5RWZmZWN0cyhjdHgpO1xuICAgICAgICBtYXNrLmFwcGx5KGN0eCwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmdldFN0eWxlKCdmaWx0ZXInKS5nZXRWYWx1ZSgnbm9uZScpICE9PSAnbm9uZScpIHtcbiAgICAgIC8vIGZpbHRlclxuICAgICAgdmFyIGZpbHRlciA9IHRoaXMuZ2V0U3R5bGUoJ2ZpbHRlcicpLmdldERlZmluaXRpb24oKTtcblxuICAgICAgaWYgKGZpbHRlcikge1xuICAgICAgICB0aGlzLmFwcGx5RWZmZWN0cyhjdHgpO1xuICAgICAgICBmaWx0ZXIuYXBwbHkoY3R4LCB0aGlzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDb250ZXh0KGN0eCk7XG4gICAgICB0aGlzLnJlbmRlckNoaWxkcmVuKGN0eCk7XG4gICAgICB0aGlzLmNsZWFyQ29udGV4dChjdHgpO1xuICAgIH1cblxuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH1cblxuICBzZXRDb250ZXh0KF8pIHsvLyBOTyBSRU5ERVJcbiAgfVxuXG4gIGFwcGx5RWZmZWN0cyhjdHgpIHtcbiAgICAvLyB0cmFuc2Zvcm1cbiAgICB2YXIgdHJhbnNmb3JtID0gVHJhbnNmb3JtLmZyb21FbGVtZW50KHRoaXMuZG9jdW1lbnQsIHRoaXMpO1xuXG4gICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgdHJhbnNmb3JtLmFwcGx5KGN0eCk7XG4gICAgfSAvLyBjbGlwXG5cblxuICAgIHZhciBjbGlwUGF0aFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2NsaXAtcGF0aCcsIGZhbHNlLCB0cnVlKTtcblxuICAgIGlmIChjbGlwUGF0aFN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICB2YXIgY2xpcCA9IGNsaXBQYXRoU3R5bGVQcm9wLmdldERlZmluaXRpb24oKTtcblxuICAgICAgaWYgKGNsaXApIHtcbiAgICAgICAgY2xpcC5hcHBseShjdHgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGNsZWFyQ29udGV4dChfKSB7Ly8gTk8gUkVOREVSXG4gIH1cblxuICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgY2hpbGQucmVuZGVyKGN0eCk7XG4gICAgfSk7XG4gIH1cblxuICBhZGRDaGlsZChjaGlsZE5vZGUpIHtcbiAgICB2YXIgY2hpbGQgPSBjaGlsZE5vZGUgaW5zdGFuY2VvZiBFbGVtZW50ID8gY2hpbGROb2RlIDogdGhpcy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KGNoaWxkTm9kZSk7XG4gICAgY2hpbGQucGFyZW50ID0gdGhpcztcblxuICAgIGlmICghRWxlbWVudC5pZ25vcmVDaGlsZFR5cGVzLmluY2x1ZGVzKGNoaWxkLnR5cGUpKSB7XG4gICAgICB0aGlzLmNoaWxkcmVuLnB1c2goY2hpbGQpO1xuICAgIH1cbiAgfVxuXG4gIG1hdGNoZXNTZWxlY3RvcihzZWxlY3Rvcikge1xuICAgIHZhciBfbm9kZSRnZXRBdHRyaWJ1dGU7XG5cbiAgICB2YXIge1xuICAgICAgbm9kZVxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKHR5cGVvZiBub2RlLm1hdGNoZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBub2RlLm1hdGNoZXMoc2VsZWN0b3IpO1xuICAgIH1cblxuICAgIHZhciBzdHlsZUNsYXNzZXMgPSAoX25vZGUkZ2V0QXR0cmlidXRlID0gbm9kZS5nZXRBdHRyaWJ1dGUpID09PSBudWxsIHx8IF9ub2RlJGdldEF0dHJpYnV0ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX25vZGUkZ2V0QXR0cmlidXRlLmNhbGwobm9kZSwgJ2NsYXNzJyk7XG5cbiAgICBpZiAoIXN0eWxlQ2xhc3NlcyB8fCBzdHlsZUNsYXNzZXMgPT09ICcnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0eWxlQ2xhc3Nlcy5zcGxpdCgnICcpLnNvbWUoc3R5bGVDbGFzcyA9PiBcIi5cIi5jb25jYXQoc3R5bGVDbGFzcykgPT09IHNlbGVjdG9yKTtcbiAgfVxuXG4gIGFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKSB7XG4gICAgdmFyIHtcbiAgICAgIHN0eWxlcyxcbiAgICAgIHN0eWxlc1NwZWNpZmljaXR5XG4gICAgfSA9IHRoaXMuZG9jdW1lbnQ7XG5cbiAgICBmb3IgKHZhciBzZWxlY3RvciBpbiBzdHlsZXMpIHtcbiAgICAgIGlmICghc2VsZWN0b3Iuc3RhcnRzV2l0aCgnQCcpICYmIHRoaXMubWF0Y2hlc1NlbGVjdG9yKHNlbGVjdG9yKSkge1xuICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbc2VsZWN0b3JdO1xuICAgICAgICB2YXIgc3BlY2lmaWNpdHkgPSBzdHlsZXNTcGVjaWZpY2l0eVtzZWxlY3Rvcl07XG5cbiAgICAgICAgaWYgKHN0eWxlKSB7XG4gICAgICAgICAgZm9yICh2YXIgbmFtZSBpbiBzdHlsZSkge1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nU3BlY2lmaWNpdHkgPSB0aGlzLnN0eWxlc1NwZWNpZmljaXR5W25hbWVdO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGV4aXN0aW5nU3BlY2lmaWNpdHkgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgIGV4aXN0aW5nU3BlY2lmaWNpdHkgPSAnMDAwJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNwZWNpZmljaXR5ID49IGV4aXN0aW5nU3BlY2lmaWNpdHkpIHtcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZXNbbmFtZV0gPSBzdHlsZVtuYW1lXTtcbiAgICAgICAgICAgICAgdGhpcy5zdHlsZXNTcGVjaWZpY2l0eVtuYW1lXSA9IHNwZWNpZmljaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlbW92ZVN0eWxlcyhlbGVtZW50LCBpZ25vcmVTdHlsZXMpIHtcbiAgICB2YXIgdG9SZXN0b3JlID0gaWdub3JlU3R5bGVzLnJlZHVjZSgodG9SZXN0b3JlLCBuYW1lKSA9PiB7XG4gICAgICB2YXIgc3R5bGVQcm9wID0gZWxlbWVudC5nZXRTdHlsZShuYW1lKTtcblxuICAgICAgaWYgKCFzdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICByZXR1cm4gdG9SZXN0b3JlO1xuICAgICAgfVxuXG4gICAgICB2YXIgdmFsdWUgPSBzdHlsZVByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICBzdHlsZVByb3Auc2V0VmFsdWUoJycpO1xuICAgICAgcmV0dXJuIFsuLi50b1Jlc3RvcmUsIFtuYW1lLCB2YWx1ZV1dO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gdG9SZXN0b3JlO1xuICB9XG5cbiAgcmVzdG9yZVN0eWxlcyhlbGVtZW50LCBzdHlsZXMpIHtcbiAgICBzdHlsZXMuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgIHZhciBbbmFtZSwgdmFsdWVdID0gX3JlZjtcbiAgICAgIGVsZW1lbnQuZ2V0U3R5bGUobmFtZSwgdHJ1ZSkuc2V0VmFsdWUodmFsdWUpO1xuICAgIH0pO1xuICB9XG5cbiAgaXNGaXJzdENoaWxkKCkge1xuICAgIHZhciBfdGhpcyRwYXJlbnQ7XG5cbiAgICByZXR1cm4gKChfdGhpcyRwYXJlbnQgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX3RoaXMkcGFyZW50ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfdGhpcyRwYXJlbnQuY2hpbGRyZW4uaW5kZXhPZih0aGlzKSkgPT09IDA7XG4gIH1cblxufVxuRWxlbWVudC5pZ25vcmVDaGlsZFR5cGVzID0gWyd0aXRsZSddO1xuXG5jbGFzcyBVbmtub3duRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIHdyYXBGb250RmFtaWx5KGZvbnRGYW1pbHkpIHtcbiAgdmFyIHRyaW1tZWQgPSBmb250RmFtaWx5LnRyaW0oKTtcbiAgcmV0dXJuIC9eKCd8XCIpLy50ZXN0KHRyaW1tZWQpID8gdHJpbW1lZCA6IFwiXFxcIlwiLmNvbmNhdCh0cmltbWVkLCBcIlxcXCJcIik7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVGb250RmFtaWx5KGZvbnRGYW1pbHkpIHtcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzID09PSAndW5kZWZpbmVkJyA/IGZvbnRGYW1pbHkgOiBmb250RmFtaWx5LnRyaW0oKS5zcGxpdCgnLCcpLm1hcCh3cmFwRm9udEZhbWlseSkuam9pbignLCcpO1xufVxuLyoqXHJcbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9mb250LXN0eWxlXHJcbiAqIEBwYXJhbSBmb250U3R5bGVcclxuICogQHJldHVybnMgQ1NTIGZvbnQgc3R5bGUuXHJcbiAqL1xuXG5cbmZ1bmN0aW9uIHByZXBhcmVGb250U3R5bGUoZm9udFN0eWxlKSB7XG4gIGlmICghZm9udFN0eWxlKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIHRhcmdldEZvbnRTdHlsZSA9IGZvbnRTdHlsZS50cmltKCkudG9Mb3dlckNhc2UoKTtcblxuICBzd2l0Y2ggKHRhcmdldEZvbnRTdHlsZSkge1xuICAgIGNhc2UgJ25vcm1hbCc6XG4gICAgY2FzZSAnaXRhbGljJzpcbiAgICBjYXNlICdvYmxpcXVlJzpcbiAgICBjYXNlICdpbmhlcml0JzpcbiAgICBjYXNlICdpbml0aWFsJzpcbiAgICBjYXNlICd1bnNldCc6XG4gICAgICByZXR1cm4gdGFyZ2V0Rm9udFN0eWxlO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICgvXm9ibGlxdWVcXHMrKC18KVxcZCtkZWckLy50ZXN0KHRhcmdldEZvbnRTdHlsZSkpIHtcbiAgICAgICAgcmV0dXJuIHRhcmdldEZvbnRTdHlsZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcclxuICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL2ZvbnQtd2VpZ2h0XHJcbiAqIEBwYXJhbSBmb250V2VpZ2h0XHJcbiAqIEByZXR1cm5zIENTUyBmb250IHdlaWdodC5cclxuICovXG5cblxuZnVuY3Rpb24gcHJlcGFyZUZvbnRXZWlnaHQoZm9udFdlaWdodCkge1xuICBpZiAoIWZvbnRXZWlnaHQpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgdGFyZ2V0Rm9udFdlaWdodCA9IGZvbnRXZWlnaHQudHJpbSgpLnRvTG93ZXJDYXNlKCk7XG5cbiAgc3dpdGNoICh0YXJnZXRGb250V2VpZ2h0KSB7XG4gICAgY2FzZSAnbm9ybWFsJzpcbiAgICBjYXNlICdib2xkJzpcbiAgICBjYXNlICdsaWdodGVyJzpcbiAgICBjYXNlICdib2xkZXInOlxuICAgIGNhc2UgJ2luaGVyaXQnOlxuICAgIGNhc2UgJ2luaXRpYWwnOlxuICAgIGNhc2UgJ3Vuc2V0JzpcbiAgICAgIHJldHVybiB0YXJnZXRGb250V2VpZ2h0O1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIGlmICgvXltcXGQuXSskLy50ZXN0KHRhcmdldEZvbnRXZWlnaHQpKSB7XG4gICAgICAgIHJldHVybiB0YXJnZXRGb250V2VpZ2h0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuY2xhc3MgRm9udCB7XG4gIGNvbnN0cnVjdG9yKGZvbnRTdHlsZSwgZm9udFZhcmlhbnQsIGZvbnRXZWlnaHQsIGZvbnRTaXplLCBmb250RmFtaWx5LCBpbmhlcml0KSB7XG4gICAgdmFyIGluaGVyaXRGb250ID0gaW5oZXJpdCA/IHR5cGVvZiBpbmhlcml0ID09PSAnc3RyaW5nJyA/IEZvbnQucGFyc2UoaW5oZXJpdCkgOiBpbmhlcml0IDoge307XG4gICAgdGhpcy5mb250RmFtaWx5ID0gZm9udEZhbWlseSB8fCBpbmhlcml0Rm9udC5mb250RmFtaWx5O1xuICAgIHRoaXMuZm9udFNpemUgPSBmb250U2l6ZSB8fCBpbmhlcml0Rm9udC5mb250U2l6ZTtcbiAgICB0aGlzLmZvbnRTdHlsZSA9IGZvbnRTdHlsZSB8fCBpbmhlcml0Rm9udC5mb250U3R5bGU7XG4gICAgdGhpcy5mb250V2VpZ2h0ID0gZm9udFdlaWdodCB8fCBpbmhlcml0Rm9udC5mb250V2VpZ2h0O1xuICAgIHRoaXMuZm9udFZhcmlhbnQgPSBmb250VmFyaWFudCB8fCBpbmhlcml0Rm9udC5mb250VmFyaWFudDtcbiAgfVxuXG4gIHN0YXRpYyBwYXJzZSgpIHtcbiAgICB2YXIgZm9udCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJyc7XG4gICAgdmFyIGluaGVyaXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZm9udFN0eWxlID0gJyc7XG4gICAgdmFyIGZvbnRWYXJpYW50ID0gJyc7XG4gICAgdmFyIGZvbnRXZWlnaHQgPSAnJztcbiAgICB2YXIgZm9udFNpemUgPSAnJztcbiAgICB2YXIgZm9udEZhbWlseSA9ICcnO1xuICAgIHZhciBwYXJ0cyA9IGNvbXByZXNzU3BhY2VzKGZvbnQpLnRyaW0oKS5zcGxpdCgnICcpO1xuICAgIHZhciBzZXQgPSB7XG4gICAgICBmb250U2l6ZTogZmFsc2UsXG4gICAgICBmb250U3R5bGU6IGZhbHNlLFxuICAgICAgZm9udFdlaWdodDogZmFsc2UsXG4gICAgICBmb250VmFyaWFudDogZmFsc2VcbiAgICB9O1xuICAgIHBhcnRzLmZvckVhY2gocGFydCA9PiB7XG4gICAgICBzd2l0Y2ggKHRydWUpIHtcbiAgICAgICAgY2FzZSAhc2V0LmZvbnRTdHlsZSAmJiBGb250LnN0eWxlcy5pbmNsdWRlcyhwYXJ0KTpcbiAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICBmb250U3R5bGUgPSBwYXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNldC5mb250U3R5bGUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgIXNldC5mb250VmFyaWFudCAmJiBGb250LnZhcmlhbnRzLmluY2x1ZGVzKHBhcnQpOlxuICAgICAgICAgIGlmIChwYXJ0ICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICAgIGZvbnRWYXJpYW50ID0gcGFydDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXQuZm9udFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICBzZXQuZm9udFZhcmlhbnQgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgIXNldC5mb250V2VpZ2h0ICYmIEZvbnQud2VpZ2h0cy5pbmNsdWRlcyhwYXJ0KTpcbiAgICAgICAgICBpZiAocGFydCAhPT0gJ2luaGVyaXQnKSB7XG4gICAgICAgICAgICBmb250V2VpZ2h0ID0gcGFydDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXQuZm9udFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICBzZXQuZm9udFZhcmlhbnQgPSB0cnVlO1xuICAgICAgICAgIHNldC5mb250V2VpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICFzZXQuZm9udFNpemU6XG4gICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgW2ZvbnRTaXplXSA9IHBhcnQuc3BsaXQoJy8nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzZXQuZm9udFN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICBzZXQuZm9udFZhcmlhbnQgPSB0cnVlO1xuICAgICAgICAgIHNldC5mb250V2VpZ2h0ID0gdHJ1ZTtcbiAgICAgICAgICBzZXQuZm9udFNpemUgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKHBhcnQgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgICAgZm9udEZhbWlseSArPSBwYXJ0O1xuICAgICAgICAgIH1cblxuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBuZXcgRm9udChmb250U3R5bGUsIGZvbnRWYXJpYW50LCBmb250V2VpZ2h0LCBmb250U2l6ZSwgZm9udEZhbWlseSwgaW5oZXJpdCk7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gW3ByZXBhcmVGb250U3R5bGUodGhpcy5mb250U3R5bGUpLCB0aGlzLmZvbnRWYXJpYW50LCBwcmVwYXJlRm9udFdlaWdodCh0aGlzLmZvbnRXZWlnaHQpLCB0aGlzLmZvbnRTaXplLCAvLyBXcmFwIGZvbnRGYW1pbHkgb25seSBvbiBub2RlanMgYW5kIG9ubHkgZm9yIGNhbnZhcy5jdHhcbiAgICBwcmVwYXJlRm9udEZhbWlseSh0aGlzLmZvbnRGYW1pbHkpXS5qb2luKCcgJykudHJpbSgpO1xuICB9XG5cbn1cbkZvbnQuc3R5bGVzID0gJ25vcm1hbHxpdGFsaWN8b2JsaXF1ZXxpbmhlcml0JztcbkZvbnQudmFyaWFudHMgPSAnbm9ybWFsfHNtYWxsLWNhcHN8aW5oZXJpdCc7XG5Gb250LndlaWdodHMgPSAnbm9ybWFsfGJvbGR8Ym9sZGVyfGxpZ2h0ZXJ8MTAwfDIwMHwzMDB8NDAwfDUwMHw2MDB8NzAwfDgwMHw5MDB8aW5oZXJpdCc7XG5cbmNsYXNzIEJvdW5kaW5nQm94IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdmFyIHgxID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBOdW1iZXIuTmFOO1xuICAgIHZhciB5MSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogTnVtYmVyLk5hTjtcbiAgICB2YXIgeDIgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IE51bWJlci5OYU47XG4gICAgdmFyIHkyID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiBOdW1iZXIuTmFOO1xuICAgIHRoaXMueDEgPSB4MTtcbiAgICB0aGlzLnkxID0geTE7XG4gICAgdGhpcy54MiA9IHgyO1xuICAgIHRoaXMueTIgPSB5MjtcbiAgICB0aGlzLmFkZFBvaW50KHgxLCB5MSk7XG4gICAgdGhpcy5hZGRQb2ludCh4MiwgeTIpO1xuICB9XG5cbiAgZ2V0IHgoKSB7XG4gICAgcmV0dXJuIHRoaXMueDE7XG4gIH1cblxuICBnZXQgeSgpIHtcbiAgICByZXR1cm4gdGhpcy55MTtcbiAgfVxuXG4gIGdldCB3aWR0aCgpIHtcbiAgICByZXR1cm4gdGhpcy54MiAtIHRoaXMueDE7XG4gIH1cblxuICBnZXQgaGVpZ2h0KCkge1xuICAgIHJldHVybiB0aGlzLnkyIC0gdGhpcy55MTtcbiAgfVxuXG4gIGFkZFBvaW50KHgsIHkpIHtcbiAgICBpZiAodHlwZW9mIHggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoaXNOYU4odGhpcy54MSkgfHwgaXNOYU4odGhpcy54MikpIHtcbiAgICAgICAgdGhpcy54MSA9IHg7XG4gICAgICAgIHRoaXMueDIgPSB4O1xuICAgICAgfVxuXG4gICAgICBpZiAoeCA8IHRoaXMueDEpIHtcbiAgICAgICAgdGhpcy54MSA9IHg7XG4gICAgICB9XG5cbiAgICAgIGlmICh4ID4gdGhpcy54Mikge1xuICAgICAgICB0aGlzLngyID0geDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBpZiAoaXNOYU4odGhpcy55MSkgfHwgaXNOYU4odGhpcy55MikpIHtcbiAgICAgICAgdGhpcy55MSA9IHk7XG4gICAgICAgIHRoaXMueTIgPSB5O1xuICAgICAgfVxuXG4gICAgICBpZiAoeSA8IHRoaXMueTEpIHtcbiAgICAgICAgdGhpcy55MSA9IHk7XG4gICAgICB9XG5cbiAgICAgIGlmICh5ID4gdGhpcy55Mikge1xuICAgICAgICB0aGlzLnkyID0geTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBhZGRYKHgpIHtcbiAgICB0aGlzLmFkZFBvaW50KHgsIG51bGwpO1xuICB9XG5cbiAgYWRkWSh5KSB7XG4gICAgdGhpcy5hZGRQb2ludChudWxsLCB5KTtcbiAgfVxuXG4gIGFkZEJvdW5kaW5nQm94KGJvdW5kaW5nQm94KSB7XG4gICAgaWYgKCFib3VuZGluZ0JveCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICB4MSxcbiAgICAgIHkxLFxuICAgICAgeDIsXG4gICAgICB5MlxuICAgIH0gPSBib3VuZGluZ0JveDtcbiAgICB0aGlzLmFkZFBvaW50KHgxLCB5MSk7XG4gICAgdGhpcy5hZGRQb2ludCh4MiwgeTIpO1xuICB9XG5cbiAgc3VtQ3ViaWModCwgcDAsIHAxLCBwMiwgcDMpIHtcbiAgICByZXR1cm4gTWF0aC5wb3coMSAtIHQsIDMpICogcDAgKyAzICogTWF0aC5wb3coMSAtIHQsIDIpICogdCAqIHAxICsgMyAqICgxIC0gdCkgKiBNYXRoLnBvdyh0LCAyKSAqIHAyICsgTWF0aC5wb3codCwgMykgKiBwMztcbiAgfVxuXG4gIGJlemllckN1cnZlQWRkKGZvclgsIHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgdmFyIGIgPSA2ICogcDAgLSAxMiAqIHAxICsgNiAqIHAyO1xuICAgIHZhciBhID0gLTMgKiBwMCArIDkgKiBwMSAtIDkgKiBwMiArIDMgKiBwMztcbiAgICB2YXIgYyA9IDMgKiBwMSAtIDMgKiBwMDtcblxuICAgIGlmIChhID09PSAwKSB7XG4gICAgICBpZiAoYiA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0ID0gLWMgLyBiO1xuXG4gICAgICBpZiAoMCA8IHQgJiYgdCA8IDEpIHtcbiAgICAgICAgaWYgKGZvclgpIHtcbiAgICAgICAgICB0aGlzLmFkZFgodGhpcy5zdW1DdWJpYyh0LCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuYWRkWSh0aGlzLnN1bUN1YmljKHQsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBiMmFjID0gTWF0aC5wb3coYiwgMikgLSA0ICogYyAqIGE7XG5cbiAgICBpZiAoYjJhYyA8IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgdDEgPSAoLWIgKyBNYXRoLnNxcnQoYjJhYykpIC8gKDIgKiBhKTtcblxuICAgIGlmICgwIDwgdDEgJiYgdDEgPCAxKSB7XG4gICAgICBpZiAoZm9yWCkge1xuICAgICAgICB0aGlzLmFkZFgodGhpcy5zdW1DdWJpYyh0MSwgcDAsIHAxLCBwMiwgcDMpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYWRkWSh0aGlzLnN1bUN1YmljKHQxLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0MiA9ICgtYiAtIE1hdGguc3FydChiMmFjKSkgLyAoMiAqIGEpO1xuXG4gICAgaWYgKDAgPCB0MiAmJiB0MiA8IDEpIHtcbiAgICAgIGlmIChmb3JYKSB7XG4gICAgICAgIHRoaXMuYWRkWCh0aGlzLnN1bUN1YmljKHQyLCBwMCwgcDEsIHAyLCBwMykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5hZGRZKHRoaXMuc3VtQ3ViaWModDIsIHAwLCBwMSwgcDIsIHAzKSk7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIGZyb20gaHR0cDovL2Jsb2cuaGFja2Vycy1jYWZlLm5ldC8yMDA5LzA2L2hvdy10by1jYWxjdWxhdGUtYmV6aWVyLWN1cnZlcy1ib3VuZGluZy5odG1sXG5cblxuICBhZGRCZXppZXJDdXJ2ZShwMHgsIHAweSwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwM3gsIHAzeSkge1xuICAgIHRoaXMuYWRkUG9pbnQocDB4LCBwMHkpO1xuICAgIHRoaXMuYWRkUG9pbnQocDN4LCBwM3kpO1xuICAgIHRoaXMuYmV6aWVyQ3VydmVBZGQodHJ1ZSwgcDB4LCBwMXgsIHAyeCwgcDN4KTtcbiAgICB0aGlzLmJlemllckN1cnZlQWRkKGZhbHNlLCBwMHksIHAxeSwgcDJ5LCBwM3kpO1xuICB9XG5cbiAgYWRkUXVhZHJhdGljQ3VydmUocDB4LCBwMHksIHAxeCwgcDF5LCBwMngsIHAyeSkge1xuICAgIHZhciBjcDF4ID0gcDB4ICsgMiAvIDMgKiAocDF4IC0gcDB4KTsgLy8gQ1AxID0gUVAwICsgMi8zICooUVAxLVFQMClcblxuICAgIHZhciBjcDF5ID0gcDB5ICsgMiAvIDMgKiAocDF5IC0gcDB5KTsgLy8gQ1AxID0gUVAwICsgMi8zICooUVAxLVFQMClcblxuICAgIHZhciBjcDJ4ID0gY3AxeCArIDEgLyAzICogKHAyeCAtIHAweCk7IC8vIENQMiA9IENQMSArIDEvMyAqKFFQMi1RUDApXG5cbiAgICB2YXIgY3AyeSA9IGNwMXkgKyAxIC8gMyAqIChwMnkgLSBwMHkpOyAvLyBDUDIgPSBDUDEgKyAxLzMgKihRUDItUVAwKVxuXG4gICAgdGhpcy5hZGRCZXppZXJDdXJ2ZShwMHgsIHAweSwgY3AxeCwgY3AyeCwgY3AxeSwgY3AyeSwgcDJ4LCBwMnkpO1xuICB9XG5cbiAgaXNQb2ludEluQm94KHgsIHkpIHtcbiAgICB2YXIge1xuICAgICAgeDEsXG4gICAgICB5MSxcbiAgICAgIHgyLFxuICAgICAgeTJcbiAgICB9ID0gdGhpcztcbiAgICByZXR1cm4geDEgPD0geCAmJiB4IDw9IHgyICYmIHkxIDw9IHkgJiYgeSA8PSB5MjtcbiAgfVxuXG59XG5cbmNsYXNzIFBhdGhQYXJzZXIgZXh0ZW5kcyBTVkdQYXRoRGF0YSB7XG4gIGNvbnN0cnVjdG9yKHBhdGgpIHtcbiAgICBzdXBlcihwYXRoIC8vIEZpeCBzcGFjZXMgYWZ0ZXIgc2lnbnMuXG4gICAgLnJlcGxhY2UoLyhbK1xcLS5dKVxccysvZ20sICckMScpIC8vIFJlbW92ZSBpbnZhbGlkIHBhcnQuXG4gICAgLnJlcGxhY2UoL1teTW1aekxsSGhWdkNjU3NRcVR0QWFlXFxkXFxzLiwrLV0uKi9nLCAnJykpO1xuICAgIHRoaXMuY29udHJvbCA9IG51bGw7XG4gICAgdGhpcy5zdGFydCA9IG51bGw7XG4gICAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgICB0aGlzLmNvbW1hbmQgPSBudWxsO1xuICAgIHRoaXMuY29tbWFuZHMgPSB0aGlzLmNvbW1hbmRzO1xuICAgIHRoaXMuaSA9IC0xO1xuICAgIHRoaXMucHJldmlvdXNDb21tYW5kID0gbnVsbDtcbiAgICB0aGlzLnBvaW50cyA9IFtdO1xuICAgIHRoaXMuYW5nbGVzID0gW107XG4gIH1cblxuICByZXNldCgpIHtcbiAgICB0aGlzLmkgPSAtMTtcbiAgICB0aGlzLmNvbW1hbmQgPSBudWxsO1xuICAgIHRoaXMucHJldmlvdXNDb21tYW5kID0gbnVsbDtcbiAgICB0aGlzLnN0YXJ0ID0gbmV3IFBvaW50KDAsIDApO1xuICAgIHRoaXMuY29udHJvbCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBuZXcgUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICB0aGlzLmFuZ2xlcyA9IFtdO1xuICB9XG5cbiAgaXNFbmQoKSB7XG4gICAgdmFyIHtcbiAgICAgIGksXG4gICAgICBjb21tYW5kc1xuICAgIH0gPSB0aGlzO1xuICAgIHJldHVybiBpID49IGNvbW1hbmRzLmxlbmd0aCAtIDE7XG4gIH1cblxuICBuZXh0KCkge1xuICAgIHZhciBjb21tYW5kID0gdGhpcy5jb21tYW5kc1srK3RoaXMuaV07XG4gICAgdGhpcy5wcmV2aW91c0NvbW1hbmQgPSB0aGlzLmNvbW1hbmQ7XG4gICAgdGhpcy5jb21tYW5kID0gY29tbWFuZDtcbiAgICByZXR1cm4gY29tbWFuZDtcbiAgfVxuXG4gIGdldFBvaW50KCkge1xuICAgIHZhciB4UHJvcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogJ3gnO1xuICAgIHZhciB5UHJvcCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3knO1xuICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCh0aGlzLmNvbW1hbmRbeFByb3BdLCB0aGlzLmNvbW1hbmRbeVByb3BdKTtcbiAgICByZXR1cm4gdGhpcy5tYWtlQWJzb2x1dGUocG9pbnQpO1xuICB9XG5cbiAgZ2V0QXNDb250cm9sUG9pbnQoeFByb3AsIHlQcm9wKSB7XG4gICAgdmFyIHBvaW50ID0gdGhpcy5nZXRQb2ludCh4UHJvcCwgeVByb3ApO1xuICAgIHRoaXMuY29udHJvbCA9IHBvaW50O1xuICAgIHJldHVybiBwb2ludDtcbiAgfVxuXG4gIGdldEFzQ3VycmVudFBvaW50KHhQcm9wLCB5UHJvcCkge1xuICAgIHZhciBwb2ludCA9IHRoaXMuZ2V0UG9pbnQoeFByb3AsIHlQcm9wKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBwb2ludDtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICBnZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQoKSB7XG4gICAgdmFyIHByZXZpb3VzQ29tbWFuZCA9IHRoaXMucHJldmlvdXNDb21tYW5kLnR5cGU7XG5cbiAgICBpZiAocHJldmlvdXNDb21tYW5kICE9PSBTVkdQYXRoRGF0YS5DVVJWRV9UTyAmJiBwcmV2aW91c0NvbW1hbmQgIT09IFNWR1BhdGhEYXRhLlNNT09USF9DVVJWRV9UTyAmJiBwcmV2aW91c0NvbW1hbmQgIT09IFNWR1BhdGhEYXRhLlFVQURfVE8gJiYgcHJldmlvdXNDb21tYW5kICE9PSBTVkdQYXRoRGF0YS5TTU9PVEhfUVVBRF9UTykge1xuICAgICAgcmV0dXJuIHRoaXMuY3VycmVudDtcbiAgICB9IC8vIHJlZmxlY3QgcG9pbnRcblxuXG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQ6IHtcbiAgICAgICAgeDogY3gsXG4gICAgICAgIHk6IGN5XG4gICAgICB9LFxuICAgICAgY29udHJvbDoge1xuICAgICAgICB4OiBveCxcbiAgICAgICAgeTogb3lcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICB2YXIgcG9pbnQgPSBuZXcgUG9pbnQoMiAqIGN4IC0gb3gsIDIgKiBjeSAtIG95KTtcbiAgICByZXR1cm4gcG9pbnQ7XG4gIH1cblxuICBtYWtlQWJzb2x1dGUocG9pbnQpIHtcbiAgICBpZiAodGhpcy5jb21tYW5kLnJlbGF0aXZlKSB7XG4gICAgICB2YXIge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gdGhpcy5jdXJyZW50O1xuICAgICAgcG9pbnQueCArPSB4O1xuICAgICAgcG9pbnQueSArPSB5O1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludDtcbiAgfVxuXG4gIGFkZE1hcmtlcihwb2ludCwgZnJvbSwgcHJpb3JUbykge1xuICAgIHZhciB7XG4gICAgICBwb2ludHMsXG4gICAgICBhbmdsZXNcbiAgICB9ID0gdGhpczsgLy8gaWYgdGhlIGxhc3QgYW5nbGUgaXNuJ3QgZmlsbGVkIGluIGJlY2F1c2Ugd2UgZGlkbid0IGhhdmUgdGhpcyBwb2ludCB5ZXQgLi4uXG5cbiAgICBpZiAocHJpb3JUbyAmJiBhbmdsZXMubGVuZ3RoID4gMCAmJiAhYW5nbGVzW2FuZ2xlcy5sZW5ndGggLSAxXSkge1xuICAgICAgYW5nbGVzW2FuZ2xlcy5sZW5ndGggLSAxXSA9IHBvaW50c1twb2ludHMubGVuZ3RoIC0gMV0uYW5nbGVUbyhwcmlvclRvKTtcbiAgICB9XG5cbiAgICB0aGlzLmFkZE1hcmtlckFuZ2xlKHBvaW50LCBmcm9tID8gZnJvbS5hbmdsZVRvKHBvaW50KSA6IG51bGwpO1xuICB9XG5cbiAgYWRkTWFya2VyQW5nbGUocG9pbnQsIGFuZ2xlKSB7XG4gICAgdGhpcy5wb2ludHMucHVzaChwb2ludCk7XG4gICAgdGhpcy5hbmdsZXMucHVzaChhbmdsZSk7XG4gIH1cblxuICBnZXRNYXJrZXJQb2ludHMoKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRzO1xuICB9XG5cbiAgZ2V0TWFya2VyQW5nbGVzKCkge1xuICAgIHZhciB7XG4gICAgICBhbmdsZXNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgbGVuID0gYW5nbGVzLmxlbmd0aDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGlmICghYW5nbGVzW2ldKSB7XG4gICAgICAgIGZvciAodmFyIGogPSBpICsgMTsgaiA8IGxlbjsgaisrKSB7XG4gICAgICAgICAgaWYgKGFuZ2xlc1tqXSkge1xuICAgICAgICAgICAgYW5nbGVzW2ldID0gYW5nbGVzW2pdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGFuZ2xlcztcbiAgfVxuXG59XG5cbmNsYXNzIFJlbmRlcmVkRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubW9kaWZpZWRFbVNpemVTdGFjayA9IGZhbHNlO1xuICB9XG5cbiAgY2FsY3VsYXRlT3BhY2l0eSgpIHtcbiAgICB2YXIgb3BhY2l0eSA9IDEuMDsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby10aGlzLWFsaWFzLCBjb25zaXN0ZW50LXRoaXNcblxuICAgIHZhciBlbGVtZW50ID0gdGhpcztcblxuICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3BhY2l0eVN0eWxlID0gZWxlbWVudC5nZXRTdHlsZSgnb3BhY2l0eScsIGZhbHNlLCB0cnVlKTsgLy8gbm8gYW5jZXN0b3JzIG9uIHN0eWxlIGNhbGxcblxuICAgICAgaWYgKG9wYWNpdHlTdHlsZS5oYXNWYWx1ZSh0cnVlKSkge1xuICAgICAgICBvcGFjaXR5ICo9IG9wYWNpdHlTdHlsZS5nZXROdW1iZXIoKTtcbiAgICAgIH1cblxuICAgICAgZWxlbWVudCA9IGVsZW1lbnQucGFyZW50O1xuICAgIH1cblxuICAgIHJldHVybiBvcGFjaXR5O1xuICB9XG5cbiAgc2V0Q29udGV4dChjdHgpIHtcbiAgICB2YXIgZnJvbU1lYXN1cmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuXG4gICAgaWYgKCFmcm9tTWVhc3VyZSkge1xuICAgICAgLy8gY2F1c2VzIHN0YWNrIG92ZXJmbG93IHdoZW4gbWVhc3VyaW5nIHRleHQgd2l0aCBncmFkaWVudHNcbiAgICAgIC8vIGZpbGxcbiAgICAgIHZhciBmaWxsU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZmlsbCcpO1xuICAgICAgdmFyIGZpbGxPcGFjaXR5U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZmlsbC1vcGFjaXR5Jyk7XG4gICAgICB2YXIgc3Ryb2tlU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlJyk7XG4gICAgICB2YXIgc3Ryb2tlT3BhY2l0eVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2Utb3BhY2l0eScpO1xuXG4gICAgICBpZiAoZmlsbFN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICB2YXIgZmlsbFN0eWxlID0gZmlsbFN0eWxlUHJvcC5nZXRGaWxsU3R5bGVEZWZpbml0aW9uKHRoaXMsIGZpbGxPcGFjaXR5U3R5bGVQcm9wKTtcblxuICAgICAgICBpZiAoZmlsbFN0eWxlKSB7XG4gICAgICAgICAgY3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChmaWxsU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgaWYgKGZpbGxTdHlsZVByb3AuZ2V0U3RyaW5nKCkgPT09ICdjdXJyZW50Q29sb3InKSB7XG4gICAgICAgICAgZmlsbFN0eWxlUHJvcC5zZXRWYWx1ZSh0aGlzLmdldFN0eWxlKCdjb2xvcicpLmdldENvbG9yKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9maWxsU3R5bGUgPSBmaWxsU3R5bGVQcm9wLmdldENvbG9yKCk7XG5cbiAgICAgICAgaWYgKF9maWxsU3R5bGUgIT09ICdpbmhlcml0Jykge1xuICAgICAgICAgIGN0eC5maWxsU3R5bGUgPSBfZmlsbFN0eWxlID09PSAnbm9uZScgPyAncmdiYSgwLDAsMCwwKScgOiBfZmlsbFN0eWxlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChmaWxsT3BhY2l0eVN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHZhciBfZmlsbFN0eWxlMiA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnZmlsbCcsIGN0eC5maWxsU3R5bGUpLmFkZE9wYWNpdHkoZmlsbE9wYWNpdHlTdHlsZVByb3ApLmdldENvbG9yKCk7XG5cbiAgICAgICAgY3R4LmZpbGxTdHlsZSA9IF9maWxsU3R5bGUyO1xuICAgICAgfSAvLyBzdHJva2VcblxuXG4gICAgICBpZiAoc3Ryb2tlU3R5bGVQcm9wLmlzVXJsRGVmaW5pdGlvbigpKSB7XG4gICAgICAgIHZhciBzdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlUHJvcC5nZXRGaWxsU3R5bGVEZWZpbml0aW9uKHRoaXMsIHN0cm9rZU9wYWNpdHlQcm9wKTtcblxuICAgICAgICBpZiAoc3Ryb2tlU3R5bGUpIHtcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VTdHlsZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdHJva2VTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICBpZiAoc3Ryb2tlU3R5bGVQcm9wLmdldFN0cmluZygpID09PSAnY3VycmVudENvbG9yJykge1xuICAgICAgICAgIHN0cm9rZVN0eWxlUHJvcC5zZXRWYWx1ZSh0aGlzLmdldFN0eWxlKCdjb2xvcicpLmdldENvbG9yKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9zdHJva2VTdHlsZSA9IHN0cm9rZVN0eWxlUHJvcC5nZXRTdHJpbmcoKTtcblxuICAgICAgICBpZiAoX3N0cm9rZVN0eWxlICE9PSAnaW5oZXJpdCcpIHtcbiAgICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBfc3Ryb2tlU3R5bGUgPT09ICdub25lJyA/ICdyZ2JhKDAsMCwwLDApJyA6IF9zdHJva2VTdHlsZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc3Ryb2tlT3BhY2l0eVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICB2YXIgX3N0cm9rZVN0eWxlMiA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnc3Ryb2tlJywgY3R4LnN0cm9rZVN0eWxlKS5hZGRPcGFjaXR5KHN0cm9rZU9wYWNpdHlQcm9wKS5nZXRTdHJpbmcoKTtcblxuICAgICAgICBjdHguc3Ryb2tlU3R5bGUgPSBfc3Ryb2tlU3R5bGUyO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3Ryb2tlV2lkdGhTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2Utd2lkdGgnKTtcblxuICAgICAgaWYgKHN0cm9rZVdpZHRoU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgdmFyIG5ld0xpbmVXaWR0aCA9IHN0cm9rZVdpZHRoU3R5bGVQcm9wLmdldFBpeGVscygpO1xuICAgICAgICBjdHgubGluZVdpZHRoID0gIW5ld0xpbmVXaWR0aCA/IFBTRVVET19aRVJPIC8vIGJyb3dzZXJzIGRvbid0IHJlc3BlY3QgMCAob3Igbm9kZS1jYW52YXM/IDotKVxuICAgICAgICA6IG5ld0xpbmVXaWR0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0cm9rZUxpbmVjYXBTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtbGluZWNhcCcpO1xuICAgICAgdmFyIHN0cm9rZUxpbmVqb2luU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLWxpbmVqb2luJyk7XG4gICAgICB2YXIgc3Ryb2tlTWl0ZXJsaW1pdFByb3AgPSB0aGlzLmdldFN0eWxlKCdzdHJva2UtbWl0ZXJsaW1pdCcpOyAvLyBORUVEIFRFU1RcbiAgICAgIC8vIGNvbnN0IHBvaW50T3JkZXJTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdwYWludC1vcmRlcicpO1xuXG4gICAgICB2YXIgc3Ryb2tlRGFzaGFycmF5U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xuICAgICAgdmFyIHN0cm9rZURhc2hvZmZzZXRQcm9wID0gdGhpcy5nZXRTdHlsZSgnc3Ryb2tlLWRhc2hvZmZzZXQnKTtcblxuICAgICAgaWYgKHN0cm9rZUxpbmVjYXBTdHlsZVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICBjdHgubGluZUNhcCA9IHN0cm9rZUxpbmVjYXBTdHlsZVByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdHJva2VMaW5lam9pblN0eWxlUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGN0eC5saW5lSm9pbiA9IHN0cm9rZUxpbmVqb2luU3R5bGVQcm9wLmdldFN0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3Ryb2tlTWl0ZXJsaW1pdFByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgICBjdHgubWl0ZXJMaW1pdCA9IHN0cm9rZU1pdGVybGltaXRQcm9wLmdldE51bWJlcigpO1xuICAgICAgfSAvLyBORUVEIFRFU1RcbiAgICAgIC8vIGlmIChwb2ludE9yZGVyU3R5bGVQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgIC8vIFx0Ly8gP1xuICAgICAgLy8gXHRjdHgucGFpbnRPcmRlciA9IHBvaW50T3JkZXJTdHlsZVByb3AuZ2V0VmFsdWUoKTtcbiAgICAgIC8vIH1cblxuXG4gICAgICBpZiAoc3Ryb2tlRGFzaGFycmF5U3R5bGVQcm9wLmhhc1ZhbHVlKCkgJiYgc3Ryb2tlRGFzaGFycmF5U3R5bGVQcm9wLmdldFN0cmluZygpICE9PSAnbm9uZScpIHtcbiAgICAgICAgdmFyIGdhcHMgPSB0b051bWJlcnMoc3Ryb2tlRGFzaGFycmF5U3R5bGVQcm9wLmdldFN0cmluZygpKTtcblxuICAgICAgICBpZiAodHlwZW9mIGN0eC5zZXRMaW5lRGFzaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjdHguc2V0TGluZURhc2goZ2Fwcyk7XG4gICAgICAgIH0gZWxzZSAvLyBAdHMtZXhwZWN0LWVycm9yIEhhbmRsZSBicm93c2VyIHByZWZpeC5cbiAgICAgICAgICBpZiAodHlwZW9mIGN0eC53ZWJraXRMaW5lRGFzaCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgY3R4LndlYmtpdExpbmVEYXNoID0gZ2FwcztcbiAgICAgICAgICB9IGVsc2UgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICBpZiAodHlwZW9mIGN0eC5tb3pEYXNoICE9PSAndW5kZWZpbmVkJyAmJiAhKGdhcHMubGVuZ3RoID09PSAxICYmIGdhcHNbMF0gPT09IDApKSB7XG4gICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgICBjdHgubW96RGFzaCA9IGdhcHM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9mZnNldCA9IHN0cm9rZURhc2hvZmZzZXRQcm9wLmdldFBpeGVscygpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY3R4LmxpbmVEYXNoT2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgfSBlbHNlIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgIGlmICh0eXBlb2YgY3R4LndlYmtpdExpbmVEYXNoT2Zmc2V0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICBjdHgud2Via2l0TGluZURhc2hPZmZzZXQgPSBvZmZzZXQ7XG4gICAgICAgICAgfSBlbHNlIC8vIEB0cy1leHBlY3QtZXJyb3IgSGFuZGxlIGJyb3dzZXIgcHJlZml4LlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjdHgubW96RGFzaE9mZnNldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBIYW5kbGUgYnJvd3NlciBwcmVmaXguXG4gICAgICAgICAgICAgIGN0eC5tb3pEYXNoT2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gZm9udFxuXG5cbiAgICB0aGlzLm1vZGlmaWVkRW1TaXplU3RhY2sgPSBmYWxzZTtcblxuICAgIGlmICh0eXBlb2YgY3R4LmZvbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICB2YXIgZm9udFN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQnKTtcbiAgICAgIHZhciBmb250U3R5bGVTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250LXN0eWxlJyk7XG4gICAgICB2YXIgZm9udFZhcmlhbnRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250LXZhcmlhbnQnKTtcbiAgICAgIHZhciBmb250V2VpZ2h0U3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnZm9udC13ZWlnaHQnKTtcbiAgICAgIHZhciBmb250U2l6ZVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZvbnQtc2l6ZScpO1xuICAgICAgdmFyIGZvbnRGYW1pbHlTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdmb250LWZhbWlseScpO1xuICAgICAgdmFyIGZvbnQgPSBuZXcgRm9udChmb250U3R5bGVTdHlsZVByb3AuZ2V0U3RyaW5nKCksIGZvbnRWYXJpYW50U3R5bGVQcm9wLmdldFN0cmluZygpLCBmb250V2VpZ2h0U3R5bGVQcm9wLmdldFN0cmluZygpLCBmb250U2l6ZVN0eWxlUHJvcC5oYXNWYWx1ZSgpID8gXCJcIi5jb25jYXQoZm9udFNpemVTdHlsZVByb3AuZ2V0UGl4ZWxzKHRydWUpLCBcInB4XCIpIDogJycsIGZvbnRGYW1pbHlTdHlsZVByb3AuZ2V0U3RyaW5nKCksIEZvbnQucGFyc2UoZm9udFN0eWxlUHJvcC5nZXRTdHJpbmcoKSwgY3R4LmZvbnQpKTtcbiAgICAgIGZvbnRTdHlsZVN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRTdHlsZSk7XG4gICAgICBmb250VmFyaWFudFN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRWYXJpYW50KTtcbiAgICAgIGZvbnRXZWlnaHRTdHlsZVByb3Auc2V0VmFsdWUoZm9udC5mb250V2VpZ2h0KTtcbiAgICAgIGZvbnRTaXplU3R5bGVQcm9wLnNldFZhbHVlKGZvbnQuZm9udFNpemUpO1xuICAgICAgZm9udEZhbWlseVN0eWxlUHJvcC5zZXRWYWx1ZShmb250LmZvbnRGYW1pbHkpO1xuICAgICAgY3R4LmZvbnQgPSBmb250LnRvU3RyaW5nKCk7XG5cbiAgICAgIGlmIChmb250U2l6ZVN0eWxlUHJvcC5pc1BpeGVscygpKSB7XG4gICAgICAgIHRoaXMuZG9jdW1lbnQuZW1TaXplID0gZm9udFNpemVTdHlsZVByb3AuZ2V0UGl4ZWxzKCk7XG4gICAgICAgIHRoaXMubW9kaWZpZWRFbVNpemVTdGFjayA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFmcm9tTWVhc3VyZSkge1xuICAgICAgLy8gZWZmZWN0c1xuICAgICAgdGhpcy5hcHBseUVmZmVjdHMoY3R4KTsgLy8gb3BhY2l0eVxuXG4gICAgICBjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLmNhbGN1bGF0ZU9wYWNpdHkoKTtcbiAgICB9XG4gIH1cblxuICBjbGVhckNvbnRleHQoY3R4KSB7XG4gICAgc3VwZXIuY2xlYXJDb250ZXh0KGN0eCk7XG5cbiAgICBpZiAodGhpcy5tb2RpZmllZEVtU2l6ZVN0YWNrKSB7XG4gICAgICB0aGlzLmRvY3VtZW50LnBvcEVtU2l6ZSgpO1xuICAgIH1cbiAgfVxuXG59XG5cbmNsYXNzIFBhdGhFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ3BhdGgnO1xuICAgIHRoaXMucGF0aFBhcnNlciA9IG51bGw7XG4gICAgdGhpcy5wYXRoUGFyc2VyID0gbmV3IFBhdGhQYXJzZXIodGhpcy5nZXRBdHRyaWJ1dGUoJ2QnKS5nZXRTdHJpbmcoKSk7XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KCk7XG4gICAgcGF0aFBhcnNlci5yZXNldCgpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIH1cblxuICAgIHdoaWxlICghcGF0aFBhcnNlci5pc0VuZCgpKSB7XG4gICAgICBzd2l0Y2ggKHBhdGhQYXJzZXIubmV4dCgpLnR5cGUpIHtcbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLk1PVkVfVE86XG4gICAgICAgICAgdGhpcy5wYXRoTShjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhMKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5IT1JJWl9MSU5FX1RPOlxuICAgICAgICAgIHRoaXMucGF0aEgoY3R4LCBib3VuZGluZ0JveCk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlZFUlRfTElORV9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhWKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5DVVJWRV9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhDKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5TTU9PVEhfQ1VSVkVfVE86XG4gICAgICAgICAgdGhpcy5wYXRoUyhjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuUVVBRF9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhRKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5TTU9PVEhfUVVBRF9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhUKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5BUkM6XG4gICAgICAgICAgdGhpcy5wYXRoQShjdHgsIGJvdW5kaW5nQm94KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ0xPU0VfUEFUSDpcbiAgICAgICAgICB0aGlzLnBhdGhaKGN0eCwgYm91bmRpbmdCb3gpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgfVxuXG4gIGdldEJvdW5kaW5nQm94KF8pIHtcbiAgICByZXR1cm4gdGhpcy5wYXRoKCk7XG4gIH1cblxuICBnZXRNYXJrZXJzKCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHBvaW50cyA9IHBhdGhQYXJzZXIuZ2V0TWFya2VyUG9pbnRzKCk7XG4gICAgdmFyIGFuZ2xlcyA9IHBhdGhQYXJzZXIuZ2V0TWFya2VyQW5nbGVzKCk7XG4gICAgdmFyIG1hcmtlcnMgPSBwb2ludHMubWFwKChwb2ludCwgaSkgPT4gW3BvaW50LCBhbmdsZXNbaV1dKTtcbiAgICByZXR1cm4gbWFya2VycztcbiAgfVxuXG4gIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgIHRoaXMucGF0aChjdHgpO1xuICAgIHRoaXMuZG9jdW1lbnQuc2NyZWVuLm1vdXNlLmNoZWNrUGF0aCh0aGlzLCBjdHgpO1xuICAgIHZhciBmaWxsUnVsZVN0eWxlUHJvcCA9IHRoaXMuZ2V0U3R5bGUoJ2ZpbGwtcnVsZScpO1xuXG4gICAgaWYgKGN0eC5maWxsU3R5bGUgIT09ICcnKSB7XG4gICAgICBpZiAoZmlsbFJ1bGVTdHlsZVByb3AuZ2V0U3RyaW5nKCdpbmhlcml0JykgIT09ICdpbmhlcml0Jykge1xuICAgICAgICBjdHguZmlsbChmaWxsUnVsZVN0eWxlUHJvcC5nZXRTdHJpbmcoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjdHguc3Ryb2tlU3R5bGUgIT09ICcnKSB7XG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ3ZlY3Rvci1lZmZlY3QnKS5nZXRTdHJpbmcoKSA9PT0gJ25vbi1zY2FsaW5nLXN0cm9rZScpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBtYXJrZXJzID0gdGhpcy5nZXRNYXJrZXJzKCk7XG5cbiAgICBpZiAobWFya2Vycykge1xuICAgICAgdmFyIG1hcmtlcnNMYXN0SW5kZXggPSBtYXJrZXJzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgbWFya2VyU3RhcnRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdtYXJrZXItc3RhcnQnKTtcbiAgICAgIHZhciBtYXJrZXJNaWRTdHlsZVByb3AgPSB0aGlzLmdldFN0eWxlKCdtYXJrZXItbWlkJyk7XG4gICAgICB2YXIgbWFya2VyRW5kU3R5bGVQcm9wID0gdGhpcy5nZXRTdHlsZSgnbWFya2VyLWVuZCcpO1xuXG4gICAgICBpZiAobWFya2VyU3RhcnRTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgdmFyIG1hcmtlciA9IG1hcmtlclN0YXJ0U3R5bGVQcm9wLmdldERlZmluaXRpb24oKTtcbiAgICAgICAgdmFyIFtwb2ludCwgYW5nbGVdID0gbWFya2Vyc1swXTtcbiAgICAgICAgbWFya2VyLnJlbmRlcihjdHgsIHBvaW50LCBhbmdsZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXJrZXJNaWRTdHlsZVByb3AuaXNVcmxEZWZpbml0aW9uKCkpIHtcbiAgICAgICAgdmFyIF9tYXJrZXIgPSBtYXJrZXJNaWRTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgbWFya2Vyc0xhc3RJbmRleDsgaSsrKSB7XG4gICAgICAgICAgdmFyIFtfcG9pbnQsIF9hbmdsZV0gPSBtYXJrZXJzW2ldO1xuXG4gICAgICAgICAgX21hcmtlci5yZW5kZXIoY3R4LCBfcG9pbnQsIF9hbmdsZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKG1hcmtlckVuZFN0eWxlUHJvcC5pc1VybERlZmluaXRpb24oKSkge1xuICAgICAgICB2YXIgX21hcmtlcjIgPSBtYXJrZXJFbmRTdHlsZVByb3AuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgICAgIHZhciBbX3BvaW50MiwgX2FuZ2xlMl0gPSBtYXJrZXJzW21hcmtlcnNMYXN0SW5kZXhdO1xuXG4gICAgICAgIF9tYXJrZXIyLnJlbmRlcihjdHgsIF9wb2ludDIsIF9hbmdsZTIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoTShwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgIHBhdGhQYXJzZXIuc3RhcnQgPSBwYXRoUGFyc2VyLmN1cnJlbnQ7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBvaW50XG4gICAgfTtcbiAgfVxuXG4gIHBhdGhNKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBwb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoTShwYXRoUGFyc2VyKTtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gcG9pbnQ7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXIocG9pbnQpO1xuICAgIGJvdW5kaW5nQm94LmFkZFBvaW50KHgsIHkpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aEwocGF0aFBhcnNlcikge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50XG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIHBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnRcbiAgICB9O1xuICB9XG5cbiAgcGF0aEwoY3R4LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoTChwYXRoUGFyc2VyKTtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gcG9pbnQ7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXIocG9pbnQsIGN1cnJlbnQpO1xuICAgIGJvdW5kaW5nQm94LmFkZFBvaW50KHgsIHkpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aEgocGF0aFBhcnNlcikge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgY29tbWFuZFxuICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgIHZhciBwb2ludCA9IG5ldyBQb2ludCgoY29tbWFuZC5yZWxhdGl2ZSA/IGN1cnJlbnQueCA6IDApICsgY29tbWFuZC54LCBjdXJyZW50LnkpO1xuICAgIHBhdGhQYXJzZXIuY3VycmVudCA9IHBvaW50O1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnRcbiAgICB9O1xuICB9XG5cbiAgcGF0aEgoY3R4LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoSChwYXRoUGFyc2VyKTtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gcG9pbnQ7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXIocG9pbnQsIGN1cnJlbnQpO1xuICAgIGJvdW5kaW5nQm94LmFkZFBvaW50KHgsIHkpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aFYocGF0aFBhcnNlcikge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgY29tbWFuZFxuICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgIHZhciBwb2ludCA9IG5ldyBQb2ludChjdXJyZW50LngsIChjb21tYW5kLnJlbGF0aXZlID8gY3VycmVudC55IDogMCkgKyBjb21tYW5kLnkpO1xuICAgIHBhdGhQYXJzZXIuY3VycmVudCA9IHBvaW50O1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnRcbiAgICB9O1xuICB9XG5cbiAgcGF0aFYoY3R4LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoVihwYXRoUGFyc2VyKTtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gcG9pbnQ7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXIocG9pbnQsIGN1cnJlbnQpO1xuICAgIGJvdW5kaW5nQm94LmFkZFBvaW50KHgsIHkpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgcGF0aEMocGF0aFBhcnNlcikge1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50XG4gICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgdmFyIHBvaW50ID0gcGF0aFBhcnNlci5nZXRQb2ludCgneDEnLCAneTEnKTtcbiAgICB2YXIgY29udHJvbFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0NvbnRyb2xQb2ludCgneDInLCAneTInKTtcbiAgICB2YXIgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9O1xuICB9XG5cbiAgcGF0aEMoY3R4LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBwb2ludCxcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoQyhwYXRoUGFyc2VyKTtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlcihjdXJyZW50UG9pbnQsIGNvbnRyb2xQb2ludCwgcG9pbnQpO1xuICAgIGJvdW5kaW5nQm94LmFkZEJlemllckN1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhwb2ludC54LCBwb2ludC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhTKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudFxuICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgIHZhciBwb2ludCA9IHBhdGhQYXJzZXIuZ2V0UmVmbGVjdGVkQ29udHJvbFBvaW50KCk7XG4gICAgdmFyIGNvbnRyb2xQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDb250cm9sUG9pbnQoJ3gyJywgJ3kyJyk7XG4gICAgdmFyIGN1cnJlbnRQb2ludCA9IHBhdGhQYXJzZXIuZ2V0QXNDdXJyZW50UG9pbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudCxcbiAgICAgIHBvaW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfTtcbiAgfVxuXG4gIHBhdGhTKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgcG9pbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aFMocGF0aFBhcnNlcik7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXIoY3VycmVudFBvaW50LCBjb250cm9sUG9pbnQsIHBvaW50KTtcbiAgICBib3VuZGluZ0JveC5hZGRCZXppZXJDdXJ2ZShjdXJyZW50LngsIGN1cnJlbnQueSwgcG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgY3R4LmJlemllckN1cnZlVG8ocG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoUShwYXRoUGFyc2VyKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIgY29udHJvbFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0NvbnRyb2xQb2ludCgneDEnLCAneTEnKTtcbiAgICB2YXIgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfTtcbiAgfVxuXG4gIHBhdGhRKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhRKHBhdGhQYXJzZXIpO1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBjb250cm9sUG9pbnQpO1xuICAgIGJvdW5kaW5nQm94LmFkZFF1YWRyYXRpY0N1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhUKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudFxuICAgIH0gPSBwYXRoUGFyc2VyO1xuICAgIHZhciBjb250cm9sUG9pbnQgPSBwYXRoUGFyc2VyLmdldFJlZmxlY3RlZENvbnRyb2xQb2ludCgpO1xuICAgIHBhdGhQYXJzZXIuY29udHJvbCA9IGNvbnRyb2xQb2ludDtcbiAgICB2YXIgY3VycmVudFBvaW50ID0gcGF0aFBhcnNlci5nZXRBc0N1cnJlbnRQb2ludCgpO1xuICAgIHJldHVybiB7XG4gICAgICBjdXJyZW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfTtcbiAgfVxuXG4gIHBhdGhUKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBjdXJyZW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhUKHBhdGhQYXJzZXIpO1xuICAgIHBhdGhQYXJzZXIuYWRkTWFya2VyKGN1cnJlbnRQb2ludCwgY29udHJvbFBvaW50LCBjb250cm9sUG9pbnQpO1xuICAgIGJvdW5kaW5nQm94LmFkZFF1YWRyYXRpY0N1cnZlKGN1cnJlbnQueCwgY3VycmVudC55LCBjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgfVxuICB9XG5cbiAgc3RhdGljIHBhdGhBKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGNvbW1hbmRcbiAgICB9ID0gcGF0aFBhcnNlcjtcbiAgICB2YXIge1xuICAgICAgclgsXG4gICAgICByWSxcbiAgICAgIHhSb3QsXG4gICAgICBsQXJjRmxhZyxcbiAgICAgIHN3ZWVwRmxhZ1xuICAgIH0gPSBjb21tYW5kO1xuICAgIHZhciB4QXhpc1JvdGF0aW9uID0geFJvdCAqIChNYXRoLlBJIC8gMTgwLjApO1xuICAgIHZhciBjdXJyZW50UG9pbnQgPSBwYXRoUGFyc2VyLmdldEFzQ3VycmVudFBvaW50KCk7IC8vIENvbnZlcnNpb24gZnJvbSBlbmRwb2ludCB0byBjZW50ZXIgcGFyYW1ldGVyaXphdGlvblxuICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ltcGxub3RlLmh0bWwjQXJjSW1wbGVtZW50YXRpb25Ob3Rlc1xuICAgIC8vIHgxJywgeTEnXG5cbiAgICB2YXIgY3VycnAgPSBuZXcgUG9pbnQoTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiAoY3VycmVudC54IC0gY3VycmVudFBvaW50LngpIC8gMi4wICsgTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiAoY3VycmVudC55IC0gY3VycmVudFBvaW50LnkpIC8gMi4wLCAtTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiAoY3VycmVudC54IC0gY3VycmVudFBvaW50LngpIC8gMi4wICsgTWF0aC5jb3MoeEF4aXNSb3RhdGlvbikgKiAoY3VycmVudC55IC0gY3VycmVudFBvaW50LnkpIC8gMi4wKTsgLy8gYWRqdXN0IHJhZGlpXG5cbiAgICB2YXIgbCA9IE1hdGgucG93KGN1cnJwLngsIDIpIC8gTWF0aC5wb3coclgsIDIpICsgTWF0aC5wb3coY3VycnAueSwgMikgLyBNYXRoLnBvdyhyWSwgMik7XG5cbiAgICBpZiAobCA+IDEpIHtcbiAgICAgIHJYICo9IE1hdGguc3FydChsKTtcbiAgICAgIHJZICo9IE1hdGguc3FydChsKTtcbiAgICB9IC8vIGN4JywgY3knXG5cblxuICAgIHZhciBzID0gKGxBcmNGbGFnID09PSBzd2VlcEZsYWcgPyAtMSA6IDEpICogTWF0aC5zcXJ0KChNYXRoLnBvdyhyWCwgMikgKiBNYXRoLnBvdyhyWSwgMikgLSBNYXRoLnBvdyhyWCwgMikgKiBNYXRoLnBvdyhjdXJycC55LCAyKSAtIE1hdGgucG93KHJZLCAyKSAqIE1hdGgucG93KGN1cnJwLngsIDIpKSAvIChNYXRoLnBvdyhyWCwgMikgKiBNYXRoLnBvdyhjdXJycC55LCAyKSArIE1hdGgucG93KHJZLCAyKSAqIE1hdGgucG93KGN1cnJwLngsIDIpKSk7XG5cbiAgICBpZiAoaXNOYU4ocykpIHtcbiAgICAgIHMgPSAwO1xuICAgIH1cblxuICAgIHZhciBjcHAgPSBuZXcgUG9pbnQocyAqIHJYICogY3VycnAueSAvIHJZLCBzICogLXJZICogY3VycnAueCAvIHJYKTsgLy8gY3gsIGN5XG5cbiAgICB2YXIgY2VudHAgPSBuZXcgUG9pbnQoKGN1cnJlbnQueCArIGN1cnJlbnRQb2ludC54KSAvIDIuMCArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogY3BwLnggLSBNYXRoLnNpbih4QXhpc1JvdGF0aW9uKSAqIGNwcC55LCAoY3VycmVudC55ICsgY3VycmVudFBvaW50LnkpIC8gMi4wICsgTWF0aC5zaW4oeEF4aXNSb3RhdGlvbikgKiBjcHAueCArIE1hdGguY29zKHhBeGlzUm90YXRpb24pICogY3BwLnkpOyAvLyBpbml0aWFsIGFuZ2xlXG5cbiAgICB2YXIgYTEgPSB2ZWN0b3JzQW5nbGUoWzEsIDBdLCBbKGN1cnJwLnggLSBjcHAueCkgLyByWCwgKGN1cnJwLnkgLSBjcHAueSkgLyByWV0pOyAvLyDOuDFcbiAgICAvLyBhbmdsZSBkZWx0YVxuXG4gICAgdmFyIHUgPSBbKGN1cnJwLnggLSBjcHAueCkgLyByWCwgKGN1cnJwLnkgLSBjcHAueSkgLyByWV07XG4gICAgdmFyIHYgPSBbKC1jdXJycC54IC0gY3BwLngpIC8gclgsICgtY3VycnAueSAtIGNwcC55KSAvIHJZXTtcbiAgICB2YXIgYWQgPSB2ZWN0b3JzQW5nbGUodSwgdik7IC8vIM6UzrhcblxuICAgIGlmICh2ZWN0b3JzUmF0aW8odSwgdikgPD0gLTEpIHtcbiAgICAgIGFkID0gTWF0aC5QSTtcbiAgICB9XG5cbiAgICBpZiAodmVjdG9yc1JhdGlvKHUsIHYpID49IDEpIHtcbiAgICAgIGFkID0gMDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgY3VycmVudFBvaW50LFxuICAgICAgclgsXG4gICAgICByWSxcbiAgICAgIHN3ZWVwRmxhZyxcbiAgICAgIHhBeGlzUm90YXRpb24sXG4gICAgICBjZW50cCxcbiAgICAgIGExLFxuICAgICAgYWRcbiAgICB9O1xuICB9XG5cbiAgcGF0aEEoY3R4LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB7XG4gICAgICBwYXRoUGFyc2VyXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnRQb2ludCxcbiAgICAgIHJYLFxuICAgICAgclksXG4gICAgICBzd2VlcEZsYWcsXG4gICAgICB4QXhpc1JvdGF0aW9uLFxuICAgICAgY2VudHAsXG4gICAgICBhMSxcbiAgICAgIGFkXG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhBKHBhdGhQYXJzZXIpOyAvLyBmb3IgbWFya2Vyc1xuXG4gICAgdmFyIGRpciA9IDEgLSBzd2VlcEZsYWcgPyAxLjAgOiAtMS4wO1xuICAgIHZhciBhaCA9IGExICsgZGlyICogKGFkIC8gMi4wKTtcbiAgICB2YXIgaGFsZldheSA9IG5ldyBQb2ludChjZW50cC54ICsgclggKiBNYXRoLmNvcyhhaCksIGNlbnRwLnkgKyByWSAqIE1hdGguc2luKGFoKSk7XG4gICAgcGF0aFBhcnNlci5hZGRNYXJrZXJBbmdsZShoYWxmV2F5LCBhaCAtIGRpciAqIE1hdGguUEkgLyAyKTtcbiAgICBwYXRoUGFyc2VyLmFkZE1hcmtlckFuZ2xlKGN1cnJlbnRQb2ludCwgYWggLSBkaXIgKiBNYXRoLlBJKTtcbiAgICBib3VuZGluZ0JveC5hZGRQb2ludChjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpOyAvLyBUT0RPOiB0aGlzIGlzIHRvbyBuYWl2ZSwgbWFrZSBpdCBiZXR0ZXJcblxuICAgIGlmIChjdHggJiYgIWlzTmFOKGExKSAmJiAhaXNOYU4oYWQpKSB7XG4gICAgICB2YXIgciA9IHJYID4gclkgPyByWCA6IHJZO1xuICAgICAgdmFyIHN4ID0gclggPiByWSA/IDEgOiByWCAvIHJZO1xuICAgICAgdmFyIHN5ID0gclggPiByWSA/IHJZIC8gclggOiAxO1xuICAgICAgY3R4LnRyYW5zbGF0ZShjZW50cC54LCBjZW50cC55KTtcbiAgICAgIGN0eC5yb3RhdGUoeEF4aXNSb3RhdGlvbik7XG4gICAgICBjdHguc2NhbGUoc3gsIHN5KTtcbiAgICAgIGN0eC5hcmMoMCwgMCwgciwgYTEsIGExICsgYWQsIEJvb2xlYW4oMSAtIHN3ZWVwRmxhZykpO1xuICAgICAgY3R4LnNjYWxlKDEgLyBzeCwgMSAvIHN5KTtcbiAgICAgIGN0eC5yb3RhdGUoLXhBeGlzUm90YXRpb24pO1xuICAgICAgY3R4LnRyYW5zbGF0ZSgtY2VudHAueCwgLWNlbnRwLnkpO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBwYXRoWihwYXRoUGFyc2VyKSB7XG4gICAgcGF0aFBhcnNlci5jdXJyZW50ID0gcGF0aFBhcnNlci5zdGFydDtcbiAgfVxuXG4gIHBhdGhaKGN0eCwgYm91bmRpbmdCb3gpIHtcbiAgICBQYXRoRWxlbWVudC5wYXRoWih0aGlzLnBhdGhQYXJzZXIpO1xuXG4gICAgaWYgKGN0eCkge1xuICAgICAgLy8gb25seSBjbG9zZSBwYXRoIGlmIGl0IGlzIG5vdCBhIHN0cmFpZ2h0IGxpbmVcbiAgICAgIGlmIChib3VuZGluZ0JveC54MSAhPT0gYm91bmRpbmdCb3gueDIgJiYgYm91bmRpbmdCb3gueTEgIT09IGJvdW5kaW5nQm94LnkyKSB7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufVxuXG5jbGFzcyBHbHlwaEVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdnbHlwaCc7XG4gICAgdGhpcy5ob3JpekFkdlggPSB0aGlzLmdldEF0dHJpYnV0ZSgnaG9yaXotYWR2LXgnKS5nZXROdW1iZXIoKTtcbiAgICB0aGlzLnVuaWNvZGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgndW5pY29kZScpLmdldFN0cmluZygpO1xuICAgIHRoaXMuYXJhYmljRm9ybSA9IHRoaXMuZ2V0QXR0cmlidXRlKCdhcmFiaWMtZm9ybScpLmdldFN0cmluZygpO1xuICB9XG5cbn1cblxuY2xhc3MgVGV4dEVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBuZXcudGFyZ2V0ID09PSBUZXh0RWxlbWVudCA/IHRydWUgOiBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAndGV4dCc7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMubWVhc3VyZUNhY2hlID0gLTE7XG4gIH1cblxuICBzZXRDb250ZXh0KGN0eCkge1xuICAgIHZhciBmcm9tTWVhc3VyZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gICAgc3VwZXIuc2V0Q29udGV4dChjdHgsIGZyb21NZWFzdXJlKTtcbiAgICB2YXIgdGV4dEJhc2VsaW5lID0gdGhpcy5nZXRTdHlsZSgnZG9taW5hbnQtYmFzZWxpbmUnKS5nZXRUZXh0QmFzZWxpbmUoKSB8fCB0aGlzLmdldFN0eWxlKCdhbGlnbm1lbnQtYmFzZWxpbmUnKS5nZXRUZXh0QmFzZWxpbmUoKTtcblxuICAgIGlmICh0ZXh0QmFzZWxpbmUpIHtcbiAgICAgIGN0eC50ZXh0QmFzZWxpbmUgPSB0ZXh0QmFzZWxpbmU7XG4gICAgfVxuICB9XG5cbiAgaW5pdGlhbGl6ZUNvb3JkaW5hdGVzKCkge1xuICAgIHRoaXMueCA9IDA7XG4gICAgdGhpcy55ID0gMDtcbiAgICB0aGlzLmxlYWZUZXh0cyA9IFtdO1xuICAgIHRoaXMudGV4dENodW5rU3RhcnQgPSAwO1xuICAgIHRoaXMubWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLm1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gIH1cblxuICBnZXRCb3VuZGluZ0JveChjdHgpIHtcbiAgICBpZiAodGhpcy50eXBlICE9PSAndGV4dCcpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFRFbGVtZW50Qm91bmRpbmdCb3goY3R4KTtcbiAgICB9IC8vIGZpcnN0LCBjYWxjdWxhdGUgY2hpbGQgcG9zaXRpb25zXG5cblxuICAgIHRoaXMuaW5pdGlhbGl6ZUNvb3JkaW5hdGVzKCk7XG4gICAgdGhpcy5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlKGN0eCk7XG4gICAgdmFyIGJvdW5kaW5nQm94ID0gbnVsbDsgLy8gdGhlbiBjYWxjdWxhdGUgYm91bmRpbmcgYm94XG5cbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgIHZhciBjaGlsZEJvdW5kaW5nQm94ID0gdGhpcy5nZXRDaGlsZEJvdW5kaW5nQm94KGN0eCwgdGhpcywgdGhpcywgaSk7XG5cbiAgICAgIGlmICghYm91bmRpbmdCb3gpIHtcbiAgICAgICAgYm91bmRpbmdCb3ggPSBjaGlsZEJvdW5kaW5nQm94O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkQm91bmRpbmdCb3goY2hpbGRCb3VuZGluZ0JveCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICB9XG5cbiAgZ2V0Rm9udFNpemUoKSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgcGFyZW50XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGluaGVyaXRGb250U2l6ZSA9IEZvbnQucGFyc2UoZG9jdW1lbnQuY3R4LmZvbnQpLmZvbnRTaXplO1xuICAgIHZhciBmb250U2l6ZSA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1zaXplJykuZ2V0TnVtYmVyKGluaGVyaXRGb250U2l6ZSk7XG4gICAgcmV0dXJuIGZvbnRTaXplO1xuICB9XG5cbiAgZ2V0VEVsZW1lbnRCb3VuZGluZ0JveChjdHgpIHtcbiAgICB2YXIgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveCh0aGlzLngsIHRoaXMueSAtIGZvbnRTaXplLCB0aGlzLnggKyB0aGlzLm1lYXN1cmVUZXh0KGN0eCksIHRoaXMueSk7XG4gIH1cblxuICBnZXRHbHlwaChmb250LCB0ZXh0LCBpKSB7XG4gICAgdmFyIGNoYXIgPSB0ZXh0W2ldO1xuICAgIHZhciBnbHlwaCA9IG51bGw7XG5cbiAgICBpZiAoZm9udC5pc0FyYWJpYykge1xuICAgICAgdmFyIGxlbiA9IHRleHQubGVuZ3RoO1xuICAgICAgdmFyIHByZXZDaGFyID0gdGV4dFtpIC0gMV07XG4gICAgICB2YXIgbmV4dENoYXIgPSB0ZXh0W2kgKyAxXTtcbiAgICAgIHZhciBhcmFiaWNGb3JtID0gJ2lzb2xhdGVkJztcblxuICAgICAgaWYgKChpID09PSAwIHx8IHByZXZDaGFyID09PSAnICcpICYmIGkgPCBsZW4gLSAxICYmIG5leHRDaGFyICE9PSAnICcpIHtcbiAgICAgICAgYXJhYmljRm9ybSA9ICd0ZXJtaW5hbCc7XG4gICAgICB9XG5cbiAgICAgIGlmIChpID4gMCAmJiBwcmV2Q2hhciAhPT0gJyAnICYmIGkgPCBsZW4gLSAxICYmIG5leHRDaGFyICE9PSAnICcpIHtcbiAgICAgICAgYXJhYmljRm9ybSA9ICdtZWRpYWwnO1xuICAgICAgfVxuXG4gICAgICBpZiAoaSA+IDAgJiYgcHJldkNoYXIgIT09ICcgJyAmJiAoaSA9PT0gbGVuIC0gMSB8fCBuZXh0Q2hhciA9PT0gJyAnKSkge1xuICAgICAgICBhcmFiaWNGb3JtID0gJ2luaXRpYWwnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGZvbnQuZ2x5cGhzW2NoYXJdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAvLyBORUVEIFRFU1RcbiAgICAgICAgdmFyIG1heWJlR2x5cGggPSBmb250LmdseXBoc1tjaGFyXTtcbiAgICAgICAgZ2x5cGggPSBtYXliZUdseXBoIGluc3RhbmNlb2YgR2x5cGhFbGVtZW50ID8gbWF5YmVHbHlwaCA6IG1heWJlR2x5cGhbYXJhYmljRm9ybV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGdseXBoID0gZm9udC5nbHlwaHNbY2hhcl07XG4gICAgfVxuXG4gICAgaWYgKCFnbHlwaCkge1xuICAgICAgZ2x5cGggPSBmb250Lm1pc3NpbmdHbHlwaDtcbiAgICB9XG5cbiAgICByZXR1cm4gZ2x5cGg7XG4gIH1cblxuICBnZXRUZXh0KCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGdldFRleHRGcm9tTm9kZShub2RlKSB7XG4gICAgdmFyIHRleHROb2RlID0gbm9kZSB8fCB0aGlzLm5vZGU7XG4gICAgdmFyIGNoaWxkTm9kZXMgPSBBcnJheS5mcm9tKHRleHROb2RlLnBhcmVudE5vZGUuY2hpbGROb2Rlcyk7XG4gICAgdmFyIGluZGV4ID0gY2hpbGROb2Rlcy5pbmRleE9mKHRleHROb2RlKTtcbiAgICB2YXIgbGFzdEluZGV4ID0gY2hpbGROb2Rlcy5sZW5ndGggLSAxO1xuICAgIHZhciB0ZXh0ID0gY29tcHJlc3NTcGFjZXMoIC8vIHRleHROb2RlLnZhbHVlXG4gICAgLy8gfHwgdGV4dE5vZGUudGV4dFxuICAgIHRleHROb2RlLnRleHRDb250ZW50IHx8ICcnKTtcblxuICAgIGlmIChpbmRleCA9PT0gMCkge1xuICAgICAgdGV4dCA9IHRyaW1MZWZ0KHRleHQpO1xuICAgIH1cblxuICAgIGlmIChpbmRleCA9PT0gbGFzdEluZGV4KSB7XG4gICAgICB0ZXh0ID0gdHJpbVJpZ2h0KHRleHQpO1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9XG5cbiAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgaWYgKHRoaXMudHlwZSAhPT0gJ3RleHQnKSB7XG4gICAgICB0aGlzLnJlbmRlclRFbGVtZW50Q2hpbGRyZW4oY3R4KTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGZpcnN0LCBjYWxjdWxhdGUgY2hpbGQgcG9zaXRpb25zXG5cblxuICAgIHRoaXMuaW5pdGlhbGl6ZUNvb3JkaW5hdGVzKCk7XG4gICAgdGhpcy5hZGp1c3RDaGlsZENvb3JkaW5hdGVzUmVjdXJzaXZlKGN0eCk7IC8vIHRoZW4gcmVuZGVyXG5cbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKF8sIGkpID0+IHtcbiAgICAgIHRoaXMucmVuZGVyQ2hpbGQoY3R4LCB0aGlzLCB0aGlzLCBpKTtcbiAgICB9KTtcbiAgICB2YXIge1xuICAgICAgbW91c2VcbiAgICB9ID0gdGhpcy5kb2N1bWVudC5zY3JlZW47IC8vIERvIG5vdCBjYWxjIGJvdW5kaW5nIGJveCBpZiBtb3VzZSBpcyBub3Qgd29ya2luZy5cblxuICAgIGlmIChtb3VzZS5pc1dvcmtpbmcoKSkge1xuICAgICAgbW91c2UuY2hlY2tCb3VuZGluZ0JveCh0aGlzLCB0aGlzLmdldEJvdW5kaW5nQm94KGN0eCkpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlclRFbGVtZW50Q2hpbGRyZW4oY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgcGFyZW50XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHJlbmRlclRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgICB2YXIgY3VzdG9tRm9udCA9IHBhcmVudC5nZXRTdHlsZSgnZm9udC1mYW1pbHknKS5nZXREZWZpbml0aW9uKCk7XG5cbiAgICBpZiAoY3VzdG9tRm9udCkge1xuICAgICAgdmFyIHtcbiAgICAgICAgdW5pdHNQZXJFbVxuICAgICAgfSA9IGN1c3RvbUZvbnQuZm9udEZhY2U7XG4gICAgICB2YXIgY3R4Rm9udCA9IEZvbnQucGFyc2UoZG9jdW1lbnQuY3R4LmZvbnQpO1xuICAgICAgdmFyIGZvbnRTaXplID0gcGFyZW50LmdldFN0eWxlKCdmb250LXNpemUnKS5nZXROdW1iZXIoY3R4Rm9udC5mb250U2l6ZSk7XG4gICAgICB2YXIgZm9udFN0eWxlID0gcGFyZW50LmdldFN0eWxlKCdmb250LXN0eWxlJykuZ2V0U3RyaW5nKGN0eEZvbnQuZm9udFN0eWxlKTtcbiAgICAgIHZhciBzY2FsZSA9IGZvbnRTaXplIC8gdW5pdHNQZXJFbTtcbiAgICAgIHZhciB0ZXh0ID0gY3VzdG9tRm9udC5pc1JUTCA/IHJlbmRlclRleHQuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKSA6IHJlbmRlclRleHQ7XG4gICAgICB2YXIgZHggPSB0b051bWJlcnMocGFyZW50LmdldEF0dHJpYnV0ZSgnZHgnKS5nZXRTdHJpbmcoKSk7XG4gICAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaChjdXN0b21Gb250LCB0ZXh0LCBpKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSh0aGlzLngsIHRoaXMueSk7XG4gICAgICAgIGN0eC5zY2FsZShzY2FsZSwgLXNjYWxlKTtcbiAgICAgICAgdmFyIGx3ID0gY3R4LmxpbmVXaWR0aDtcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGN0eC5saW5lV2lkdGggKiB1bml0c1BlckVtIC8gZm9udFNpemU7XG5cbiAgICAgICAgaWYgKGZvbnRTdHlsZSA9PT0gJ2l0YWxpYycpIHtcbiAgICAgICAgICBjdHgudHJhbnNmb3JtKDEsIDAsIC40LCAxLCAwLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdseXBoLnJlbmRlcihjdHgpO1xuXG4gICAgICAgIGlmIChmb250U3R5bGUgPT09ICdpdGFsaWMnKSB7XG4gICAgICAgICAgY3R4LnRyYW5zZm9ybSgxLCAwLCAtLjQsIDEsIDAsIDApO1xuICAgICAgICB9XG5cbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IGx3O1xuICAgICAgICBjdHguc2NhbGUoMSAvIHNjYWxlLCAtMSAvIHNjYWxlKTtcbiAgICAgICAgY3R4LnRyYW5zbGF0ZSgtdGhpcy54LCAtdGhpcy55KTtcbiAgICAgICAgdGhpcy54ICs9IGZvbnRTaXplICogKGdseXBoLmhvcml6QWR2WCB8fCBjdXN0b21Gb250Lmhvcml6QWR2WCkgLyB1bml0c1BlckVtO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZHhbaV0gIT09ICd1bmRlZmluZWQnICYmICFpc05hTihkeFtpXSkpIHtcbiAgICAgICAgICB0aGlzLnggKz0gZHhbaV07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSB0aGlzOyAvLyBORUVEIFRFU1RcbiAgICAvLyBpZiAoY3R4LnBhaW50T3JkZXIgPT09ICdzdHJva2UnKSB7XG4gICAgLy8gXHRpZiAoY3R4LnN0cm9rZVN0eWxlKSB7XG4gICAgLy8gXHRcdGN0eC5zdHJva2VUZXh0KHJlbmRlclRleHQsIHgsIHkpO1xuICAgIC8vIFx0fVxuICAgIC8vIFx0aWYgKGN0eC5maWxsU3R5bGUpIHtcbiAgICAvLyBcdFx0Y3R4LmZpbGxUZXh0KHJlbmRlclRleHQsIHgsIHkpO1xuICAgIC8vIFx0fVxuICAgIC8vIH0gZWxzZSB7XG5cbiAgICBpZiAoY3R4LmZpbGxTdHlsZSkge1xuICAgICAgY3R4LmZpbGxUZXh0KHJlbmRlclRleHQsIHgsIHkpO1xuICAgIH1cblxuICAgIGlmIChjdHguc3Ryb2tlU3R5bGUpIHtcbiAgICAgIGN0eC5zdHJva2VUZXh0KHJlbmRlclRleHQsIHgsIHkpO1xuICAgIH0gLy8gfVxuXG4gIH1cblxuICBhcHBseUFuY2hvcmluZygpIHtcbiAgICBpZiAodGhpcy50ZXh0Q2h1bmtTdGFydCA+PSB0aGlzLmxlYWZUZXh0cy5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFRoaXMgaXMgYmFzaWNhbGx5IHRoZSBcIkFwcGx5IGFuY2hvcmluZ1wiIHBhcnQgb2YgaHR0cHM6Ly93d3cudzMub3JnL1RSL1NWRzIvdGV4dC5odG1sI1RleHRMYXlvdXRBbGdvcml0aG0uXG4gICAgLy8gVGhlIGRpZmZlcmVuY2UgaXMgdGhhdCB3ZSBhcHBseSB0aGUgYW5jaG9yaW5nIGFzIHNvb24gYXMgYSBjaHVuayBpcyBmaW5pc2hlZC4gVGhpcyBzYXZlcyBzb21lIGV4dHJhIGxvb3BpbmcuXG4gICAgLy8gVmVydGljYWwgdGV4dCBpcyBub3Qgc3VwcG9ydGVkLlxuXG5cbiAgICB2YXIgZmlyc3RFbGVtZW50ID0gdGhpcy5sZWFmVGV4dHNbdGhpcy50ZXh0Q2h1bmtTdGFydF07XG4gICAgdmFyIHRleHRBbmNob3IgPSBmaXJzdEVsZW1lbnQuZ2V0U3R5bGUoJ3RleHQtYW5jaG9yJykuZ2V0U3RyaW5nKCdzdGFydCcpO1xuICAgIHZhciBpc1JUTCA9IGZhbHNlOyAvLyB3ZSB0cmVhdCBSVEwgbGlrZSBMVFJcblxuICAgIHZhciBzaGlmdCA9IDA7XG5cbiAgICBpZiAodGV4dEFuY2hvciA9PT0gJ3N0YXJ0JyAmJiAhaXNSVEwgfHwgdGV4dEFuY2hvciA9PT0gJ2VuZCcgJiYgaXNSVEwpIHtcbiAgICAgIHNoaWZ0ID0gZmlyc3RFbGVtZW50LnggLSB0aGlzLm1pblg7XG4gICAgfSBlbHNlIGlmICh0ZXh0QW5jaG9yID09PSAnZW5kJyAmJiAhaXNSVEwgfHwgdGV4dEFuY2hvciA9PT0gJ3N0YXJ0JyAmJiBpc1JUTCkge1xuICAgICAgc2hpZnQgPSBmaXJzdEVsZW1lbnQueCAtIHRoaXMubWF4WDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2hpZnQgPSBmaXJzdEVsZW1lbnQueCAtICh0aGlzLm1pblggKyB0aGlzLm1heFgpIC8gMjtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gdGhpcy50ZXh0Q2h1bmtTdGFydDsgaSA8IHRoaXMubGVhZlRleHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB0aGlzLmxlYWZUZXh0c1tpXS54ICs9IHNoaWZ0O1xuICAgIH0gLy8gc3RhcnQgbmV3IGNodW5rXG5cblxuICAgIHRoaXMubWluWCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICB0aGlzLm1heFggPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XG4gICAgdGhpcy50ZXh0Q2h1bmtTdGFydCA9IHRoaXMubGVhZlRleHRzLmxlbmd0aDtcbiAgfVxuXG4gIGFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUoY3R4KSB7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICB0aGlzLmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlKGN0eCwgdGhpcywgdGhpcywgaSk7XG4gICAgfSk7XG4gICAgdGhpcy5hcHBseUFuY2hvcmluZygpO1xuICB9XG5cbiAgYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZUNvcmUoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XG5cbiAgICBpZiAoY2hpbGQuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgY2hpbGQuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgICB0ZXh0UGFyZW50LmFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmVDb3JlKGN0eCwgdGV4dFBhcmVudCwgY2hpbGQsIGkpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG9ubHkgbGVhZnMgYXJlIHJlbGV2YW50XG4gICAgICB0aGlzLmFkanVzdENoaWxkQ29vcmRpbmF0ZXMoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpO1xuICAgIH1cbiAgfVxuXG4gIGFkanVzdENoaWxkQ29vcmRpbmF0ZXMoY3R4LCB0ZXh0UGFyZW50LCBwYXJlbnQsIGkpIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnQuY2hpbGRyZW5baV07XG5cbiAgICBpZiAodHlwZW9mIGNoaWxkLm1lYXN1cmVUZXh0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBjaGlsZC5zZXRDb250ZXh0KGN0eCwgdHJ1ZSk7XG4gICAgdmFyIHhBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCd4Jyk7XG4gICAgdmFyIHlBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCd5Jyk7XG4gICAgdmFyIGR4QXR0ciA9IGNoaWxkLmdldEF0dHJpYnV0ZSgnZHgnKTtcbiAgICB2YXIgZHlBdHRyID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdkeScpO1xuICAgIHZhciBjdXN0b21Gb250ID0gY2hpbGQuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5JykuZ2V0RGVmaW5pdGlvbigpO1xuICAgIHZhciBpc1JUTCA9IEJvb2xlYW4oY3VzdG9tRm9udCkgJiYgY3VzdG9tRm9udC5pc1JUTDtcblxuICAgIGlmIChpID09PSAwKSB7XG4gICAgICAvLyBGaXJzdCBjaGlsZHJlbiBpbmhlcml0IGF0dHJpYnV0ZXMgZnJvbSBwYXJlbnQocykuIFBvc2l0aW9uYWwgYXR0cmlidXRlc1xuICAgICAgLy8gYXJlIG9ubHkgaW5oZXJpdGVkIGZyb20gYSBwYXJlbnQgdG8gaXQncyBmaXJzdCBjaGlsZC5cbiAgICAgIGlmICgheEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICB4QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ3gnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICgheUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICB5QXR0ci5zZXRWYWx1ZShjaGlsZC5nZXRJbmhlcml0ZWRBdHRyaWJ1dGUoJ3knKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZHhBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgZHhBdHRyLnNldFZhbHVlKGNoaWxkLmdldEluaGVyaXRlZEF0dHJpYnV0ZSgnZHgnKSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgZHlBdHRyLnNldFZhbHVlKGNoaWxkLmdldEluaGVyaXRlZEF0dHJpYnV0ZSgnZHknKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHdpZHRoID0gY2hpbGQubWVhc3VyZVRleHQoY3R4KTtcblxuICAgIGlmIChpc1JUTCkge1xuICAgICAgdGV4dFBhcmVudC54IC09IHdpZHRoO1xuICAgIH1cblxuICAgIGlmICh4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAvLyBhbiBcInhcIiBhdHRyaWJ1dGUgbWFya3MgdGhlIHN0YXJ0IG9mIGEgbmV3IGNodW5rXG4gICAgICB0ZXh0UGFyZW50LmFwcGx5QW5jaG9yaW5nKCk7XG4gICAgICBjaGlsZC54ID0geEF0dHIuZ2V0UGl4ZWxzKCd4Jyk7XG5cbiAgICAgIGlmIChkeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICBjaGlsZC54ICs9IGR4QXR0ci5nZXRQaXhlbHMoJ3gnKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGR4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHRleHRQYXJlbnQueCArPSBkeEF0dHIuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkLnggPSB0ZXh0UGFyZW50Lng7XG4gICAgfVxuXG4gICAgdGV4dFBhcmVudC54ID0gY2hpbGQueDtcblxuICAgIGlmICghaXNSVEwpIHtcbiAgICAgIHRleHRQYXJlbnQueCArPSB3aWR0aDtcbiAgICB9XG5cbiAgICBpZiAoeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgY2hpbGQueSA9IHlBdHRyLmdldFBpeGVscygneScpO1xuXG4gICAgICBpZiAoZHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgY2hpbGQueSArPSBkeUF0dHIuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgICB0ZXh0UGFyZW50LnkgKz0gZHlBdHRyLmdldFBpeGVscygneScpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZC55ID0gdGV4dFBhcmVudC55O1xuICAgIH1cblxuICAgIHRleHRQYXJlbnQueSA9IGNoaWxkLnk7IC8vIHVwZGF0ZSB0aGUgY3VycmVudCBjaHVuayBhbmQgaXQncyBib3VuZHNcblxuICAgIHRleHRQYXJlbnQubGVhZlRleHRzLnB1c2goY2hpbGQpO1xuICAgIHRleHRQYXJlbnQubWluWCA9IE1hdGgubWluKHRleHRQYXJlbnQubWluWCwgY2hpbGQueCwgY2hpbGQueCArIHdpZHRoKTtcbiAgICB0ZXh0UGFyZW50Lm1heFggPSBNYXRoLm1heCh0ZXh0UGFyZW50Lm1heFgsIGNoaWxkLngsIGNoaWxkLnggKyB3aWR0aCk7XG4gICAgY2hpbGQuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICByZXR1cm4gY2hpbGQ7XG4gIH1cblxuICBnZXRDaGlsZEJvdW5kaW5nQm94KGN0eCwgdGV4dFBhcmVudCwgcGFyZW50LCBpKSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkcmVuW2ldOyAvLyBub3QgYSB0ZXh0IG5vZGU/XG5cbiAgICBpZiAodHlwZW9mIGNoaWxkLmdldEJvdW5kaW5nQm94ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgYm91bmRpbmdCb3ggPSBjaGlsZC5nZXRCb3VuZGluZ0JveChjdHgpO1xuXG4gICAgaWYgKCFib3VuZGluZ0JveCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY2hpbGQuY2hpbGRyZW4uZm9yRWFjaCgoXywgaSkgPT4ge1xuICAgICAgdmFyIGNoaWxkQm91bmRpbmdCb3ggPSB0ZXh0UGFyZW50LmdldENoaWxkQm91bmRpbmdCb3goY3R4LCB0ZXh0UGFyZW50LCBjaGlsZCwgaSk7XG4gICAgICBib3VuZGluZ0JveC5hZGRCb3VuZGluZ0JveChjaGlsZEJvdW5kaW5nQm94KTtcbiAgICB9KTtcbiAgICByZXR1cm4gYm91bmRpbmdCb3g7XG4gIH1cblxuICByZW5kZXJDaGlsZChjdHgsIHRleHRQYXJlbnQsIHBhcmVudCwgaSkge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZHJlbltpXTtcbiAgICBjaGlsZC5yZW5kZXIoY3R4KTtcbiAgICBjaGlsZC5jaGlsZHJlbi5mb3JFYWNoKChfLCBpKSA9PiB7XG4gICAgICB0ZXh0UGFyZW50LnJlbmRlckNoaWxkKGN0eCwgdGV4dFBhcmVudCwgY2hpbGQsIGkpO1xuICAgIH0pO1xuICB9XG5cbiAgbWVhc3VyZVRleHQoY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIG1lYXN1cmVDYWNoZVxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKH5tZWFzdXJlQ2FjaGUpIHtcbiAgICAgIHJldHVybiBtZWFzdXJlQ2FjaGU7XG4gICAgfVxuXG4gICAgdmFyIHJlbmRlclRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgICB2YXIgbWVhc3VyZSA9IHRoaXMubWVhc3VyZVRhcmdldFRleHQoY3R4LCByZW5kZXJUZXh0KTtcbiAgICB0aGlzLm1lYXN1cmVDYWNoZSA9IG1lYXN1cmU7XG4gICAgcmV0dXJuIG1lYXN1cmU7XG4gIH1cblxuICBtZWFzdXJlVGFyZ2V0VGV4dChjdHgsIHRhcmdldFRleHQpIHtcbiAgICBpZiAoIXRhcmdldFRleHQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgcGFyZW50XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGN1c3RvbUZvbnQgPSBwYXJlbnQuZ2V0U3R5bGUoJ2ZvbnQtZmFtaWx5JykuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgaWYgKGN1c3RvbUZvbnQpIHtcbiAgICAgIHZhciBmb250U2l6ZSA9IHRoaXMuZ2V0Rm9udFNpemUoKTtcbiAgICAgIHZhciB0ZXh0ID0gY3VzdG9tRm9udC5pc1JUTCA/IHRhcmdldFRleHQuc3BsaXQoJycpLnJldmVyc2UoKS5qb2luKCcnKSA6IHRhcmdldFRleHQ7XG4gICAgICB2YXIgZHggPSB0b051bWJlcnMocGFyZW50LmdldEF0dHJpYnV0ZSgnZHgnKS5nZXRTdHJpbmcoKSk7XG4gICAgICB2YXIgbGVuID0gdGV4dC5sZW5ndGg7XG4gICAgICB2YXIgX21lYXN1cmUgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2V0R2x5cGgoY3VzdG9tRm9udCwgdGV4dCwgaSk7XG4gICAgICAgIF9tZWFzdXJlICs9IChnbHlwaC5ob3JpekFkdlggfHwgY3VzdG9tRm9udC5ob3JpekFkdlgpICogZm9udFNpemUgLyBjdXN0b21Gb250LmZvbnRGYWNlLnVuaXRzUGVyRW07XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkeFtpXSAhPT0gJ3VuZGVmaW5lZCcgJiYgIWlzTmFOKGR4W2ldKSkge1xuICAgICAgICAgIF9tZWFzdXJlICs9IGR4W2ldO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfbWVhc3VyZTtcbiAgICB9XG5cbiAgICBpZiAoIWN0eC5tZWFzdXJlVGV4dCkge1xuICAgICAgcmV0dXJuIHRhcmdldFRleHQubGVuZ3RoICogMTA7XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcbiAgICB0aGlzLnNldENvbnRleHQoY3R4LCB0cnVlKTtcbiAgICB2YXIge1xuICAgICAgd2lkdGg6IG1lYXN1cmVcbiAgICB9ID0gY3R4Lm1lYXN1cmVUZXh0KHRhcmdldFRleHQpO1xuICAgIHRoaXMuY2xlYXJDb250ZXh0KGN0eCk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICByZXR1cm4gbWVhc3VyZTtcbiAgfVxuICAvKipcclxuICAgKiBJbmhlcml0cyBwb3NpdGlvbmFsIGF0dHJpYnV0ZXMgZnJvbSB7QGxpbmsgVGV4dEVsZW1lbnR9IHBhcmVudChzKS4gQXR0cmlidXRlc1xyXG4gICAqIGFyZSBvbmx5IGluaGVyaXRlZCBmcm9tIGEgcGFyZW50IHRvIGl0cyBmaXJzdCBjaGlsZC5cclxuICAgKiBAcGFyYW0gbmFtZSAtIFRoZSBhdHRyaWJ1dGUgbmFtZS5cclxuICAgKiBAcmV0dXJucyBUaGUgYXR0cmlidXRlIHZhbHVlIG9yIG51bGwuXHJcbiAgICovXG5cblxuICBnZXRJbmhlcml0ZWRBdHRyaWJ1dGUobmFtZSkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhcyxjb25zaXN0ZW50LXRoaXNcbiAgICB2YXIgY3VycmVudCA9IHRoaXM7XG5cbiAgICB3aGlsZSAoY3VycmVudCBpbnN0YW5jZW9mIFRleHRFbGVtZW50ICYmIGN1cnJlbnQuaXNGaXJzdENoaWxkKCkpIHtcbiAgICAgIHZhciBwYXJlbnRBdHRyID0gY3VycmVudC5wYXJlbnQuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXG4gICAgICBpZiAocGFyZW50QXR0ci5oYXNWYWx1ZSh0cnVlKSkge1xuICAgICAgICByZXR1cm4gcGFyZW50QXR0ci5nZXRWYWx1ZSgnMCcpO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxufVxuXG5jbGFzcyBUU3BhbkVsZW1lbnQgZXh0ZW5kcyBUZXh0RWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIG5ldy50YXJnZXQgPT09IFRTcGFuRWxlbWVudCA/IHRydWUgOiBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAndHNwYW4nOyAvLyBpZiB0aGlzIG5vZGUgaGFzIGNoaWxkcmVuLCB0aGVuIHRoZXkgb3duIHRoZSB0ZXh0XG5cbiAgICB0aGlzLnRleHQgPSB0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDAgPyAnJyA6IHRoaXMuZ2V0VGV4dEZyb21Ob2RlKCk7XG4gIH1cblxuICBnZXRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHQ7XG4gIH1cblxufVxuXG5jbGFzcyBUZXh0Tm9kZSBleHRlbmRzIFRTcGFuRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3RleHROb2RlJztcbiAgfVxuXG59XG5cbmNsYXNzIFNWR0VsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdzdmcnO1xuICAgIHRoaXMucm9vdCA9IGZhbHNlO1xuICB9XG5cbiAgc2V0Q29udGV4dChjdHgpIHtcbiAgICB2YXIgX3RoaXMkbm9kZSRwYXJlbnROb2RlO1xuXG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHtcbiAgICAgIHNjcmVlbixcbiAgICAgIHdpbmRvd1xuICAgIH0gPSBkb2N1bWVudDtcbiAgICB2YXIgY2FudmFzID0gY3R4LmNhbnZhcztcbiAgICBzY3JlZW4uc2V0RGVmYXVsdHMoY3R4KTtcblxuICAgIGlmIChjYW52YXMuc3R5bGUgJiYgdHlwZW9mIGN0eC5mb250ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgY3R4LmZvbnQgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShjYW52YXMpLmdldFByb3BlcnR5VmFsdWUoJ2ZvbnQnKTtcbiAgICAgIHZhciBmb250U2l6ZVByb3AgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdmb250U2l6ZScsIEZvbnQucGFyc2UoY3R4LmZvbnQpLmZvbnRTaXplKTtcblxuICAgICAgaWYgKGZvbnRTaXplUHJvcC5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIGRvY3VtZW50LnJvb3RFbVNpemUgPSBmb250U2l6ZVByb3AuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgICAgIGRvY3VtZW50LmVtU2l6ZSA9IGRvY3VtZW50LnJvb3RFbVNpemU7XG4gICAgICB9XG4gICAgfSAvLyBjcmVhdGUgbmV3IHZpZXcgcG9ydFxuXG5cbiAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCd4JykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCd5JykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3knLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gc2NyZWVuLnZpZXdQb3J0O1xuXG4gICAgaWYgKCF0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJywgdHJ1ZSkuc2V0VmFsdWUoJzEwMCUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcsIHRydWUpLnNldFZhbHVlKCcxMDAlJyk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLmdldFN0eWxlKCdjb2xvcicpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0U3R5bGUoJ2NvbG9yJywgdHJ1ZSkuc2V0VmFsdWUoJ2JsYWNrJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlZlhBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3JlZlgnKTtcbiAgICB2YXIgcmVmWUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncmVmWScpO1xuICAgIHZhciB2aWV3Qm94QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd2aWV3Qm94Jyk7XG4gICAgdmFyIHZpZXdCb3ggPSB2aWV3Qm94QXR0ci5oYXNWYWx1ZSgpID8gdG9OdW1iZXJzKHZpZXdCb3hBdHRyLmdldFN0cmluZygpKSA6IG51bGw7XG4gICAgdmFyIGNsaXAgPSAhdGhpcy5yb290ICYmIHRoaXMuZ2V0U3R5bGUoJ292ZXJmbG93JykuZ2V0VmFsdWUoJ2hpZGRlbicpICE9PSAndmlzaWJsZSc7XG4gICAgdmFyIG1pblggPSAwO1xuICAgIHZhciBtaW5ZID0gMDtcbiAgICB2YXIgY2xpcFggPSAwO1xuICAgIHZhciBjbGlwWSA9IDA7XG5cbiAgICBpZiAodmlld0JveCkge1xuICAgICAgbWluWCA9IHZpZXdCb3hbMF07XG4gICAgICBtaW5ZID0gdmlld0JveFsxXTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMucm9vdCkge1xuICAgICAgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcpO1xuICAgICAgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgPT09ICdtYXJrZXInKSB7XG4gICAgICAgIGNsaXBYID0gbWluWDtcbiAgICAgICAgY2xpcFkgPSBtaW5ZO1xuICAgICAgICBtaW5YID0gMDtcbiAgICAgICAgbWluWSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2NyZWVuLnZpZXdQb3J0LnNldEN1cnJlbnQod2lkdGgsIGhlaWdodCk7IC8vIERlZmF1bHQgdmFsdWUgb2YgdHJhbnNmb3JtLW9yaWdpbiBpcyBjZW50ZXIgb25seSBmb3Igcm9vdCBTVkcgZWxlbWVudHNcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9TVkcvQXR0cmlidXRlL3RyYW5zZm9ybS1vcmlnaW5cblxuICAgIGlmICh0aGlzLm5vZGUgLy8gaXMgbm90IHRlbXBvcmFyeSBTVkdFbGVtZW50XG4gICAgJiYgKCF0aGlzLnBhcmVudCB8fCAoKF90aGlzJG5vZGUkcGFyZW50Tm9kZSA9IHRoaXMubm9kZS5wYXJlbnROb2RlKSA9PT0gbnVsbCB8fCBfdGhpcyRub2RlJHBhcmVudE5vZGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF90aGlzJG5vZGUkcGFyZW50Tm9kZS5ub2RlTmFtZSkgPT09ICdmb3JlaWduT2JqZWN0JykgJiYgdGhpcy5nZXRTdHlsZSgndHJhbnNmb3JtJywgZmFsc2UsIHRydWUpLmhhc1ZhbHVlKCkgJiYgIXRoaXMuZ2V0U3R5bGUoJ3RyYW5zZm9ybS1vcmlnaW4nLCBmYWxzZSwgdHJ1ZSkuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRTdHlsZSgndHJhbnNmb3JtLW9yaWdpbicsIHRydWUsIHRydWUpLnNldFZhbHVlKCc1MCUgNTAlJyk7XG4gICAgfVxuXG4gICAgc3VwZXIuc2V0Q29udGV4dChjdHgpO1xuICAgIGN0eC50cmFuc2xhdGUodGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKSwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKSk7XG5cbiAgICBpZiAodmlld0JveCkge1xuICAgICAgd2lkdGggPSB2aWV3Qm94WzJdO1xuICAgICAgaGVpZ2h0ID0gdmlld0JveFszXTtcbiAgICB9XG5cbiAgICBkb2N1bWVudC5zZXRWaWV3Qm94KHtcbiAgICAgIGN0eCxcbiAgICAgIGFzcGVjdFJhdGlvOiB0aGlzLmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpLmdldFN0cmluZygpLFxuICAgICAgd2lkdGg6IHNjcmVlbi52aWV3UG9ydC53aWR0aCxcbiAgICAgIGRlc2lyZWRXaWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IHNjcmVlbi52aWV3UG9ydC5oZWlnaHQsXG4gICAgICBkZXNpcmVkSGVpZ2h0OiBoZWlnaHQsXG4gICAgICBtaW5YLFxuICAgICAgbWluWSxcbiAgICAgIHJlZlg6IHJlZlhBdHRyLmdldFZhbHVlKCksXG4gICAgICByZWZZOiByZWZZQXR0ci5nZXRWYWx1ZSgpLFxuICAgICAgY2xpcCxcbiAgICAgIGNsaXBYLFxuICAgICAgY2xpcFlcbiAgICB9KTtcblxuICAgIGlmICh2aWV3Qm94KSB7XG4gICAgICBzY3JlZW4udmlld1BvcnQucmVtb3ZlQ3VycmVudCgpO1xuICAgICAgc2NyZWVuLnZpZXdQb3J0LnNldEN1cnJlbnQod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICB9XG5cbiAgY2xlYXJDb250ZXh0KGN0eCkge1xuICAgIHN1cGVyLmNsZWFyQ29udGV4dChjdHgpO1xuICAgIHRoaXMuZG9jdW1lbnQuc2NyZWVuLnZpZXdQb3J0LnJlbW92ZUN1cnJlbnQoKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXNpemUgU1ZHIHRvIGZpdCBpbiBnaXZlbiBzaXplLlxyXG4gICAqIEBwYXJhbSB3aWR0aFxyXG4gICAqIEBwYXJhbSBoZWlnaHRcclxuICAgKiBAcGFyYW0gcHJlc2VydmVBc3BlY3RSYXRpb1xyXG4gICAqL1xuXG5cbiAgcmVzaXplKHdpZHRoKSB7XG4gICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogd2lkdGg7XG4gICAgdmFyIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIHZhciB3aWR0aEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnd2lkdGgnLCB0cnVlKTtcbiAgICB2YXIgaGVpZ2h0QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0cnVlKTtcbiAgICB2YXIgdmlld0JveEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpO1xuICAgIHZhciBzdHlsZUF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgnc3R5bGUnKTtcbiAgICB2YXIgb3JpZ2luV2lkdGggPSB3aWR0aEF0dHIuZ2V0TnVtYmVyKDApO1xuICAgIHZhciBvcmlnaW5IZWlnaHQgPSBoZWlnaHRBdHRyLmdldE51bWJlcigwKTtcblxuICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvKSB7XG4gICAgICBpZiAodHlwZW9mIHByZXNlcnZlQXNwZWN0UmF0aW8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgdHJ1ZSkuc2V0VmFsdWUocHJlc2VydmVBc3BlY3RSYXRpbyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJlc2VydmVBc3BlY3RSYXRpb0F0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycpO1xuXG4gICAgICAgIGlmIChwcmVzZXJ2ZUFzcGVjdFJhdGlvQXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgcHJlc2VydmVBc3BlY3RSYXRpb0F0dHIuc2V0VmFsdWUocHJlc2VydmVBc3BlY3RSYXRpb0F0dHIuZ2V0U3RyaW5nKCkucmVwbGFjZSgvXlxccyooXFxTLipcXFMpXFxzKiQvLCAnJDEnKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB3aWR0aEF0dHIuc2V0VmFsdWUod2lkdGgpO1xuICAgIGhlaWdodEF0dHIuc2V0VmFsdWUoaGVpZ2h0KTtcblxuICAgIGlmICghdmlld0JveEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgdmlld0JveEF0dHIuc2V0VmFsdWUoXCIwIDAgXCIuY29uY2F0KG9yaWdpbldpZHRoIHx8IHdpZHRoLCBcIiBcIikuY29uY2F0KG9yaWdpbkhlaWdodCB8fCBoZWlnaHQpKTtcbiAgICB9XG5cbiAgICBpZiAoc3R5bGVBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHZhciB3aWR0aFN0eWxlID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKTtcbiAgICAgIHZhciBoZWlnaHRTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpO1xuXG4gICAgICBpZiAod2lkdGhTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIHdpZHRoU3R5bGUuc2V0VmFsdWUoXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaGVpZ2h0U3R5bGUuaGFzVmFsdWUoKSkge1xuICAgICAgICBoZWlnaHRTdHlsZS5zZXRWYWx1ZShcIlwiLmNvbmNhdChoZWlnaHQsIFwicHhcIikpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG5cbmNsYXNzIFJlY3RFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdyZWN0JztcbiAgfVxuXG4gIHBhdGgoY3R4KSB7XG4gICAgdmFyIHggPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciB5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcsIGZhbHNlLCB0cnVlKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JywgZmFsc2UsIHRydWUpLmdldFBpeGVscygneScpO1xuICAgIHZhciByeEF0dHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncngnKTtcbiAgICB2YXIgcnlBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3J5Jyk7XG4gICAgdmFyIHJ4ID0gcnhBdHRyLmdldFBpeGVscygneCcpO1xuICAgIHZhciByeSA9IHJ5QXR0ci5nZXRQaXhlbHMoJ3knKTtcblxuICAgIGlmIChyeEF0dHIuaGFzVmFsdWUoKSAmJiAhcnlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHJ5ID0gcng7XG4gICAgfVxuXG4gICAgaWYgKHJ5QXR0ci5oYXNWYWx1ZSgpICYmICFyeEF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgcnggPSByeTtcbiAgICB9XG5cbiAgICByeCA9IE1hdGgubWluKHJ4LCB3aWR0aCAvIDIuMCk7XG4gICAgcnkgPSBNYXRoLm1pbihyeSwgaGVpZ2h0IC8gMi4wKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIHZhciBLQVBQQSA9IDQgKiAoKE1hdGguc3FydCgyKSAtIDEpIC8gMyk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7IC8vIGFsd2F5cyBzdGFydCB0aGUgcGF0aCBzbyB3ZSBkb24ndCBmaWxsIHByaW9yIHBhdGhzXG5cbiAgICAgIGlmIChoZWlnaHQgPiAwICYmIHdpZHRoID4gMCkge1xuICAgICAgICBjdHgubW92ZVRvKHggKyByeCwgeSk7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoIC0gcngsIHkpO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgd2lkdGggLSByeCArIEtBUFBBICogcngsIHksIHggKyB3aWR0aCwgeSArIHJ5IC0gS0FQUEEgKiByeSwgeCArIHdpZHRoLCB5ICsgcnkpO1xuICAgICAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCAtIHJ5KTtcbiAgICAgICAgY3R4LmJlemllckN1cnZlVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcnkgKyBLQVBQQSAqIHJ5LCB4ICsgd2lkdGggLSByeCArIEtBUFBBICogcngsIHkgKyBoZWlnaHQsIHggKyB3aWR0aCAtIHJ4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4ICsgcngsIHkgKyBoZWlnaHQpO1xuICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4ICsgcnggLSBLQVBQQSAqIHJ4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcnkgKyBLQVBQQSAqIHJ5LCB4LCB5ICsgaGVpZ2h0IC0gcnkpO1xuICAgICAgICBjdHgubGluZVRvKHgsIHkgKyByeSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHgsIHkgKyByeSAtIEtBUFBBICogcnksIHggKyByeCAtIEtBUFBBICogcngsIHksIHggKyByeCwgeSk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gIH1cblxuICBnZXRNYXJrZXJzKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbn1cblxuY2xhc3MgQ2lyY2xlRWxlbWVudCBleHRlbmRzIFBhdGhFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnY2lyY2xlJztcbiAgfVxuXG4gIHBhdGgoY3R4KSB7XG4gICAgdmFyIGN4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIGN5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIHIgPSB0aGlzLmdldEF0dHJpYnV0ZSgncicpLmdldFBpeGVscygpO1xuXG4gICAgaWYgKGN0eCAmJiByID4gMCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LmFyYyhjeCwgY3ksIHIsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBCb3VuZGluZ0JveChjeCAtIHIsIGN5IC0gciwgY3ggKyByLCBjeSArIHIpO1xuICB9XG5cbiAgZ2V0TWFya2VycygpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG59XG5cbmNsYXNzIEVsbGlwc2VFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdlbGxpcHNlJztcbiAgfVxuXG4gIHBhdGgoY3R4KSB7XG4gICAgdmFyIEtBUFBBID0gNCAqICgoTWF0aC5zcXJ0KDIpIC0gMSkgLyAzKTtcbiAgICB2YXIgcnggPSB0aGlzLmdldEF0dHJpYnV0ZSgncngnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgcnkgPSB0aGlzLmdldEF0dHJpYnV0ZSgncnknKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgY3ggPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgY3kgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5nZXRQaXhlbHMoJ3knKTtcblxuICAgIGlmIChjdHggJiYgcnggPiAwICYmIHJ5ID4gMCkge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4Lm1vdmVUbyhjeCArIHJ4LCBjeSk7XG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCArIHJ4LCBjeSArIEtBUFBBICogcnksIGN4ICsgS0FQUEEgKiByeCwgY3kgKyByeSwgY3gsIGN5ICsgcnkpO1xuICAgICAgY3R4LmJlemllckN1cnZlVG8oY3ggLSBLQVBQQSAqIHJ4LCBjeSArIHJ5LCBjeCAtIHJ4LCBjeSArIEtBUFBBICogcnksIGN4IC0gcngsIGN5KTtcbiAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKGN4IC0gcngsIGN5IC0gS0FQUEEgKiByeSwgY3ggLSBLQVBQQSAqIHJ4LCBjeSAtIHJ5LCBjeCwgY3kgLSByeSk7XG4gICAgICBjdHguYmV6aWVyQ3VydmVUbyhjeCArIEtBUFBBICogcngsIGN5IC0gcnksIGN4ICsgcngsIGN5IC0gS0FQUEEgKiByeSwgY3ggKyByeCwgY3kpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3goY3ggLSByeCwgY3kgLSByeSwgY3ggKyByeCwgY3kgKyByeSk7XG4gIH1cblxuICBnZXRNYXJrZXJzKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbn1cblxuY2xhc3MgTGluZUVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2xpbmUnO1xuICB9XG5cbiAgZ2V0UG9pbnRzKCkge1xuICAgIHJldHVybiBbbmV3IFBvaW50KHRoaXMuZ2V0QXR0cmlidXRlKCd4MScpLmdldFBpeGVscygneCcpLCB0aGlzLmdldEF0dHJpYnV0ZSgneTEnKS5nZXRQaXhlbHMoJ3knKSksIG5ldyBQb2ludCh0aGlzLmdldEF0dHJpYnV0ZSgneDInKS5nZXRQaXhlbHMoJ3gnKSwgdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJykuZ2V0UGl4ZWxzKCd5JykpXTtcbiAgfVxuXG4gIHBhdGgoY3R4KSB7XG4gICAgdmFyIFt7XG4gICAgICB4OiB4MCxcbiAgICAgIHk6IHkwXG4gICAgfSwge1xuICAgICAgeDogeDEsXG4gICAgICB5OiB5MVxuICAgIH1dID0gdGhpcy5nZXRQb2ludHMoKTtcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5tb3ZlVG8oeDAsIHkwKTtcbiAgICAgIGN0eC5saW5lVG8oeDEsIHkxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHgwLCB5MCwgeDEsIHkxKTtcbiAgfVxuXG4gIGdldE1hcmtlcnMoKSB7XG4gICAgdmFyIFtwMCwgcDFdID0gdGhpcy5nZXRQb2ludHMoKTtcbiAgICB2YXIgYSA9IHAwLmFuZ2xlVG8ocDEpO1xuICAgIHJldHVybiBbW3AwLCBhXSwgW3AxLCBhXV07XG4gIH1cblxufVxuXG5jbGFzcyBQb2x5bGluZUVsZW1lbnQgZXh0ZW5kcyBQYXRoRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdwb2x5bGluZSc7XG4gICAgdGhpcy5wb2ludHMgPSBbXTtcbiAgICB0aGlzLnBvaW50cyA9IFBvaW50LnBhcnNlUGF0aCh0aGlzLmdldEF0dHJpYnV0ZSgncG9pbnRzJykuZ2V0U3RyaW5nKCkpO1xuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIge1xuICAgICAgcG9pbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIFt7XG4gICAgICB4OiB4MCxcbiAgICAgIHk6IHkwXG4gICAgfV0gPSBwb2ludHM7XG4gICAgdmFyIGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KHgwLCB5MCk7XG5cbiAgICBpZiAoY3R4KSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKHgwLCB5MCk7XG4gICAgfVxuXG4gICAgcG9pbnRzLmZvckVhY2goX3JlZiA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICB4LFxuICAgICAgICB5XG4gICAgICB9ID0gX3JlZjtcbiAgICAgIGJvdW5kaW5nQm94LmFkZFBvaW50KHgsIHkpO1xuXG4gICAgICBpZiAoY3R4KSB7XG4gICAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICB9XG5cbiAgZ2V0TWFya2VycygpIHtcbiAgICB2YXIge1xuICAgICAgcG9pbnRzXG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIGxhc3RJbmRleCA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgIHZhciBtYXJrZXJzID0gW107XG4gICAgcG9pbnRzLmZvckVhY2goKHBvaW50LCBpKSA9PiB7XG4gICAgICBpZiAoaSA9PT0gbGFzdEluZGV4KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbWFya2Vycy5wdXNoKFtwb2ludCwgcG9pbnQuYW5nbGVUbyhwb2ludHNbaSArIDFdKV0pO1xuICAgIH0pO1xuXG4gICAgaWYgKG1hcmtlcnMubGVuZ3RoID4gMCkge1xuICAgICAgbWFya2Vycy5wdXNoKFtwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdLCBtYXJrZXJzW21hcmtlcnMubGVuZ3RoIC0gMV1bMV1dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFya2VycztcbiAgfVxuXG59XG5cbmNsYXNzIFBvbHlnb25FbGVtZW50IGV4dGVuZHMgUG9seWxpbmVFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAncG9seWdvbic7XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciBib3VuZGluZ0JveCA9IHN1cGVyLnBhdGgoY3R4KTtcbiAgICB2YXIgW3tcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfV0gPSB0aGlzLnBvaW50cztcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5saW5lVG8oeCwgeSk7XG4gICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvdW5kaW5nQm94O1xuICB9XG5cbn1cblxuY2xhc3MgUGF0dGVybkVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAncGF0dGVybic7XG4gIH1cblxuICBjcmVhdGVQYXR0ZXJuKGN0eCwgXywgcGFyZW50T3BhY2l0eVByb3ApIHtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcsIHRydWUpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knLCB0cnVlKTsgLy8gcmVuZGVyIG1lIHVzaW5nIGEgdGVtcG9yYXJ5IHN2ZyBlbGVtZW50XG5cbiAgICB2YXIgcGF0dGVyblN2ZyA9IG5ldyBTVkdFbGVtZW50KHRoaXMuZG9jdW1lbnQsIG51bGwpO1xuICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy52aWV3Qm94ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd2aWV3Qm94JywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnKS5nZXRWYWx1ZSgpKTtcbiAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMud2lkdGggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3dpZHRoJywgXCJcIi5jb25jYXQod2lkdGgsIFwicHhcIikpO1xuICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy5oZWlnaHQgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ2hlaWdodCcsIFwiXCIuY29uY2F0KGhlaWdodCwgXCJweFwiKSk7XG4gICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnRyYW5zZm9ybSA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAndHJhbnNmb3JtJywgdGhpcy5nZXRBdHRyaWJ1dGUoJ3BhdHRlcm5UcmFuc2Zvcm0nKS5nZXRWYWx1ZSgpKTtcbiAgICBwYXR0ZXJuU3ZnLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbjtcbiAgICB2YXIgcGF0dGVybkNhbnZhcyA9IHRoaXMuZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIHZhciBwYXR0ZXJuQ3R4ID0gcGF0dGVybkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIHZhciB4QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4Jyk7XG4gICAgdmFyIHlBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKTtcblxuICAgIGlmICh4QXR0ci5oYXNWYWx1ZSgpICYmIHlBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHBhdHRlcm5DdHgudHJhbnNsYXRlKHhBdHRyLmdldFBpeGVscygneCcsIHRydWUpLCB5QXR0ci5nZXRQaXhlbHMoJ3knLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudE9wYWNpdHlQcm9wLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuc3R5bGVzWydmaWxsLW9wYWNpdHknXSA9IHBhcmVudE9wYWNpdHlQcm9wO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWZsZWN0LmRlbGV0ZVByb3BlcnR5KHRoaXMuc3R5bGVzLCAnZmlsbC1vcGFjaXR5Jyk7XG4gICAgfSAvLyByZW5kZXIgM3gzIGdyaWQgc28gd2hlbiB3ZSB0cmFuc2Zvcm0gdGhlcmUncyBubyB3aGl0ZSBzcGFjZSBvbiBlZGdlc1xuXG5cbiAgICBmb3IgKHZhciB4ID0gLTE7IHggPD0gMTsgeCsrKSB7XG4gICAgICBmb3IgKHZhciB5ID0gLTE7IHkgPD0gMTsgeSsrKSB7XG4gICAgICAgIHBhdHRlcm5DdHguc2F2ZSgpO1xuICAgICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMueCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAneCcsIHggKiBwYXR0ZXJuQ2FudmFzLndpZHRoKTtcbiAgICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnkgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3knLCB5ICogcGF0dGVybkNhbnZhcy5oZWlnaHQpO1xuICAgICAgICBwYXR0ZXJuU3ZnLnJlbmRlcihwYXR0ZXJuQ3R4KTtcbiAgICAgICAgcGF0dGVybkN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybihwYXR0ZXJuQ2FudmFzLCAncmVwZWF0Jyk7XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cblxufVxuXG5jbGFzcyBNYXJrZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ21hcmtlcic7XG4gIH1cblxuICByZW5kZXIoY3R4LCBwb2ludCwgYW5nbGUpIHtcbiAgICBpZiAoIXBvaW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHBvaW50O1xuICAgIHZhciBvcmllbnQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnb3JpZW50JykuZ2V0U3RyaW5nKCdhdXRvJyk7XG4gICAgdmFyIG1hcmtlclVuaXRzID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ21hcmtlclVuaXRzJykuZ2V0U3RyaW5nKCdzdHJva2VXaWR0aCcpO1xuICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG5cbiAgICBpZiAob3JpZW50ID09PSAnYXV0bycpIHtcbiAgICAgIGN0eC5yb3RhdGUoYW5nbGUpO1xuICAgIH1cblxuICAgIGlmIChtYXJrZXJVbml0cyA9PT0gJ3N0cm9rZVdpZHRoJykge1xuICAgICAgY3R4LnNjYWxlKGN0eC5saW5lV2lkdGgsIGN0eC5saW5lV2lkdGgpO1xuICAgIH1cblxuICAgIGN0eC5zYXZlKCk7IC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudFxuXG4gICAgdmFyIG1hcmtlclN2ZyA9IG5ldyBTVkdFbGVtZW50KHRoaXMuZG9jdW1lbnQsIG51bGwpO1xuICAgIG1hcmtlclN2Zy50eXBlID0gdGhpcy50eXBlO1xuICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnZpZXdCb3ggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3ZpZXdCb3gnLCB0aGlzLmdldEF0dHJpYnV0ZSgndmlld0JveCcpLmdldFZhbHVlKCkpO1xuICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnJlZlggPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3JlZlgnLCB0aGlzLmdldEF0dHJpYnV0ZSgncmVmWCcpLmdldFZhbHVlKCkpO1xuICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLnJlZlkgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3JlZlknLCB0aGlzLmdldEF0dHJpYnV0ZSgncmVmWScpLmdldFZhbHVlKCkpO1xuICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICd3aWR0aCcsIHRoaXMuZ2V0QXR0cmlidXRlKCdtYXJrZXJXaWR0aCcpLmdldFZhbHVlKCkpO1xuICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnaGVpZ2h0JywgdGhpcy5nZXRBdHRyaWJ1dGUoJ21hcmtlckhlaWdodCcpLmdldFZhbHVlKCkpO1xuICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLm92ZXJmbG93ID0gbmV3IFByb3BlcnR5KHRoaXMuZG9jdW1lbnQsICdvdmVyZmxvdycsIHRoaXMuZ2V0QXR0cmlidXRlKCdvdmVyZmxvdycpLmdldFZhbHVlKCkpO1xuICAgIG1hcmtlclN2Zy5hdHRyaWJ1dGVzLmZpbGwgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ2ZpbGwnLCB0aGlzLmdldEF0dHJpYnV0ZSgnZmlsbCcpLmdldENvbG9yKCdibGFjaycpKTtcbiAgICBtYXJrZXJTdmcuYXR0cmlidXRlcy5zdHJva2UgPSBuZXcgUHJvcGVydHkodGhpcy5kb2N1bWVudCwgJ3N0cm9rZScsIHRoaXMuZ2V0QXR0cmlidXRlKCdzdHJva2UnKS5nZXRWYWx1ZSgnbm9uZScpKTtcbiAgICBtYXJrZXJTdmcuY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIG1hcmtlclN2Zy5yZW5kZXIoY3R4KTtcbiAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgaWYgKG1hcmtlclVuaXRzID09PSAnc3Ryb2tlV2lkdGgnKSB7XG4gICAgICBjdHguc2NhbGUoMSAvIGN0eC5saW5lV2lkdGgsIDEgLyBjdHgubGluZVdpZHRoKTtcbiAgICB9XG5cbiAgICBpZiAob3JpZW50ID09PSAnYXV0bycpIHtcbiAgICAgIGN0eC5yb3RhdGUoLWFuZ2xlKTtcbiAgICB9XG5cbiAgICBjdHgudHJhbnNsYXRlKC14LCAteSk7XG4gIH1cblxufVxuXG5jbGFzcyBEZWZzRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdkZWZzJztcbiAgfVxuXG4gIHJlbmRlcigpIHsvLyBOT09QXG4gIH1cblxufVxuXG5jbGFzcyBHRWxlbWVudCBleHRlbmRzIFJlbmRlcmVkRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2cnO1xuICB9XG5cbiAgZ2V0Qm91bmRpbmdCb3goY3R4KSB7XG4gICAgdmFyIGJvdW5kaW5nQm94ID0gbmV3IEJvdW5kaW5nQm94KCk7XG4gICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGJvdW5kaW5nQm94LmFkZEJvdW5kaW5nQm94KGNoaWxkLmdldEJvdW5kaW5nQm94KGN0eCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBib3VuZGluZ0JveDtcbiAgfVxuXG59XG5cbmNsYXNzIEdyYWRpZW50RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQgPSBbJ2dyYWRpZW50VW5pdHMnXTtcbiAgICB0aGlzLnN0b3BzID0gW107XG4gICAgdmFyIHtcbiAgICAgIHN0b3BzLFxuICAgICAgY2hpbGRyZW5cbiAgICB9ID0gdGhpcztcbiAgICBjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGlmIChjaGlsZC50eXBlID09PSAnc3RvcCcpIHtcbiAgICAgICAgc3RvcHMucHVzaChjaGlsZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXRHcmFkaWVudFVuaXRzKCkge1xuICAgIHJldHVybiB0aGlzLmdldEF0dHJpYnV0ZSgnZ3JhZGllbnRVbml0cycpLmdldFN0cmluZygnb2JqZWN0Qm91bmRpbmdCb3gnKTtcbiAgfVxuXG4gIGNyZWF0ZUdyYWRpZW50KGN0eCwgZWxlbWVudCwgcGFyZW50T3BhY2l0eVByb3ApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXRoaXMtYWxpYXMsIGNvbnNpc3RlbnQtdGhpc1xuICAgIHZhciBzdG9wc0NvbnRhaW5lciA9IHRoaXM7XG5cbiAgICBpZiAodGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuaGFzVmFsdWUoKSkge1xuICAgICAgc3RvcHNDb250YWluZXIgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgICB0aGlzLmluaGVyaXRTdG9wQ29udGFpbmVyKHN0b3BzQ29udGFpbmVyKTtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgc3RvcHNcbiAgICB9ID0gc3RvcHNDb250YWluZXI7XG4gICAgdmFyIGdyYWRpZW50ID0gdGhpcy5nZXRHcmFkaWVudChjdHgsIGVsZW1lbnQpO1xuXG4gICAgaWYgKCFncmFkaWVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkUGFyZW50T3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCwgc3RvcHNbc3RvcHMubGVuZ3RoIC0gMV0uY29sb3IpO1xuICAgIH1cblxuICAgIHN0b3BzLmZvckVhY2goc3RvcCA9PiB7XG4gICAgICBncmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcC5vZmZzZXQsIHRoaXMuYWRkUGFyZW50T3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCwgc3RvcC5jb2xvcikpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIC8vIHJlbmRlciBhcyB0cmFuc2Zvcm1lZCBwYXR0ZXJuIG9uIHRlbXBvcmFyeSBjYW52YXNcbiAgICAgIHZhciB7XG4gICAgICAgIGRvY3VtZW50XG4gICAgICB9ID0gdGhpcztcbiAgICAgIHZhciB7XG4gICAgICAgIE1BWF9WSVJUVUFMX1BJWEVMUyxcbiAgICAgICAgdmlld1BvcnRcbiAgICAgIH0gPSBkb2N1bWVudC5zY3JlZW47XG4gICAgICB2YXIgW3Jvb3RWaWV3XSA9IHZpZXdQb3J0LnZpZXdQb3J0cztcbiAgICAgIHZhciByZWN0ID0gbmV3IFJlY3RFbGVtZW50KGRvY3VtZW50LCBudWxsKTtcbiAgICAgIHJlY3QuYXR0cmlidXRlcy54ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAneCcsIC1NQVhfVklSVFVBTF9QSVhFTFMgLyAzLjApO1xuICAgICAgcmVjdC5hdHRyaWJ1dGVzLnkgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd5JywgLU1BWF9WSVJUVUFMX1BJWEVMUyAvIDMuMCk7XG4gICAgICByZWN0LmF0dHJpYnV0ZXMud2lkdGggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd3aWR0aCcsIE1BWF9WSVJUVUFMX1BJWEVMUyk7XG4gICAgICByZWN0LmF0dHJpYnV0ZXMuaGVpZ2h0ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnaGVpZ2h0JywgTUFYX1ZJUlRVQUxfUElYRUxTKTtcbiAgICAgIHZhciBncm91cCA9IG5ldyBHRWxlbWVudChkb2N1bWVudCwgbnVsbCk7XG4gICAgICBncm91cC5hdHRyaWJ1dGVzLnRyYW5zZm9ybSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3RyYW5zZm9ybScsIHRoaXMuZ2V0QXR0cmlidXRlKCdncmFkaWVudFRyYW5zZm9ybScpLmdldFZhbHVlKCkpO1xuICAgICAgZ3JvdXAuY2hpbGRyZW4gPSBbcmVjdF07XG4gICAgICB2YXIgcGF0dGVyblN2ZyA9IG5ldyBTVkdFbGVtZW50KGRvY3VtZW50LCBudWxsKTtcbiAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy54ID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAneCcsIDApO1xuICAgICAgcGF0dGVyblN2Zy5hdHRyaWJ1dGVzLnkgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd5JywgMCk7XG4gICAgICBwYXR0ZXJuU3ZnLmF0dHJpYnV0ZXMud2lkdGggPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd3aWR0aCcsIHJvb3RWaWV3LndpZHRoKTtcbiAgICAgIHBhdHRlcm5TdmcuYXR0cmlidXRlcy5oZWlnaHQgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdoZWlnaHQnLCByb290Vmlldy5oZWlnaHQpO1xuICAgICAgcGF0dGVyblN2Zy5jaGlsZHJlbiA9IFtncm91cF07XG4gICAgICB2YXIgcGF0dGVybkNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUNhbnZhcyhyb290Vmlldy53aWR0aCwgcm9vdFZpZXcuaGVpZ2h0KTtcbiAgICAgIHZhciBwYXR0ZXJuQ3R4ID0gcGF0dGVybkNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgcGF0dGVybkN0eC5maWxsU3R5bGUgPSBncmFkaWVudDtcbiAgICAgIHBhdHRlcm5TdmcucmVuZGVyKHBhdHRlcm5DdHgpO1xuICAgICAgcmV0dXJuIHBhdHRlcm5DdHguY3JlYXRlUGF0dGVybihwYXR0ZXJuQ2FudmFzLCAnbm8tcmVwZWF0Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGdyYWRpZW50O1xuICB9XG5cbiAgaW5oZXJpdFN0b3BDb250YWluZXIoc3RvcHNDb250YWluZXIpIHtcbiAgICB0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQuZm9yRWFjaChhdHRyaWJ1dGVUb0luaGVyaXQgPT4ge1xuICAgICAgaWYgKCF0aGlzLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLmhhc1ZhbHVlKCkgJiYgc3RvcHNDb250YWluZXIuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZVRvSW5oZXJpdCkuaGFzVmFsdWUoKSkge1xuICAgICAgICB0aGlzLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQsIHRydWUpLnNldFZhbHVlKHN0b3BzQ29udGFpbmVyLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVUb0luaGVyaXQpLmdldFZhbHVlKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgYWRkUGFyZW50T3BhY2l0eShwYXJlbnRPcGFjaXR5UHJvcCwgY29sb3IpIHtcbiAgICBpZiAocGFyZW50T3BhY2l0eVByb3AuaGFzVmFsdWUoKSkge1xuICAgICAgdmFyIGNvbG9yUHJvcCA9IG5ldyBQcm9wZXJ0eSh0aGlzLmRvY3VtZW50LCAnY29sb3InLCBjb2xvcik7XG4gICAgICByZXR1cm4gY29sb3JQcm9wLmFkZE9wYWNpdHkocGFyZW50T3BhY2l0eVByb3ApLmdldENvbG9yKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbG9yO1xuICB9XG5cbn1cblxuY2xhc3MgTGluZWFyR3JhZGllbnRFbGVtZW50IGV4dGVuZHMgR3JhZGllbnRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2xpbmVhckdyYWRpZW50JztcbiAgICB0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgneDEnLCAneTEnLCAneDInLCAneTInKTtcbiAgfVxuXG4gIGdldEdyYWRpZW50KGN0eCwgZWxlbWVudCkge1xuICAgIHZhciBpc0JvdW5kaW5nQm94VW5pdHMgPSB0aGlzLmdldEdyYWRpZW50VW5pdHMoKSA9PT0gJ29iamVjdEJvdW5kaW5nQm94JztcbiAgICB2YXIgYm91bmRpbmdCb3ggPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBlbGVtZW50LmdldEJvdW5kaW5nQm94KGN0eCkgOiBudWxsO1xuXG4gICAgaWYgKGlzQm91bmRpbmdCb3hVbml0cyAmJiAhYm91bmRpbmdCb3gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJykuaGFzVmFsdWUoKSAmJiAhdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJykuaGFzVmFsdWUoKSAmJiAhdGhpcy5nZXRBdHRyaWJ1dGUoJ3gyJykuaGFzVmFsdWUoKSAmJiAhdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgICB0aGlzLmdldEF0dHJpYnV0ZSgneTEnLCB0cnVlKS5zZXRWYWx1ZSgwKTtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCd4MicsIHRydWUpLnNldFZhbHVlKDEpO1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3kyJywgdHJ1ZSkuc2V0VmFsdWUoMCk7XG4gICAgfVxuXG4gICAgdmFyIHgxID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueCArIGJvdW5kaW5nQm94LndpZHRoICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3gxJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgneDEnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgeTEgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3kxJykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgneTEnKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgeDIgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC54ICsgYm91bmRpbmdCb3gud2lkdGggKiB0aGlzLmdldEF0dHJpYnV0ZSgneDInKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCd4MicpLmdldFBpeGVscygneCcpO1xuICAgIHZhciB5MiA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnkgKyBib3VuZGluZ0JveC5oZWlnaHQgKiB0aGlzLmdldEF0dHJpYnV0ZSgneTInKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCd5MicpLmdldFBpeGVscygneScpO1xuXG4gICAgaWYgKHgxID09PSB4MiAmJiB5MSA9PT0geTIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQoeDEsIHkxLCB4MiwgeTIpO1xuICB9XG5cbn1cblxuY2xhc3MgUmFkaWFsR3JhZGllbnRFbGVtZW50IGV4dGVuZHMgR3JhZGllbnRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ3JhZGlhbEdyYWRpZW50JztcbiAgICB0aGlzLmF0dHJpYnV0ZXNUb0luaGVyaXQucHVzaCgnY3gnLCAnY3knLCAncicsICdmeCcsICdmeScsICdmcicpO1xuICB9XG5cbiAgZ2V0R3JhZGllbnQoY3R4LCBlbGVtZW50KSB7XG4gICAgdmFyIGlzQm91bmRpbmdCb3hVbml0cyA9IHRoaXMuZ2V0R3JhZGllbnRVbml0cygpID09PSAnb2JqZWN0Qm91bmRpbmdCb3gnO1xuICAgIHZhciBib3VuZGluZ0JveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KTtcblxuICAgIGlmIChpc0JvdW5kaW5nQm94VW5pdHMgJiYgIWJvdW5kaW5nQm94KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCdjeCcpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdjeCcsIHRydWUpLnNldFZhbHVlKCc1MCUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCdjeScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMuZ2V0QXR0cmlidXRlKCdjeScsIHRydWUpLnNldFZhbHVlKCc1MCUnKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuZ2V0QXR0cmlidXRlKCdyJykuaGFzVmFsdWUoKSkge1xuICAgICAgdGhpcy5nZXRBdHRyaWJ1dGUoJ3InLCB0cnVlKS5zZXRWYWx1ZSgnNTAlJyk7XG4gICAgfVxuXG4gICAgdmFyIGN4ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueCArIGJvdW5kaW5nQm94LndpZHRoICogdGhpcy5nZXRBdHRyaWJ1dGUoJ2N4JykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgnY3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgY3kgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyBib3VuZGluZ0JveC55ICsgYm91bmRpbmdCb3guaGVpZ2h0ICogdGhpcy5nZXRBdHRyaWJ1dGUoJ2N5JykuZ2V0TnVtYmVyKCkgOiB0aGlzLmdldEF0dHJpYnV0ZSgnY3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgZnggPSBjeDtcbiAgICB2YXIgZnkgPSBjeTtcblxuICAgIGlmICh0aGlzLmdldEF0dHJpYnV0ZSgnZngnKS5oYXNWYWx1ZSgpKSB7XG4gICAgICBmeCA9IGlzQm91bmRpbmdCb3hVbml0cyA/IGJvdW5kaW5nQm94LnggKyBib3VuZGluZ0JveC53aWR0aCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdmeCcpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZ2V0QXR0cmlidXRlKCdmeScpLmhhc1ZhbHVlKCkpIHtcbiAgICAgIGZ5ID0gaXNCb3VuZGluZ0JveFVuaXRzID8gYm91bmRpbmdCb3gueSArIGJvdW5kaW5nQm94LmhlaWdodCAqIHRoaXMuZ2V0QXR0cmlidXRlKCdmeScpLmdldE51bWJlcigpIDogdGhpcy5nZXRBdHRyaWJ1dGUoJ2Z5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgfVxuXG4gICAgdmFyIHIgPSBpc0JvdW5kaW5nQm94VW5pdHMgPyAoYm91bmRpbmdCb3gud2lkdGggKyBib3VuZGluZ0JveC5oZWlnaHQpIC8gMi4wICogdGhpcy5nZXRBdHRyaWJ1dGUoJ3InKS5nZXROdW1iZXIoKSA6IHRoaXMuZ2V0QXR0cmlidXRlKCdyJykuZ2V0UGl4ZWxzKCk7XG4gICAgdmFyIGZyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2ZyJykuZ2V0UGl4ZWxzKCk7XG4gICAgcmV0dXJuIGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChmeCwgZnksIGZyLCBjeCwgY3ksIHIpO1xuICB9XG5cbn1cblxuY2xhc3MgU3RvcEVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ3N0b3AnO1xuICAgIHZhciBvZmZzZXQgPSBNYXRoLm1heCgwLCBNYXRoLm1pbigxLCB0aGlzLmdldEF0dHJpYnV0ZSgnb2Zmc2V0JykuZ2V0TnVtYmVyKCkpKTtcbiAgICB2YXIgc3RvcE9wYWNpdHkgPSB0aGlzLmdldFN0eWxlKCdzdG9wLW9wYWNpdHknKTtcbiAgICB2YXIgc3RvcENvbG9yID0gdGhpcy5nZXRTdHlsZSgnc3RvcC1jb2xvcicsIHRydWUpO1xuXG4gICAgaWYgKHN0b3BDb2xvci5nZXRTdHJpbmcoKSA9PT0gJycpIHtcbiAgICAgIHN0b3BDb2xvci5zZXRWYWx1ZSgnIzAwMCcpO1xuICAgIH1cblxuICAgIGlmIChzdG9wT3BhY2l0eS5oYXNWYWx1ZSgpKSB7XG4gICAgICBzdG9wQ29sb3IgPSBzdG9wQ29sb3IuYWRkT3BhY2l0eShzdG9wT3BhY2l0eSk7XG4gICAgfVxuXG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5jb2xvciA9IHN0b3BDb2xvci5nZXRDb2xvcigpO1xuICB9XG5cbn1cblxuY2xhc3MgQW5pbWF0ZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2FuaW1hdGUnO1xuICAgIHRoaXMuZHVyYXRpb24gPSAwO1xuICAgIHRoaXMuaW5pdGlhbFZhbHVlID0gbnVsbDtcbiAgICB0aGlzLmluaXRpYWxVbml0cyA9ICcnO1xuICAgIHRoaXMucmVtb3ZlZCA9IGZhbHNlO1xuICAgIHRoaXMuZnJvemVuID0gZmFsc2U7XG4gICAgZG9jdW1lbnQuc2NyZWVuLmFuaW1hdGlvbnMucHVzaCh0aGlzKTtcbiAgICB0aGlzLmJlZ2luID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2JlZ2luJykuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgdGhpcy5tYXhEdXJhdGlvbiA9IHRoaXMuYmVnaW4gKyB0aGlzLmdldEF0dHJpYnV0ZSgnZHVyJykuZ2V0TWlsbGlzZWNvbmRzKCk7XG4gICAgdGhpcy5mcm9tID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Zyb20nKTtcbiAgICB0aGlzLnRvID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3RvJyk7XG4gICAgdGhpcy52YWx1ZXMgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICd2YWx1ZXMnLCBudWxsKTtcbiAgICB2YXIgdmFsdWVzQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd2YWx1ZXMnKTtcblxuICAgIGlmICh2YWx1ZXNBdHRyLmhhc1ZhbHVlKCkpIHtcbiAgICAgIHRoaXMudmFsdWVzLnNldFZhbHVlKHZhbHVlc0F0dHIuZ2V0U3RyaW5nKCkuc3BsaXQoJzsnKSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0UHJvcGVydHkoKSB7XG4gICAgdmFyIGF0dHJpYnV0ZVR5cGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXR0cmlidXRlVHlwZScpLmdldFN0cmluZygpO1xuICAgIHZhciBhdHRyaWJ1dGVOYW1lID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2F0dHJpYnV0ZU5hbWUnKS5nZXRTdHJpbmcoKTtcblxuICAgIGlmIChhdHRyaWJ1dGVUeXBlID09PSAnQ1NTJykge1xuICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldFN0eWxlKGF0dHJpYnV0ZU5hbWUsIHRydWUpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhcmVudC5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSwgdHJ1ZSk7XG4gIH1cblxuICBjYWxjVmFsdWUoKSB7XG4gICAgdmFyIHtcbiAgICAgIGluaXRpYWxVbml0c1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciB7XG4gICAgICBwcm9ncmVzcyxcbiAgICAgIGZyb20sXG4gICAgICB0b1xuICAgIH0gPSB0aGlzLmdldFByb2dyZXNzKCk7IC8vIHR3ZWVuIHZhbHVlIGxpbmVhcmx5XG5cbiAgICB2YXIgbmV3VmFsdWUgPSBmcm9tLmdldE51bWJlcigpICsgKHRvLmdldE51bWJlcigpIC0gZnJvbS5nZXROdW1iZXIoKSkgKiBwcm9ncmVzcztcblxuICAgIGlmIChpbml0aWFsVW5pdHMgPT09ICclJykge1xuICAgICAgbmV3VmFsdWUgKj0gMTAwLjA7IC8vIG51bVZhbHVlKCkgcmV0dXJucyAwLTEgd2hlcmVhcyBwcm9wZXJ0aWVzIGFyZSAwLTEwMFxuICAgIH1cblxuICAgIHJldHVybiBcIlwiLmNvbmNhdChuZXdWYWx1ZSkuY29uY2F0KGluaXRpYWxVbml0cyk7XG4gIH1cblxuICB1cGRhdGUoZGVsdGEpIHtcbiAgICB2YXIge1xuICAgICAgcGFyZW50XG4gICAgfSA9IHRoaXM7XG4gICAgdmFyIHByb3AgPSB0aGlzLmdldFByb3BlcnR5KCk7IC8vIHNldCBpbml0aWFsIHZhbHVlXG5cbiAgICBpZiAoIXRoaXMuaW5pdGlhbFZhbHVlKSB7XG4gICAgICB0aGlzLmluaXRpYWxWYWx1ZSA9IHByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICB0aGlzLmluaXRpYWxVbml0cyA9IHByb3AuZ2V0VW5pdHMoKTtcbiAgICB9IC8vIGlmIHdlJ3JlIHBhc3QgdGhlIGVuZCB0aW1lXG5cblxuICAgIGlmICh0aGlzLmR1cmF0aW9uID4gdGhpcy5tYXhEdXJhdGlvbikge1xuICAgICAgdmFyIGZpbGwgPSB0aGlzLmdldEF0dHJpYnV0ZSgnZmlsbCcpLmdldFN0cmluZygncmVtb3ZlJyk7IC8vIGxvb3AgZm9yIGluZGVmaW5pdGVseSByZXBlYXRpbmcgYW5pbWF0aW9uc1xuXG4gICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoJ3JlcGVhdENvdW50JykuZ2V0U3RyaW5nKCkgPT09ICdpbmRlZmluaXRlJyB8fCB0aGlzLmdldEF0dHJpYnV0ZSgncmVwZWF0RHVyJykuZ2V0U3RyaW5nKCkgPT09ICdpbmRlZmluaXRlJykge1xuICAgICAgICB0aGlzLmR1cmF0aW9uID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoZmlsbCA9PT0gJ2ZyZWV6ZScgJiYgIXRoaXMuZnJvemVuKSB7XG4gICAgICAgIHRoaXMuZnJvemVuID0gdHJ1ZTtcbiAgICAgICAgcGFyZW50LmFuaW1hdGlvbkZyb3plbiA9IHRydWU7XG4gICAgICAgIHBhcmVudC5hbmltYXRpb25Gcm96ZW5WYWx1ZSA9IHByb3AuZ2V0U3RyaW5nKCk7XG4gICAgICB9IGVsc2UgaWYgKGZpbGwgPT09ICdyZW1vdmUnICYmICF0aGlzLnJlbW92ZWQpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgcHJvcC5zZXRWYWx1ZShwYXJlbnQuYW5pbWF0aW9uRnJvemVuID8gcGFyZW50LmFuaW1hdGlvbkZyb3plblZhbHVlIDogdGhpcy5pbml0aWFsVmFsdWUpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuZHVyYXRpb24gKz0gZGVsdGE7IC8vIGlmIHdlJ3JlIHBhc3QgdGhlIGJlZ2luIHRpbWVcblxuICAgIHZhciB1cGRhdGVkID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5iZWdpbiA8IHRoaXMuZHVyYXRpb24pIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuY2FsY1ZhbHVlKCk7IC8vIHR3ZWVuXG5cbiAgICAgIHZhciB0eXBlQXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd0eXBlJyk7XG5cbiAgICAgIGlmICh0eXBlQXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICAgIC8vIGZvciB0cmFuc2Zvcm0sIGV0Yy5cbiAgICAgICAgdmFyIHR5cGUgPSB0eXBlQXR0ci5nZXRTdHJpbmcoKTtcbiAgICAgICAgbmV3VmFsdWUgPSBcIlwiLmNvbmNhdCh0eXBlLCBcIihcIikuY29uY2F0KG5ld1ZhbHVlLCBcIilcIik7XG4gICAgICB9XG5cbiAgICAgIHByb3Auc2V0VmFsdWUobmV3VmFsdWUpO1xuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH1cblxuICBnZXRQcm9ncmVzcygpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICB2YWx1ZXNcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgcmVzdWx0ID0ge1xuICAgICAgcHJvZ3Jlc3M6ICh0aGlzLmR1cmF0aW9uIC0gdGhpcy5iZWdpbikgLyAodGhpcy5tYXhEdXJhdGlvbiAtIHRoaXMuYmVnaW4pXG4gICAgfTtcblxuICAgIGlmICh2YWx1ZXMuaGFzVmFsdWUoKSkge1xuICAgICAgdmFyIHAgPSByZXN1bHQucHJvZ3Jlc3MgKiAodmFsdWVzLmdldFZhbHVlKCkubGVuZ3RoIC0gMSk7XG4gICAgICB2YXIgbGIgPSBNYXRoLmZsb29yKHApO1xuICAgICAgdmFyIHViID0gTWF0aC5jZWlsKHApO1xuICAgICAgcmVzdWx0LmZyb20gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdmcm9tJywgcGFyc2VGbG9hdCh2YWx1ZXMuZ2V0VmFsdWUoKVtsYl0pKTtcbiAgICAgIHJlc3VsdC50byA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3RvJywgcGFyc2VGbG9hdCh2YWx1ZXMuZ2V0VmFsdWUoKVt1Yl0pKTtcbiAgICAgIHJlc3VsdC5wcm9ncmVzcyA9IChwIC0gbGIpIC8gKHViIC0gbGIpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQuZnJvbSA9IHRoaXMuZnJvbTtcbiAgICAgIHJlc3VsdC50byA9IHRoaXMudG87XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG59XG5cbmNsYXNzIEFuaW1hdGVDb2xvckVsZW1lbnQgZXh0ZW5kcyBBbmltYXRlRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2FuaW1hdGVDb2xvcic7XG4gIH1cblxuICBjYWxjVmFsdWUoKSB7XG4gICAgdmFyIHtcbiAgICAgIHByb2dyZXNzLFxuICAgICAgZnJvbSxcbiAgICAgIHRvXG4gICAgfSA9IHRoaXMuZ2V0UHJvZ3Jlc3MoKTtcbiAgICB2YXIgY29sb3JGcm9tID0gbmV3IFJHQkNvbG9yKGZyb20uZ2V0Q29sb3IoKSk7XG4gICAgdmFyIGNvbG9yVG8gPSBuZXcgUkdCQ29sb3IodG8uZ2V0Q29sb3IoKSk7XG5cbiAgICBpZiAoY29sb3JGcm9tLm9rICYmIGNvbG9yVG8ub2spIHtcbiAgICAgIC8vIHR3ZWVuIGNvbG9yIGxpbmVhcmx5XG4gICAgICB2YXIgciA9IGNvbG9yRnJvbS5yICsgKGNvbG9yVG8uciAtIGNvbG9yRnJvbS5yKSAqIHByb2dyZXNzO1xuICAgICAgdmFyIGcgPSBjb2xvckZyb20uZyArIChjb2xvclRvLmcgLSBjb2xvckZyb20uZykgKiBwcm9ncmVzcztcbiAgICAgIHZhciBiID0gY29sb3JGcm9tLmIgKyAoY29sb3JUby5iIC0gY29sb3JGcm9tLmIpICogcHJvZ3Jlc3M7IC8vID8gYWxwaGFcblxuICAgICAgcmV0dXJuIFwicmdiKFwiLmNvbmNhdChNYXRoLmZsb29yKHIpLCBcIiwgXCIpLmNvbmNhdChNYXRoLmZsb29yKGcpLCBcIiwgXCIpLmNvbmNhdChNYXRoLmZsb29yKGIpLCBcIilcIik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKCdmcm9tJykuZ2V0Q29sb3IoKTtcbiAgfVxuXG59XG5cbmNsYXNzIEFuaW1hdGVUcmFuc2Zvcm1FbGVtZW50IGV4dGVuZHMgQW5pbWF0ZUVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdhbmltYXRlVHJhbnNmb3JtJztcbiAgfVxuXG4gIGNhbGNWYWx1ZSgpIHtcbiAgICB2YXIge1xuICAgICAgcHJvZ3Jlc3MsXG4gICAgICBmcm9tLFxuICAgICAgdG9cbiAgICB9ID0gdGhpcy5nZXRQcm9ncmVzcygpOyAvLyB0d2VlbiB2YWx1ZSBsaW5lYXJseVxuXG4gICAgdmFyIHRyYW5zZm9ybUZyb20gPSB0b051bWJlcnMoZnJvbS5nZXRTdHJpbmcoKSk7XG4gICAgdmFyIHRyYW5zZm9ybVRvID0gdG9OdW1iZXJzKHRvLmdldFN0cmluZygpKTtcbiAgICB2YXIgbmV3VmFsdWUgPSB0cmFuc2Zvcm1Gcm9tLm1hcCgoZnJvbSwgaSkgPT4ge1xuICAgICAgdmFyIHRvID0gdHJhbnNmb3JtVG9baV07XG4gICAgICByZXR1cm4gZnJvbSArICh0byAtIGZyb20pICogcHJvZ3Jlc3M7XG4gICAgfSkuam9pbignICcpO1xuICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgfVxuXG59XG5cbmNsYXNzIEZvbnRFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKSB7XG4gICAgc3VwZXIoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpO1xuICAgIHRoaXMudHlwZSA9ICdmb250JztcbiAgICB0aGlzLmdseXBocyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5ob3JpekFkdlggPSB0aGlzLmdldEF0dHJpYnV0ZSgnaG9yaXotYWR2LXgnKS5nZXROdW1iZXIoKTtcbiAgICB2YXIge1xuICAgICAgZGVmaW5pdGlvbnNcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgdmFyIHtcbiAgICAgIGNoaWxkcmVuXG4gICAgfSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgc3dpdGNoIChjaGlsZC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ZvbnQtZmFjZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdGhpcy5mb250RmFjZSA9IGNoaWxkO1xuICAgICAgICAgICAgdmFyIGZvbnRGYW1pbHlTdHlsZSA9IGNoaWxkLmdldFN0eWxlKCdmb250LWZhbWlseScpO1xuXG4gICAgICAgICAgICBpZiAoZm9udEZhbWlseVN0eWxlLmhhc1ZhbHVlKCkpIHtcbiAgICAgICAgICAgICAgZGVmaW5pdGlvbnNbZm9udEZhbWlseVN0eWxlLmdldFN0cmluZygpXSA9IHRoaXM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtaXNzaW5nLWdseXBoJzpcbiAgICAgICAgICB0aGlzLm1pc3NpbmdHbHlwaCA9IGNoaWxkO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ2dseXBoJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgZ2x5cGggPSBjaGlsZDtcblxuICAgICAgICAgICAgaWYgKGdseXBoLmFyYWJpY0Zvcm0pIHtcbiAgICAgICAgICAgICAgdGhpcy5pc1JUTCA9IHRydWU7XG4gICAgICAgICAgICAgIHRoaXMuaXNBcmFiaWMgPSB0cnVlO1xuXG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5nbHlwaHNbZ2x5cGgudW5pY29kZV0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5nbHlwaHNbZ2x5cGgudW5pY29kZV0gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgdGhpcy5nbHlwaHNbZ2x5cGgudW5pY29kZV1bZ2x5cGguYXJhYmljRm9ybV0gPSBnbHlwaDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2dseXBoLnVuaWNvZGVdID0gZ2x5cGg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7Ly8gTk8gUkVOREVSXG4gIH1cblxufVxuXG5jbGFzcyBGb250RmFjZUVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2ZvbnQtZmFjZSc7XG4gICAgdGhpcy5hc2NlbnQgPSB0aGlzLmdldEF0dHJpYnV0ZSgnYXNjZW50JykuZ2V0TnVtYmVyKCk7XG4gICAgdGhpcy5kZXNjZW50ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2Rlc2NlbnQnKS5nZXROdW1iZXIoKTtcbiAgICB0aGlzLnVuaXRzUGVyRW0gPSB0aGlzLmdldEF0dHJpYnV0ZSgndW5pdHMtcGVyLWVtJykuZ2V0TnVtYmVyKCk7XG4gIH1cblxufVxuXG5jbGFzcyBNaXNzaW5nR2x5cGhFbGVtZW50IGV4dGVuZHMgUGF0aEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdtaXNzaW5nLWdseXBoJztcbiAgICB0aGlzLmhvcml6QWR2WCA9IDA7XG4gIH1cblxufVxuXG5jbGFzcyBUUmVmRWxlbWVudCBleHRlbmRzIFRleHRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAndHJlZic7XG4gIH1cblxuICBnZXRUZXh0KCkge1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBmaXJzdENoaWxkID0gZWxlbWVudC5jaGlsZHJlblswXTtcblxuICAgICAgaWYgKGZpcnN0Q2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGZpcnN0Q2hpbGQuZ2V0VGV4dCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxuXG59XG5cbmNsYXNzIEFFbGVtZW50IGV4dGVuZHMgVGV4dEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnYSc7XG4gICAgdmFyIHtcbiAgICAgIGNoaWxkTm9kZXNcbiAgICB9ID0gbm9kZTtcbiAgICB2YXIgZmlyc3RDaGlsZCA9IGNoaWxkTm9kZXNbMF07XG4gICAgdmFyIGhhc1RleHQgPSBjaGlsZE5vZGVzLmxlbmd0aCA+IDAgJiYgQXJyYXkuZnJvbShjaGlsZE5vZGVzKS5ldmVyeShub2RlID0+IG5vZGUubm9kZVR5cGUgPT09IDMpO1xuICAgIHRoaXMuaGFzVGV4dCA9IGhhc1RleHQ7XG4gICAgdGhpcy50ZXh0ID0gaGFzVGV4dCA/IHRoaXMuZ2V0VGV4dEZyb21Ob2RlKGZpcnN0Q2hpbGQpIDogJyc7XG4gIH1cblxuICBnZXRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHQ7XG4gIH1cblxuICByZW5kZXJDaGlsZHJlbihjdHgpIHtcbiAgICBpZiAodGhpcy5oYXNUZXh0KSB7XG4gICAgICAvLyByZW5kZXIgYXMgdGV4dCBlbGVtZW50XG4gICAgICBzdXBlci5yZW5kZXJDaGlsZHJlbihjdHgpO1xuICAgICAgdmFyIHtcbiAgICAgICAgZG9jdW1lbnQsXG4gICAgICAgIHgsXG4gICAgICAgIHlcbiAgICAgIH0gPSB0aGlzO1xuICAgICAgdmFyIHtcbiAgICAgICAgbW91c2VcbiAgICAgIH0gPSBkb2N1bWVudC5zY3JlZW47XG4gICAgICB2YXIgZm9udFNpemUgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdmb250U2l6ZScsIEZvbnQucGFyc2UoZG9jdW1lbnQuY3R4LmZvbnQpLmZvbnRTaXplKTsgLy8gRG8gbm90IGNhbGMgYm91bmRpbmcgYm94IGlmIG1vdXNlIGlzIG5vdCB3b3JraW5nLlxuXG4gICAgICBpZiAobW91c2UuaXNXb3JraW5nKCkpIHtcbiAgICAgICAgbW91c2UuY2hlY2tCb3VuZGluZ0JveCh0aGlzLCBuZXcgQm91bmRpbmdCb3goeCwgeSAtIGZvbnRTaXplLmdldFBpeGVscygneScpLCB4ICsgdGhpcy5tZWFzdXJlVGV4dChjdHgpLCB5KSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIC8vIHJlbmRlciBhcyB0ZW1wb3JhcnkgZ3JvdXBcbiAgICAgIHZhciBnID0gbmV3IEdFbGVtZW50KHRoaXMuZG9jdW1lbnQsIG51bGwpO1xuICAgICAgZy5jaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW47XG4gICAgICBnLnBhcmVudCA9IHRoaXM7XG4gICAgICBnLnJlbmRlcihjdHgpO1xuICAgIH1cbiAgfVxuXG4gIG9uQ2xpY2soKSB7XG4gICAgdmFyIHtcbiAgICAgIHdpbmRvd1xuICAgIH0gPSB0aGlzLmRvY3VtZW50O1xuXG4gICAgaWYgKHdpbmRvdykge1xuICAgICAgd2luZG93Lm9wZW4odGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0U3RyaW5nKCkpO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91c2VNb3ZlKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmRvY3VtZW50LmN0eDtcbiAgICBjdHguY2FudmFzLnN0eWxlLmN1cnNvciA9ICdwb2ludGVyJztcbiAgfVxuXG59XG5cbmZ1bmN0aW9uIG93bktleXMkMihvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMih0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDIoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuY2xhc3MgVGV4dFBhdGhFbGVtZW50IGV4dGVuZHMgVGV4dEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAndGV4dFBhdGgnO1xuICAgIHRoaXMudGV4dFdpZHRoID0gMDtcbiAgICB0aGlzLnRleHRIZWlnaHQgPSAwO1xuICAgIHRoaXMucGF0aExlbmd0aCA9IC0xO1xuICAgIHRoaXMuZ2x5cGhJbmZvID0gbnVsbDtcbiAgICB0aGlzLmxldHRlclNwYWNpbmdDYWNoZSA9IFtdO1xuICAgIHRoaXMubWVhc3VyZXNDYWNoZSA9IG5ldyBNYXAoW1snJywgMF1dKTtcbiAgICB2YXIgcGF0aEVsZW1lbnQgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXREZWZpbml0aW9uKCk7XG4gICAgdGhpcy50ZXh0ID0gdGhpcy5nZXRUZXh0RnJvbU5vZGUoKTtcbiAgICB0aGlzLmRhdGFBcnJheSA9IHRoaXMucGFyc2VQYXRoRGF0YShwYXRoRWxlbWVudCk7XG4gIH1cblxuICBnZXRUZXh0KCkge1xuICAgIHJldHVybiB0aGlzLnRleHQ7XG4gIH1cblxuICBwYXRoKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBkYXRhQXJyYXlcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChjdHgpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBkYXRhQXJyYXkuZm9yRWFjaChfcmVmID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHBvaW50c1xuICAgICAgfSA9IF9yZWY7XG5cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTU9WRV9UTzpcbiAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHBvaW50c1swXSwgcG9pbnRzWzFdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQ1VSVkVfVE86XG4gICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgaWYgKGN0eCkge1xuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8ocG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBbY3gsIGN5LCByeCwgcnksIHRoZXRhLCBkVGhldGEsIHBzaSwgZnNdID0gcG9pbnRzO1xuICAgICAgICAgICAgdmFyIHIgPSByeCA+IHJ5ID8gcnggOiByeTtcbiAgICAgICAgICAgIHZhciBzY2FsZVggPSByeCA+IHJ5ID8gMSA6IHJ4IC8gcnk7XG4gICAgICAgICAgICB2YXIgc2NhbGVZID0gcnggPiByeSA/IHJ5IC8gcnggOiAxO1xuXG4gICAgICAgICAgICBpZiAoY3R4KSB7XG4gICAgICAgICAgICAgIGN0eC50cmFuc2xhdGUoY3gsIGN5KTtcbiAgICAgICAgICAgICAgY3R4LnJvdGF0ZShwc2kpO1xuICAgICAgICAgICAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgICAgICAgICAgICBjdHguYXJjKDAsIDAsIHIsIHRoZXRhLCB0aGV0YSArIGRUaGV0YSwgQm9vbGVhbigxIC0gZnMpKTtcbiAgICAgICAgICAgICAgY3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgICAgICAgICAgICBjdHgucm90YXRlKC1wc2kpO1xuICAgICAgICAgICAgICBjdHgudHJhbnNsYXRlKC1jeCwgLWN5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5DTE9TRV9QQVRIOlxuICAgICAgICAgIGlmIChjdHgpIHtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgIHRoaXMuc2V0VGV4dERhdGEoY3R4KTtcbiAgICBjdHguc2F2ZSgpO1xuICAgIHZhciB0ZXh0RGVjb3JhdGlvbiA9IHRoaXMucGFyZW50LmdldFN0eWxlKCd0ZXh0LWRlY29yYXRpb24nKS5nZXRTdHJpbmcoKTtcbiAgICB2YXIgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgdmFyIHtcbiAgICAgIGdseXBoSW5mb1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBmaWxsID0gY3R4LmZpbGxTdHlsZTtcblxuICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICB9XG5cbiAgICBnbHlwaEluZm8uZm9yRWFjaCgoZ2x5cGgsIGkpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHAwLFxuICAgICAgICBwMSxcbiAgICAgICAgcm90YXRpb24sXG4gICAgICAgIHRleHQ6IHBhcnRpYWxUZXh0XG4gICAgICB9ID0gZ2x5cGg7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zbGF0ZShwMC54LCBwMC55KTtcbiAgICAgIGN0eC5yb3RhdGUocm90YXRpb24pO1xuXG4gICAgICBpZiAoY3R4LmZpbGxTdHlsZSkge1xuICAgICAgICBjdHguZmlsbFRleHQocGFydGlhbFRleHQsIDAsIDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoY3R4LnN0cm9rZVN0eWxlKSB7XG4gICAgICAgIGN0eC5zdHJva2VUZXh0KHBhcnRpYWxUZXh0LCAwLCAwKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgaWYgKHRleHREZWNvcmF0aW9uID09PSAndW5kZXJsaW5lJykge1xuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGN0eC5tb3ZlVG8ocDAueCwgcDAueSArIGZvbnRTaXplIC8gOCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgubGluZVRvKHAxLngsIHAxLnkgKyBmb250U2l6ZSAvIDUpO1xuICAgICAgfSAvLyAvLyBUbyBhc3Npc3Qgd2l0aCBkZWJ1Z2dpbmcgdmlzdWFsbHksIHVuY29tbWVudCBmb2xsb3dpbmdcbiAgICAgIC8vXG4gICAgICAvLyBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAvLyBpZiAoaSAlIDIpXG4gICAgICAvLyBcdGN0eC5zdHJva2VTdHlsZSA9ICdyZWQnO1xuICAgICAgLy8gZWxzZVxuICAgICAgLy8gXHRjdHguc3Ryb2tlU3R5bGUgPSAnZ3JlZW4nO1xuICAgICAgLy8gY3R4Lm1vdmVUbyhwMC54LCBwMC55KTtcbiAgICAgIC8vIGN0eC5saW5lVG8ocDEueCwgcDEueSk7XG4gICAgICAvLyBjdHguc3Ryb2tlKCk7XG4gICAgICAvLyBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICB9KTtcblxuICAgIGlmICh0ZXh0RGVjb3JhdGlvbiA9PT0gJ3VuZGVybGluZScpIHtcbiAgICAgIGN0eC5saW5lV2lkdGggPSBmb250U2l6ZSAvIDIwO1xuICAgICAgY3R4LnN0cm9rZVN0eWxlID0gZmlsbDtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgZ2V0TGV0dGVyU3BhY2luZ0F0KCkge1xuICAgIHZhciBpZHggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDA7XG4gICAgcmV0dXJuIHRoaXMubGV0dGVyU3BhY2luZ0NhY2hlW2lkeF0gfHwgMDtcbiAgfVxuXG4gIGZpbmRTZWdtZW50VG9GaXRDaGFyKGN0eCwgYW5jaG9yLCB0ZXh0RnVsbFdpZHRoLCBmdWxsUGF0aFdpZHRoLCBzcGFjZXNOdW1iZXIsIGlucHV0T2Zmc2V0LCBkeSwgYywgY2hhckkpIHtcbiAgICB2YXIgb2Zmc2V0ID0gaW5wdXRPZmZzZXQ7XG4gICAgdmFyIGdseXBoV2lkdGggPSB0aGlzLm1lYXN1cmVUZXh0KGN0eCwgYyk7XG5cbiAgICBpZiAoYyA9PT0gJyAnICYmIGFuY2hvciA9PT0gJ2p1c3RpZnknICYmIHRleHRGdWxsV2lkdGggPCBmdWxsUGF0aFdpZHRoKSB7XG4gICAgICBnbHlwaFdpZHRoICs9IChmdWxsUGF0aFdpZHRoIC0gdGV4dEZ1bGxXaWR0aCkgLyBzcGFjZXNOdW1iZXI7XG4gICAgfVxuXG4gICAgaWYgKGNoYXJJID4gLTEpIHtcbiAgICAgIG9mZnNldCArPSB0aGlzLmdldExldHRlclNwYWNpbmdBdChjaGFySSk7XG4gICAgfVxuXG4gICAgdmFyIHNwbGluZVN0ZXAgPSB0aGlzLnRleHRIZWlnaHQgLyAyMDtcbiAgICB2YXIgcDAgPSB0aGlzLmdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgob2Zmc2V0LCBzcGxpbmVTdGVwLCAwKTtcbiAgICB2YXIgcDEgPSB0aGlzLmdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgob2Zmc2V0ICsgZ2x5cGhXaWR0aCwgc3BsaW5lU3RlcCwgMCk7XG4gICAgdmFyIHNlZ21lbnQgPSB7XG4gICAgICBwMCxcbiAgICAgIHAxXG4gICAgfTtcbiAgICB2YXIgcm90YXRpb24gPSBwMCAmJiBwMSA/IE1hdGguYXRhbjIocDEueSAtIHAwLnksIHAxLnggLSBwMC54KSA6IDA7XG5cbiAgICBpZiAoZHkpIHtcbiAgICAgIHZhciBkeVggPSBNYXRoLmNvcyhNYXRoLlBJIC8gMiArIHJvdGF0aW9uKSAqIGR5O1xuICAgICAgdmFyIGR5WSA9IE1hdGguY29zKC1yb3RhdGlvbikgKiBkeTtcbiAgICAgIHNlZ21lbnQucDAgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBwMCksIHt9LCB7XG4gICAgICAgIHg6IHAwLnggKyBkeVgsXG4gICAgICAgIHk6IHAwLnkgKyBkeVlcbiAgICAgIH0pO1xuICAgICAgc2VnbWVudC5wMSA9IF9vYmplY3RTcHJlYWQkMihfb2JqZWN0U3ByZWFkJDIoe30sIHAxKSwge30sIHtcbiAgICAgICAgeDogcDEueCArIGR5WCxcbiAgICAgICAgeTogcDEueSArIGR5WVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgb2Zmc2V0ICs9IGdseXBoV2lkdGg7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9mZnNldCxcbiAgICAgIHNlZ21lbnQsXG4gICAgICByb3RhdGlvblxuICAgIH07XG4gIH1cblxuICBtZWFzdXJlVGV4dChjdHgsIHRleHQpIHtcbiAgICB2YXIge1xuICAgICAgbWVhc3VyZXNDYWNoZVxuICAgIH0gPSB0aGlzO1xuICAgIHZhciB0YXJnZXRUZXh0ID0gdGV4dCB8fCB0aGlzLmdldFRleHQoKTtcblxuICAgIGlmIChtZWFzdXJlc0NhY2hlLmhhcyh0YXJnZXRUZXh0KSkge1xuICAgICAgcmV0dXJuIG1lYXN1cmVzQ2FjaGUuZ2V0KHRhcmdldFRleHQpO1xuICAgIH1cblxuICAgIHZhciBtZWFzdXJlID0gdGhpcy5tZWFzdXJlVGFyZ2V0VGV4dChjdHgsIHRhcmdldFRleHQpO1xuICAgIG1lYXN1cmVzQ2FjaGUuc2V0KHRhcmdldFRleHQsIG1lYXN1cmUpO1xuICAgIHJldHVybiBtZWFzdXJlO1xuICB9IC8vIFRoaXMgbWV0aG9kIHN1cHBvc2VzIHdoYXQgYWxsIGN1c3RvbSBmb250cyBhbHJlYWR5IGxvYWRlZC5cbiAgLy8gSWYgc29tZSBmb250IHdpbGwgYmUgbG9hZGVkIGFmdGVyIHRoaXMgbWV0aG9kIGNhbGwsIDx0ZXh0UGF0aD4gd2lsbCBub3QgYmUgcmVuZGVyZWQgY29ycmVjdGx5LlxuICAvLyBZb3UgbmVlZCB0byBjYWxsIHRoaXMgbWV0aG9kIG1hbnVhbGx5IHRvIHVwZGF0ZSBnbHlwaHMgY2FjaGUuXG5cblxuICBzZXRUZXh0RGF0YShjdHgpIHtcbiAgICBpZiAodGhpcy5nbHlwaEluZm8pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcmVuZGVyVGV4dCA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBjaGFycyA9IHJlbmRlclRleHQuc3BsaXQoJycpO1xuICAgIHZhciBzcGFjZXNOdW1iZXIgPSByZW5kZXJUZXh0LnNwbGl0KCcgJykubGVuZ3RoIC0gMTtcbiAgICB2YXIgZHggPSB0aGlzLnBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R4Jykuc3BsaXQoKS5tYXAoXyA9PiBfLmdldFBpeGVscygneCcpKTtcbiAgICB2YXIgZHkgPSB0aGlzLnBhcmVudC5nZXRBdHRyaWJ1dGUoJ2R5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIGFuY2hvciA9IHRoaXMucGFyZW50LmdldFN0eWxlKCd0ZXh0LWFuY2hvcicpLmdldFN0cmluZygnc3RhcnQnKTtcbiAgICB2YXIgdGhpc1NwYWNpbmcgPSB0aGlzLmdldFN0eWxlKCdsZXR0ZXItc3BhY2luZycpO1xuICAgIHZhciBwYXJlbnRTcGFjaW5nID0gdGhpcy5wYXJlbnQuZ2V0U3R5bGUoJ2xldHRlci1zcGFjaW5nJyk7XG4gICAgdmFyIGxldHRlclNwYWNpbmcgPSAwO1xuXG4gICAgaWYgKCF0aGlzU3BhY2luZy5oYXNWYWx1ZSgpIHx8IHRoaXNTcGFjaW5nLmdldFZhbHVlKCkgPT09ICdpbmhlcml0Jykge1xuICAgICAgbGV0dGVyU3BhY2luZyA9IHBhcmVudFNwYWNpbmcuZ2V0UGl4ZWxzKCk7XG4gICAgfSBlbHNlIGlmICh0aGlzU3BhY2luZy5oYXNWYWx1ZSgpKSB7XG4gICAgICBpZiAodGhpc1NwYWNpbmcuZ2V0VmFsdWUoKSAhPT0gJ2luaXRpYWwnICYmIHRoaXNTcGFjaW5nLmdldFZhbHVlKCkgIT09ICd1bnNldCcpIHtcbiAgICAgICAgbGV0dGVyU3BhY2luZyA9IHRoaXNTcGFjaW5nLmdldFBpeGVscygpO1xuICAgICAgfVxuICAgIH0gLy8gZmlsbCBsZXR0ZXItc3BhY2luZyBjYWNoZVxuXG5cbiAgICB2YXIgbGV0dGVyU3BhY2luZ0NhY2hlID0gW107XG4gICAgdmFyIHRleHRMZW4gPSByZW5kZXJUZXh0Lmxlbmd0aDtcbiAgICB0aGlzLmxldHRlclNwYWNpbmdDYWNoZSA9IGxldHRlclNwYWNpbmdDYWNoZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dExlbjsgaSsrKSB7XG4gICAgICBsZXR0ZXJTcGFjaW5nQ2FjaGUucHVzaCh0eXBlb2YgZHhbaV0gIT09ICd1bmRlZmluZWQnID8gZHhbaV0gOiBsZXR0ZXJTcGFjaW5nKTtcbiAgICB9XG5cbiAgICB2YXIgZHhTdW0gPSBsZXR0ZXJTcGFjaW5nQ2FjaGUucmVkdWNlKChhY2MsIGN1ciwgaSkgPT4gaSA9PT0gMCA/IDAgOiBhY2MgKyBjdXIgfHwgMCwgMCk7XG4gICAgdmFyIHRleHRXaWR0aCA9IHRoaXMubWVhc3VyZVRleHQoY3R4KTtcbiAgICB2YXIgdGV4dEZ1bGxXaWR0aCA9IE1hdGgubWF4KHRleHRXaWR0aCArIGR4U3VtLCAwKTtcbiAgICB0aGlzLnRleHRXaWR0aCA9IHRleHRXaWR0aDtcbiAgICB0aGlzLnRleHRIZWlnaHQgPSB0aGlzLmdldEZvbnRTaXplKCk7XG4gICAgdGhpcy5nbHlwaEluZm8gPSBbXTtcbiAgICB2YXIgZnVsbFBhdGhXaWR0aCA9IHRoaXMuZ2V0UGF0aExlbmd0aCgpO1xuICAgIHZhciBzdGFydE9mZnNldCA9IHRoaXMuZ2V0U3R5bGUoJ3N0YXJ0T2Zmc2V0JykuZ2V0TnVtYmVyKDApICogZnVsbFBhdGhXaWR0aDtcbiAgICB2YXIgb2Zmc2V0ID0gMDtcblxuICAgIGlmIChhbmNob3IgPT09ICdtaWRkbGUnIHx8IGFuY2hvciA9PT0gJ2NlbnRlcicpIHtcbiAgICAgIG9mZnNldCA9IC10ZXh0RnVsbFdpZHRoIC8gMjtcbiAgICB9XG5cbiAgICBpZiAoYW5jaG9yID09PSAnZW5kJyB8fCBhbmNob3IgPT09ICdyaWdodCcpIHtcbiAgICAgIG9mZnNldCA9IC10ZXh0RnVsbFdpZHRoO1xuICAgIH1cblxuICAgIG9mZnNldCArPSBzdGFydE9mZnNldDtcbiAgICBjaGFycy5mb3JFYWNoKChjaGFyLCBpKSA9PiB7XG4gICAgICAvLyBGaW5kIHN1Y2ggc2VnbWVudCB3aGF0IGRpc3RhbmNlIGJldHdlZW4gcDAgYW5kIHAxIGlzIGFwcHJveC4gd2lkdGggb2YgZ2x5cGhcbiAgICAgIHZhciB7XG4gICAgICAgIG9mZnNldDogbmV4dE9mZnNldCxcbiAgICAgICAgc2VnbWVudCxcbiAgICAgICAgcm90YXRpb25cbiAgICAgIH0gPSB0aGlzLmZpbmRTZWdtZW50VG9GaXRDaGFyKGN0eCwgYW5jaG9yLCB0ZXh0RnVsbFdpZHRoLCBmdWxsUGF0aFdpZHRoLCBzcGFjZXNOdW1iZXIsIG9mZnNldCwgZHksIGNoYXIsIGkpO1xuICAgICAgb2Zmc2V0ID0gbmV4dE9mZnNldDtcblxuICAgICAgaWYgKCFzZWdtZW50LnAwIHx8ICFzZWdtZW50LnAxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gY29uc3Qgd2lkdGggPSB0aGlzLmdldExpbmVMZW5ndGgoXG4gICAgICAvLyBcdHNlZ21lbnQucDAueCxcbiAgICAgIC8vIFx0c2VnbWVudC5wMC55LFxuICAgICAgLy8gXHRzZWdtZW50LnAxLngsXG4gICAgICAvLyBcdHNlZ21lbnQucDEueVxuICAgICAgLy8gKTtcbiAgICAgIC8vIE5vdGU6IFNpbmNlIGdseXBocyBhcmUgcmVuZGVyZWQgb25lIGF0IGEgdGltZSwgYW55IGtlcm5pbmcgcGFpciBkYXRhIGJ1aWx0IGludG8gdGhlIGZvbnQgd2lsbCBub3QgYmUgdXNlZC5cbiAgICAgIC8vIENhbiBmb3Jlc2VlIGhhdmluZyBhIHJvdWdoIHBhaXIgdGFibGUgYnVpbHQgaW4gdGhhdCB0aGUgZGV2ZWxvcGVyIGNhbiBvdmVycmlkZSBhcyBuZWVkZWQuXG4gICAgICAvLyBPciB1c2UgXCJkeFwiIGF0dHJpYnV0ZSBvZiB0aGUgPHRleHQ+IG5vZGUgYXMgYSBuYWl2ZSByZXBsYWNlbWVudFxuICAgICAgLy8gY29uc3Qga2VybiA9IDA7XG4gICAgICAvLyBwbGFjZWhvbGRlciBmb3IgZnV0dXJlIGltcGxlbWVudGF0aW9uXG4gICAgICAvLyBjb25zdCBtaWRwb2ludCA9IHRoaXMuZ2V0UG9pbnRPbkxpbmUoXG4gICAgICAvLyBcdGtlcm4gKyB3aWR0aCAvIDIuMCxcbiAgICAgIC8vIFx0c2VnbWVudC5wMC54LCBzZWdtZW50LnAwLnksIHNlZ21lbnQucDEueCwgc2VnbWVudC5wMS55XG4gICAgICAvLyApO1xuXG5cbiAgICAgIHRoaXMuZ2x5cGhJbmZvLnB1c2goe1xuICAgICAgICAvLyB0cmFuc3Bvc2VYOiBtaWRwb2ludC54LFxuICAgICAgICAvLyB0cmFuc3Bvc2VZOiBtaWRwb2ludC55LFxuICAgICAgICB0ZXh0OiBjaGFyc1tpXSxcbiAgICAgICAgcDA6IHNlZ21lbnQucDAsXG4gICAgICAgIHAxOiBzZWdtZW50LnAxLFxuICAgICAgICByb3RhdGlvblxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBwYXJzZVBhdGhEYXRhKHBhdGgpIHtcbiAgICB0aGlzLnBhdGhMZW5ndGggPSAtMTsgLy8gcmVzZXQgcGF0aCBsZW5ndGhcblxuICAgIGlmICghcGF0aCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIHZhciBwYXRoQ29tbWFuZHMgPSBbXTtcbiAgICB2YXIge1xuICAgICAgcGF0aFBhcnNlclxuICAgIH0gPSBwYXRoO1xuICAgIHBhdGhQYXJzZXIucmVzZXQoKTsgLy8gY29udmVydCBsLCBILCBoLCBWLCBhbmQgdiB0byBMXG5cbiAgICB3aGlsZSAoIXBhdGhQYXJzZXIuaXNFbmQoKSkge1xuICAgICAgdmFyIHtcbiAgICAgICAgY3VycmVudFxuICAgICAgfSA9IHBhdGhQYXJzZXI7XG4gICAgICB2YXIgc3RhcnRYID0gY3VycmVudCA/IGN1cnJlbnQueCA6IDA7XG4gICAgICB2YXIgc3RhcnRZID0gY3VycmVudCA/IGN1cnJlbnQueSA6IDA7XG4gICAgICB2YXIgY29tbWFuZCA9IHBhdGhQYXJzZXIubmV4dCgpO1xuICAgICAgdmFyIG5leHRDb21tYW5kVHlwZSA9IGNvbW1hbmQudHlwZTtcbiAgICAgIHZhciBwb2ludHMgPSBbXTtcblxuICAgICAgc3dpdGNoIChjb21tYW5kLnR5cGUpIHtcbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLk1PVkVfVE86XG4gICAgICAgICAgdGhpcy5wYXRoTShwYXRoUGFyc2VyLCBwb2ludHMpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5MSU5FX1RPOlxuICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aEwocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuSE9SSVpfTElORV9UTzpcbiAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhIKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlZFUlRfTElORV9UTzpcbiAgICAgICAgICBuZXh0Q29tbWFuZFR5cGUgPSB0aGlzLnBhdGhWKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgIHRoaXMucGF0aEMocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuU01PT1RIX0NVUlZFX1RPOlxuICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aFMocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuUVVBRF9UTzpcbiAgICAgICAgICB0aGlzLnBhdGhRKHBhdGhQYXJzZXIsIHBvaW50cyk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlNNT09USF9RVUFEX1RPOlxuICAgICAgICAgIG5leHRDb21tYW5kVHlwZSA9IHRoaXMucGF0aFQocGF0aFBhcnNlciwgcG9pbnRzKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuQVJDOlxuICAgICAgICAgIHBvaW50cyA9IHRoaXMucGF0aEEocGF0aFBhcnNlcik7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNMT1NFX1BBVEg6XG4gICAgICAgICAgUGF0aEVsZW1lbnQucGF0aFoocGF0aFBhcnNlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21tYW5kLnR5cGUgIT09IFBhdGhQYXJzZXIuQ0xPU0VfUEFUSCkge1xuICAgICAgICBwYXRoQ29tbWFuZHMucHVzaCh7XG4gICAgICAgICAgdHlwZTogbmV4dENvbW1hbmRUeXBlLFxuICAgICAgICAgIHBvaW50cyxcbiAgICAgICAgICBzdGFydDoge1xuICAgICAgICAgICAgeDogc3RhcnRYLFxuICAgICAgICAgICAgeTogc3RhcnRZXG4gICAgICAgICAgfSxcbiAgICAgICAgICBwYXRoTGVuZ3RoOiB0aGlzLmNhbGNMZW5ndGgoc3RhcnRYLCBzdGFydFksIG5leHRDb21tYW5kVHlwZSwgcG9pbnRzKVxuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhdGhDb21tYW5kcy5wdXNoKHtcbiAgICAgICAgICB0eXBlOiBQYXRoUGFyc2VyLkNMT1NFX1BBVEgsXG4gICAgICAgICAgcG9pbnRzOiBbXSxcbiAgICAgICAgICBwYXRoTGVuZ3RoOiAwXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwYXRoQ29tbWFuZHM7XG4gIH1cblxuICBwYXRoTShwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aE0ocGF0aFBhcnNlcikucG9pbnQ7XG4gICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gIH1cblxuICBwYXRoTChwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICB2YXIge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEwocGF0aFBhcnNlcikucG9pbnQ7XG4gICAgcG9pbnRzLnB1c2goeCwgeSk7XG4gICAgcmV0dXJuIFBhdGhQYXJzZXIuTElORV9UTztcbiAgfVxuXG4gIHBhdGhIKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgIHZhciB7XG4gICAgICB4LFxuICAgICAgeVxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoSChwYXRoUGFyc2VyKS5wb2ludDtcbiAgICBwb2ludHMucHVzaCh4LCB5KTtcbiAgICByZXR1cm4gUGF0aFBhcnNlci5MSU5FX1RPO1xuICB9XG5cbiAgcGF0aFYocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhWKHBhdGhQYXJzZXIpLnBvaW50O1xuICAgIHBvaW50cy5wdXNoKHgsIHkpO1xuICAgIHJldHVybiBQYXRoUGFyc2VyLkxJTkVfVE87XG4gIH1cblxuICBwYXRoQyhwYXRoUGFyc2VyLCBwb2ludHMpIHtcbiAgICB2YXIge1xuICAgICAgcG9pbnQsXG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEMocGF0aFBhcnNlcik7XG4gICAgcG9pbnRzLnB1c2gocG9pbnQueCwgcG9pbnQueSwgY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICB9XG5cbiAgcGF0aFMocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIHBvaW50LFxuICAgICAgY29udHJvbFBvaW50LFxuICAgICAgY3VycmVudFBvaW50XG4gICAgfSA9IFBhdGhFbGVtZW50LnBhdGhTKHBhdGhQYXJzZXIpO1xuICAgIHBvaW50cy5wdXNoKHBvaW50LngsIHBvaW50LnksIGNvbnRyb2xQb2ludC54LCBjb250cm9sUG9pbnQueSwgY3VycmVudFBvaW50LngsIGN1cnJlbnRQb2ludC55KTtcbiAgICByZXR1cm4gUGF0aFBhcnNlci5DVVJWRV9UTztcbiAgfVxuXG4gIHBhdGhRKHBhdGhQYXJzZXIsIHBvaW50cykge1xuICAgIHZhciB7XG4gICAgICBjb250cm9sUG9pbnQsXG4gICAgICBjdXJyZW50UG9pbnRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aFEocGF0aFBhcnNlcik7XG4gICAgcG9pbnRzLnB1c2goY29udHJvbFBvaW50LngsIGNvbnRyb2xQb2ludC55LCBjdXJyZW50UG9pbnQueCwgY3VycmVudFBvaW50LnkpO1xuICB9XG5cbiAgcGF0aFQocGF0aFBhcnNlciwgcG9pbnRzKSB7XG4gICAgdmFyIHtcbiAgICAgIGNvbnRyb2xQb2ludCxcbiAgICAgIGN1cnJlbnRQb2ludFxuICAgIH0gPSBQYXRoRWxlbWVudC5wYXRoVChwYXRoUGFyc2VyKTtcbiAgICBwb2ludHMucHVzaChjb250cm9sUG9pbnQueCwgY29udHJvbFBvaW50LnksIGN1cnJlbnRQb2ludC54LCBjdXJyZW50UG9pbnQueSk7XG4gICAgcmV0dXJuIFBhdGhQYXJzZXIuUVVBRF9UTztcbiAgfVxuXG4gIHBhdGhBKHBhdGhQYXJzZXIpIHtcbiAgICB2YXIge1xuICAgICAgclgsXG4gICAgICByWSxcbiAgICAgIHN3ZWVwRmxhZyxcbiAgICAgIHhBeGlzUm90YXRpb24sXG4gICAgICBjZW50cCxcbiAgICAgIGExLFxuICAgICAgYWRcbiAgICB9ID0gUGF0aEVsZW1lbnQucGF0aEEocGF0aFBhcnNlcik7XG5cbiAgICBpZiAoc3dlZXBGbGFnID09PSAwICYmIGFkID4gMCkge1xuICAgICAgYWQgLT0gMiAqIE1hdGguUEk7XG4gICAgfVxuXG4gICAgaWYgKHN3ZWVwRmxhZyA9PT0gMSAmJiBhZCA8IDApIHtcbiAgICAgIGFkICs9IDIgKiBNYXRoLlBJO1xuICAgIH1cblxuICAgIHJldHVybiBbY2VudHAueCwgY2VudHAueSwgclgsIHJZLCBhMSwgYWQsIHhBeGlzUm90YXRpb24sIHN3ZWVwRmxhZ107XG4gIH1cblxuICBjYWxjTGVuZ3RoKHgsIHksIGNvbW1hbmRUeXBlLCBwb2ludHMpIHtcbiAgICB2YXIgbGVuID0gMDtcbiAgICB2YXIgcDEgPSBudWxsO1xuICAgIHZhciBwMiA9IG51bGw7XG4gICAgdmFyIHQgPSAwO1xuXG4gICAgc3dpdGNoIChjb21tYW5kVHlwZSkge1xuICAgICAgY2FzZSBQYXRoUGFyc2VyLkxJTkVfVE86XG4gICAgICAgIHJldHVybiB0aGlzLmdldExpbmVMZW5ndGgoeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0pO1xuXG4gICAgICBjYXNlIFBhdGhQYXJzZXIuQ1VSVkVfVE86XG4gICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIDEwMCBsaW5lIHNlZ21lbnRzXG4gICAgICAgIGxlbiA9IDAuMDtcbiAgICAgICAgcDEgPSB0aGlzLmdldFBvaW50T25DdWJpY0JlemllcigwLCB4LCB5LCBwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHBvaW50c1s0XSwgcG9pbnRzWzVdKTtcblxuICAgICAgICBmb3IgKHQgPSAwLjAxOyB0IDw9IDE7IHQgKz0gMC4wMSkge1xuICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uQ3ViaWNCZXppZXIodCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdLCBwb2ludHNbNF0sIHBvaW50c1s1XSk7XG4gICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlbjtcblxuICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIDEwMCBsaW5lIHNlZ21lbnRzXG4gICAgICAgIGxlbiA9IDAuMDtcbiAgICAgICAgcDEgPSB0aGlzLmdldFBvaW50T25RdWFkcmF0aWNCZXppZXIoMCwgeCwgeSwgcG9pbnRzWzBdLCBwb2ludHNbMV0sIHBvaW50c1syXSwgcG9pbnRzWzNdKTtcblxuICAgICAgICBmb3IgKHQgPSAwLjAxOyB0IDw9IDE7IHQgKz0gMC4wMSkge1xuICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKHQsIHgsIHksIHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSk7XG4gICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGxlbjtcblxuICAgICAgY2FzZSBQYXRoUGFyc2VyLkFSQzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIEFwcHJveGltYXRlcyBieSBicmVha2luZyBjdXJ2ZSBpbnRvIGxpbmUgc2VnbWVudHNcbiAgICAgICAgICBsZW4gPSAwLjA7XG4gICAgICAgICAgdmFyIHN0YXJ0ID0gcG9pbnRzWzRdOyAvLyA0ID0gdGhldGFcblxuICAgICAgICAgIHZhciBkVGhldGEgPSBwb2ludHNbNV07IC8vIDUgPSBkVGhldGFcblxuICAgICAgICAgIHZhciBlbmQgPSBwb2ludHNbNF0gKyBkVGhldGE7XG4gICAgICAgICAgdmFyIGluYyA9IE1hdGguUEkgLyAxODAuMDsgLy8gMSBkZWdyZWUgcmVzb2x1dGlvblxuXG4gICAgICAgICAgaWYgKE1hdGguYWJzKHN0YXJ0IC0gZW5kKSA8IGluYykge1xuICAgICAgICAgICAgaW5jID0gTWF0aC5hYnMoc3RhcnQgLSBlbmQpO1xuICAgICAgICAgIH0gLy8gTm90ZTogZm9yIHB1cnBvc2Ugb2YgY2FsY3VsYXRpbmcgYXJjIGxlbmd0aCwgbm90IGdvaW5nIHRvIHdvcnJ5IGFib3V0IHJvdGF0aW5nIFgtYXhpcyBieSBhbmdsZSBwc2lcblxuXG4gICAgICAgICAgcDEgPSB0aGlzLmdldFBvaW50T25FbGxpcHRpY2FsQXJjKHBvaW50c1swXSwgcG9pbnRzWzFdLCBwb2ludHNbMl0sIHBvaW50c1szXSwgc3RhcnQsIDApO1xuXG4gICAgICAgICAgaWYgKGRUaGV0YSA8IDApIHtcbiAgICAgICAgICAgIC8vIGNsb2Nrd2lzZVxuICAgICAgICAgICAgZm9yICh0ID0gc3RhcnQgLSBpbmM7IHQgPiBlbmQ7IHQgLT0gaW5jKSB7XG4gICAgICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHQsIDApO1xuICAgICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBjb3VudGVyLWNsb2Nrd2lzZVxuICAgICAgICAgICAgZm9yICh0ID0gc3RhcnQgKyBpbmM7IHQgPCBlbmQ7IHQgKz0gaW5jKSB7XG4gICAgICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIHQsIDApO1xuICAgICAgICAgICAgICBsZW4gKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAxLngsIHAxLnksIHAyLngsIHAyLnkpO1xuICAgICAgICAgICAgICBwMSA9IHAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHAyID0gdGhpcy5nZXRQb2ludE9uRWxsaXB0aWNhbEFyYyhwb2ludHNbMF0sIHBvaW50c1sxXSwgcG9pbnRzWzJdLCBwb2ludHNbM10sIGVuZCwgMCk7XG4gICAgICAgICAgbGVuICs9IHRoaXMuZ2V0TGluZUxlbmd0aChwMS54LCBwMS55LCBwMi54LCBwMi55KTtcbiAgICAgICAgICByZXR1cm4gbGVuO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICBnZXRQb2ludE9uTGluZShkaXN0LCBwMXgsIHAxeSwgcDJ4LCBwMnkpIHtcbiAgICB2YXIgZnJvbVggPSBhcmd1bWVudHMubGVuZ3RoID4gNSAmJiBhcmd1bWVudHNbNV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s1XSA6IHAxeDtcbiAgICB2YXIgZnJvbVkgPSBhcmd1bWVudHMubGVuZ3RoID4gNiAmJiBhcmd1bWVudHNbNl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1s2XSA6IHAxeTtcbiAgICB2YXIgbSA9IChwMnkgLSBwMXkpIC8gKHAyeCAtIHAxeCArIFBTRVVET19aRVJPKTtcbiAgICB2YXIgcnVuID0gTWF0aC5zcXJ0KGRpc3QgKiBkaXN0IC8gKDEgKyBtICogbSkpO1xuXG4gICAgaWYgKHAyeCA8IHAxeCkge1xuICAgICAgcnVuICo9IC0xO1xuICAgIH1cblxuICAgIHZhciByaXNlID0gbSAqIHJ1bjtcbiAgICB2YXIgcHQgPSBudWxsO1xuXG4gICAgaWYgKHAyeCA9PT0gcDF4KSB7XG4gICAgICAvLyB2ZXJ0aWNhbCBsaW5lXG4gICAgICBwdCA9IHtcbiAgICAgICAgeDogZnJvbVgsXG4gICAgICAgIHk6IGZyb21ZICsgcmlzZVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKChmcm9tWSAtIHAxeSkgLyAoZnJvbVggLSBwMXggKyBQU0VVRE9fWkVSTykgPT09IG0pIHtcbiAgICAgIHB0ID0ge1xuICAgICAgICB4OiBmcm9tWCArIHJ1bixcbiAgICAgICAgeTogZnJvbVkgKyByaXNlXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgaXggPSAwO1xuICAgICAgdmFyIGl5ID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmdldExpbmVMZW5ndGgocDF4LCBwMXksIHAyeCwgcDJ5KTtcblxuICAgICAgaWYgKGxlbiA8IFBTRVVET19aRVJPKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgdSA9IChmcm9tWCAtIHAxeCkgKiAocDJ4IC0gcDF4KSArIChmcm9tWSAtIHAxeSkgKiAocDJ5IC0gcDF5KTtcbiAgICAgIHUgLz0gbGVuICogbGVuO1xuICAgICAgaXggPSBwMXggKyB1ICogKHAyeCAtIHAxeCk7XG4gICAgICBpeSA9IHAxeSArIHUgKiAocDJ5IC0gcDF5KTtcbiAgICAgIHZhciBwUmlzZSA9IHRoaXMuZ2V0TGluZUxlbmd0aChmcm9tWCwgZnJvbVksIGl4LCBpeSk7XG4gICAgICB2YXIgcFJ1biA9IE1hdGguc3FydChkaXN0ICogZGlzdCAtIHBSaXNlICogcFJpc2UpO1xuICAgICAgcnVuID0gTWF0aC5zcXJ0KHBSdW4gKiBwUnVuIC8gKDEgKyBtICogbSkpO1xuXG4gICAgICBpZiAocDJ4IDwgcDF4KSB7XG4gICAgICAgIHJ1biAqPSAtMTtcbiAgICAgIH1cblxuICAgICAgcmlzZSA9IG0gKiBydW47XG4gICAgICBwdCA9IHtcbiAgICAgICAgeDogaXggKyBydW4sXG4gICAgICAgIHk6IGl5ICsgcmlzZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gcHQ7XG4gIH1cblxuICBnZXRQb2ludE9uUGF0aChkaXN0YW5jZSkge1xuICAgIHZhciBmdWxsTGVuID0gdGhpcy5nZXRQYXRoTGVuZ3RoKCk7XG4gICAgdmFyIGN1bXVsYXRpdmVQYXRoTGVuZ3RoID0gMDtcbiAgICB2YXIgcCA9IG51bGw7XG5cbiAgICBpZiAoZGlzdGFuY2UgPCAtMC4wMDAwNSB8fCBkaXN0YW5jZSAtIDAuMDAwMDUgPiBmdWxsTGVuKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIge1xuICAgICAgZGF0YUFycmF5XG4gICAgfSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBjb21tYW5kIG9mIGRhdGFBcnJheSkge1xuICAgICAgaWYgKGNvbW1hbmQgJiYgKGNvbW1hbmQucGF0aExlbmd0aCA8IDAuMDAwMDUgfHwgY3VtdWxhdGl2ZVBhdGhMZW5ndGggKyBjb21tYW5kLnBhdGhMZW5ndGggKyAwLjAwMDA1IDwgZGlzdGFuY2UpKSB7XG4gICAgICAgIGN1bXVsYXRpdmVQYXRoTGVuZ3RoICs9IGNvbW1hbmQucGF0aExlbmd0aDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBkZWx0YSA9IGRpc3RhbmNlIC0gY3VtdWxhdGl2ZVBhdGhMZW5ndGg7XG4gICAgICB2YXIgY3VycmVudFQgPSAwO1xuXG4gICAgICBzd2l0Y2ggKGNvbW1hbmQudHlwZSkge1xuICAgICAgICBjYXNlIFBhdGhQYXJzZXIuTElORV9UTzpcbiAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludE9uTGluZShkZWx0YSwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnksIGNvbW1hbmQucG9pbnRzWzBdLCBjb21tYW5kLnBvaW50c1sxXSwgY29tbWFuZC5zdGFydC54LCBjb21tYW5kLnN0YXJ0LnkpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgUGF0aFBhcnNlci5BUkM6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHN0YXJ0ID0gY29tbWFuZC5wb2ludHNbNF07IC8vIDQgPSB0aGV0YVxuXG4gICAgICAgICAgICB2YXIgZFRoZXRhID0gY29tbWFuZC5wb2ludHNbNV07IC8vIDUgPSBkVGhldGFcblxuICAgICAgICAgICAgdmFyIGVuZCA9IGNvbW1hbmQucG9pbnRzWzRdICsgZFRoZXRhO1xuICAgICAgICAgICAgY3VycmVudFQgPSBzdGFydCArIGRlbHRhIC8gY29tbWFuZC5wYXRoTGVuZ3RoICogZFRoZXRhO1xuXG4gICAgICAgICAgICBpZiAoZFRoZXRhIDwgMCAmJiBjdXJyZW50VCA8IGVuZCB8fCBkVGhldGEgPj0gMCAmJiBjdXJyZW50VCA+IGVuZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMoY29tbWFuZC5wb2ludHNbMF0sIGNvbW1hbmQucG9pbnRzWzFdLCBjb21tYW5kLnBvaW50c1syXSwgY29tbWFuZC5wb2ludHNbM10sIGN1cnJlbnRULCBjb21tYW5kLnBvaW50c1s2XSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLkNVUlZFX1RPOlxuICAgICAgICAgIGN1cnJlbnRUID0gZGVsdGEgLyBjb21tYW5kLnBhdGhMZW5ndGg7XG5cbiAgICAgICAgICBpZiAoY3VycmVudFQgPiAxKSB7XG4gICAgICAgICAgICBjdXJyZW50VCA9IDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcCA9IHRoaXMuZ2V0UG9pbnRPbkN1YmljQmV6aWVyKGN1cnJlbnRULCBjb21tYW5kLnN0YXJ0LngsIGNvbW1hbmQuc3RhcnQueSwgY29tbWFuZC5wb2ludHNbMF0sIGNvbW1hbmQucG9pbnRzWzFdLCBjb21tYW5kLnBvaW50c1syXSwgY29tbWFuZC5wb2ludHNbM10sIGNvbW1hbmQucG9pbnRzWzRdLCBjb21tYW5kLnBvaW50c1s1XSk7XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBQYXRoUGFyc2VyLlFVQURfVE86XG4gICAgICAgICAgY3VycmVudFQgPSBkZWx0YSAvIGNvbW1hbmQucGF0aExlbmd0aDtcblxuICAgICAgICAgIGlmIChjdXJyZW50VCA+IDEpIHtcbiAgICAgICAgICAgIGN1cnJlbnRUID0gMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwID0gdGhpcy5nZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyKGN1cnJlbnRULCBjb21tYW5kLnN0YXJ0LngsIGNvbW1hbmQuc3RhcnQueSwgY29tbWFuZC5wb2ludHNbMF0sIGNvbW1hbmQucG9pbnRzWzFdLCBjb21tYW5kLnBvaW50c1syXSwgY29tbWFuZC5wb2ludHNbM10pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAocCkge1xuICAgICAgICByZXR1cm4gcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBnZXRMaW5lTGVuZ3RoKHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgcmV0dXJuIE1hdGguc3FydCgoeDIgLSB4MSkgKiAoeDIgLSB4MSkgKyAoeTIgLSB5MSkgKiAoeTIgLSB5MSkpO1xuICB9XG5cbiAgZ2V0UGF0aExlbmd0aCgpIHtcbiAgICBpZiAodGhpcy5wYXRoTGVuZ3RoID09PSAtMSkge1xuICAgICAgdGhpcy5wYXRoTGVuZ3RoID0gdGhpcy5kYXRhQXJyYXkucmVkdWNlKChsZW5ndGgsIGNvbW1hbmQpID0+IGNvbW1hbmQucGF0aExlbmd0aCA+IDAgPyBsZW5ndGggKyBjb21tYW5kLnBhdGhMZW5ndGggOiBsZW5ndGgsIDApO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnBhdGhMZW5ndGg7XG4gIH1cblxuICBnZXRQb2ludE9uQ3ViaWNCZXppZXIocGN0LCBwMXgsIHAxeSwgcDJ4LCBwMnksIHAzeCwgcDN5LCBwNHgsIHA0eSkge1xuICAgIHZhciB4ID0gcDR4ICogQ0IxKHBjdCkgKyBwM3ggKiBDQjIocGN0KSArIHAyeCAqIENCMyhwY3QpICsgcDF4ICogQ0I0KHBjdCk7XG4gICAgdmFyIHkgPSBwNHkgKiBDQjEocGN0KSArIHAzeSAqIENCMihwY3QpICsgcDJ5ICogQ0IzKHBjdCkgKyBwMXkgKiBDQjQocGN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG5cbiAgZ2V0UG9pbnRPblF1YWRyYXRpY0JlemllcihwY3QsIHAxeCwgcDF5LCBwMngsIHAyeSwgcDN4LCBwM3kpIHtcbiAgICB2YXIgeCA9IHAzeCAqIFFCMShwY3QpICsgcDJ4ICogUUIyKHBjdCkgKyBwMXggKiBRQjMocGN0KTtcbiAgICB2YXIgeSA9IHAzeSAqIFFCMShwY3QpICsgcDJ5ICogUUIyKHBjdCkgKyBwMXkgKiBRQjMocGN0KTtcbiAgICByZXR1cm4ge1xuICAgICAgeCxcbiAgICAgIHlcbiAgICB9O1xuICB9XG5cbiAgZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMoY3gsIGN5LCByeCwgcnksIHRoZXRhLCBwc2kpIHtcbiAgICB2YXIgY29zUHNpID0gTWF0aC5jb3MocHNpKTtcbiAgICB2YXIgc2luUHNpID0gTWF0aC5zaW4ocHNpKTtcbiAgICB2YXIgcHQgPSB7XG4gICAgICB4OiByeCAqIE1hdGguY29zKHRoZXRhKSxcbiAgICAgIHk6IHJ5ICogTWF0aC5zaW4odGhldGEpXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgeDogY3ggKyAocHQueCAqIGNvc1BzaSAtIHB0LnkgKiBzaW5Qc2kpLFxuICAgICAgeTogY3kgKyAocHQueCAqIHNpblBzaSArIHB0LnkgKiBjb3NQc2kpXG4gICAgfTtcbiAgfSAvLyBUT0RPIG5lZWQgc29tZSBvcHRpbWlzYXRpb25zLiBwb3NzaWJseSBidWlsZCBjYWNoZSBvbmx5IGZvciBjdXJ2ZWQgc2VnbWVudHM/XG5cblxuICBidWlsZEVxdWlkaXN0YW50Q2FjaGUoaW5wdXRTdGVwLCBpbnB1dFByZWNpc2lvbikge1xuICAgIHZhciBmdWxsTGVuID0gdGhpcy5nZXRQYXRoTGVuZ3RoKCk7XG4gICAgdmFyIHByZWNpc2lvbiA9IGlucHV0UHJlY2lzaW9uIHx8IDAuMjU7IC8vIGFjY3VyYWN5IHZzIHBlcmZvcm1hbmNlXG5cbiAgICB2YXIgc3RlcCA9IGlucHV0U3RlcCB8fCBmdWxsTGVuIC8gMTAwO1xuXG4gICAgaWYgKCF0aGlzLmVxdWlkaXN0YW50Q2FjaGUgfHwgdGhpcy5lcXVpZGlzdGFudENhY2hlLnN0ZXAgIT09IHN0ZXAgfHwgdGhpcy5lcXVpZGlzdGFudENhY2hlLnByZWNpc2lvbiAhPT0gcHJlY2lzaW9uKSB7XG4gICAgICAvLyBQcmVwYXJlIGNhY2hlXG4gICAgICB0aGlzLmVxdWlkaXN0YW50Q2FjaGUgPSB7XG4gICAgICAgIHN0ZXAsXG4gICAgICAgIHByZWNpc2lvbixcbiAgICAgICAgcG9pbnRzOiBbXVxuICAgICAgfTsgLy8gQ2FsY3VsYXRlIHBvaW50c1xuXG4gICAgICB2YXIgcyA9IDA7XG5cbiAgICAgIGZvciAodmFyIGwgPSAwOyBsIDw9IGZ1bGxMZW47IGwgKz0gcHJlY2lzaW9uKSB7XG4gICAgICAgIHZhciBwMCA9IHRoaXMuZ2V0UG9pbnRPblBhdGgobCk7XG4gICAgICAgIHZhciBwMSA9IHRoaXMuZ2V0UG9pbnRPblBhdGgobCArIHByZWNpc2lvbik7XG5cbiAgICAgICAgaWYgKCFwMCB8fCAhcDEpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHMgKz0gdGhpcy5nZXRMaW5lTGVuZ3RoKHAwLngsIHAwLnksIHAxLngsIHAxLnkpO1xuXG4gICAgICAgIGlmIChzID49IHN0ZXApIHtcbiAgICAgICAgICB0aGlzLmVxdWlkaXN0YW50Q2FjaGUucG9pbnRzLnB1c2goe1xuICAgICAgICAgICAgeDogcDAueCxcbiAgICAgICAgICAgIHk6IHAwLnksXG4gICAgICAgICAgICBkaXN0YW5jZTogbFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHMgLT0gc3RlcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgodGFyZ2V0RGlzdGFuY2UsIHN0ZXAsIHByZWNpc2lvbikge1xuICAgIHRoaXMuYnVpbGRFcXVpZGlzdGFudENhY2hlKHN0ZXAsIHByZWNpc2lvbik7XG5cbiAgICBpZiAodGFyZ2V0RGlzdGFuY2UgPCAwIHx8IHRhcmdldERpc3RhbmNlIC0gdGhpcy5nZXRQYXRoTGVuZ3RoKCkgPiAwLjAwMDA1KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgaWR4ID0gTWF0aC5yb3VuZCh0YXJnZXREaXN0YW5jZSAvIHRoaXMuZ2V0UGF0aExlbmd0aCgpICogKHRoaXMuZXF1aWRpc3RhbnRDYWNoZS5wb2ludHMubGVuZ3RoIC0gMSkpO1xuICAgIHJldHVybiB0aGlzLmVxdWlkaXN0YW50Q2FjaGUucG9pbnRzW2lkeF0gfHwgbnVsbDtcbiAgfVxuXG59XG5cbnZhciBkYXRhVXJpUmVnZXggPSAvXlxccypkYXRhOigoW14vLDtdK1xcL1teLyw7XSspKD86OyhbXiw7PV0rPVteLDs9XSspKT8pPyg/OjsoYmFzZTY0KSk/LCguKikkL2k7XG5jbGFzcyBJbWFnZUVsZW1lbnQgZXh0ZW5kcyBSZW5kZXJlZEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnaW1hZ2UnO1xuICAgIHRoaXMubG9hZGVkID0gZmFsc2U7XG4gICAgdmFyIGhyZWYgPSB0aGlzLmdldEhyZWZBdHRyaWJ1dGUoKS5nZXRTdHJpbmcoKTtcblxuICAgIGlmICghaHJlZikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBpc1N2ZyA9IGhyZWYuZW5kc1dpdGgoJy5zdmcnKSB8fCAvXlxccypkYXRhOmltYWdlXFwvc3ZnXFwreG1sL2kudGVzdChocmVmKTtcbiAgICBkb2N1bWVudC5pbWFnZXMucHVzaCh0aGlzKTtcblxuICAgIGlmICghaXNTdmcpIHtcbiAgICAgIHZvaWQgdGhpcy5sb2FkSW1hZ2UoaHJlZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZvaWQgdGhpcy5sb2FkU3ZnKGhyZWYpO1xuICAgIH1cblxuICAgIHRoaXMuaXNTdmcgPSBpc1N2ZztcbiAgfVxuXG4gIGxvYWRJbWFnZShocmVmKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIGltYWdlID0geWllbGQgX3RoaXMuZG9jdW1lbnQuY3JlYXRlSW1hZ2UoaHJlZik7XG4gICAgICAgIF90aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIHdoaWxlIGxvYWRpbmcgaW1hZ2UgXFxcIlwiLmNvbmNhdChocmVmLCBcIlxcXCI6XCIpLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgIH0pKCk7XG4gIH1cblxuICBsb2FkU3ZnKGhyZWYpIHtcbiAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIG1hdGNoID0gZGF0YVVyaVJlZ2V4LmV4ZWMoaHJlZik7XG5cbiAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICB2YXIgZGF0YSA9IG1hdGNoWzVdO1xuXG4gICAgICAgIGlmIChtYXRjaFs0XSA9PT0gJ2Jhc2U2NCcpIHtcbiAgICAgICAgICBfdGhpczIuaW1hZ2UgPSBhdG9iKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF90aGlzMi5pbWFnZSA9IGRlY29kZVVSSUNvbXBvbmVudChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB5aWVsZCBfdGhpczIuZG9jdW1lbnQuZmV0Y2goaHJlZik7XG4gICAgICAgICAgdmFyIHN2ZyA9IHlpZWxkIHJlc3BvbnNlLnRleHQoKTtcbiAgICAgICAgICBfdGhpczIuaW1hZ2UgPSBzdmc7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aGlsZSBsb2FkaW5nIGltYWdlIFxcXCJcIi5jb25jYXQoaHJlZiwgXCJcXFwiOlwiKSwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBfdGhpczIubG9hZGVkID0gdHJ1ZTtcbiAgICB9KSgpO1xuICB9XG5cbiAgcmVuZGVyQ2hpbGRyZW4oY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgaW1hZ2UsXG4gICAgICBsb2FkZWRcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgeCA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4JykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIHkgPSB0aGlzLmdldEF0dHJpYnV0ZSgneScpLmdldFBpeGVscygneScpO1xuICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJykuZ2V0UGl4ZWxzKCd4Jyk7XG4gICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0U3R5bGUoJ2hlaWdodCcpLmdldFBpeGVscygneScpO1xuXG4gICAgaWYgKCFsb2FkZWQgfHwgIWltYWdlIHx8ICF3aWR0aCB8fCAhaGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHgudHJhbnNsYXRlKHgsIHkpO1xuXG4gICAgaWYgKHRoaXMuaXNTdmcpIHtcbiAgICAgIHZhciBzdWJEb2N1bWVudCA9IGRvY3VtZW50LmNhbnZnLmZvcmtTdHJpbmcoY3R4LCB0aGlzLmltYWdlLCB7XG4gICAgICAgIGlnbm9yZU1vdXNlOiB0cnVlLFxuICAgICAgICBpZ25vcmVBbmltYXRpb246IHRydWUsXG4gICAgICAgIGlnbm9yZURpbWVuc2lvbnM6IHRydWUsXG4gICAgICAgIGlnbm9yZUNsZWFyOiB0cnVlLFxuICAgICAgICBvZmZzZXRYOiAwLFxuICAgICAgICBvZmZzZXRZOiAwLFxuICAgICAgICBzY2FsZVdpZHRoOiB3aWR0aCxcbiAgICAgICAgc2NhbGVIZWlnaHQ6IGhlaWdodFxuICAgICAgfSk7XG4gICAgICBzdWJEb2N1bWVudC5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQucGFyZW50ID0gdGhpcztcbiAgICAgIHZvaWQgc3ViRG9jdW1lbnQucmVuZGVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfaW1hZ2UgPSB0aGlzLmltYWdlO1xuICAgICAgZG9jdW1lbnQuc2V0Vmlld0JveCh7XG4gICAgICAgIGN0eCxcbiAgICAgICAgYXNwZWN0UmF0aW86IHRoaXMuZ2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJykuZ2V0U3RyaW5nKCksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBkZXNpcmVkV2lkdGg6IF9pbWFnZS53aWR0aCxcbiAgICAgICAgaGVpZ2h0LFxuICAgICAgICBkZXNpcmVkSGVpZ2h0OiBfaW1hZ2UuaGVpZ2h0XG4gICAgICB9KTtcblxuICAgICAgaWYgKHRoaXMubG9hZGVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgX2ltYWdlLmNvbXBsZXRlID09PSAndW5kZWZpbmVkJyB8fCBfaW1hZ2UuY29tcGxldGUpIHtcbiAgICAgICAgICBjdHguZHJhd0ltYWdlKF9pbWFnZSwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgZ2V0Qm91bmRpbmdCb3goKSB7XG4gICAgdmFyIHggPSB0aGlzLmdldEF0dHJpYnV0ZSgneCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciB5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKS5nZXRQaXhlbHMoJ3knKTtcbiAgICB2YXIgd2lkdGggPSB0aGlzLmdldFN0eWxlKCd3aWR0aCcpLmdldFBpeGVscygneCcpO1xuICAgIHZhciBoZWlnaHQgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnKS5nZXRQaXhlbHMoJ3knKTtcbiAgICByZXR1cm4gbmV3IEJvdW5kaW5nQm94KHgsIHksIHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gIH1cblxufVxuXG5jbGFzcyBTeW1ib2xFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAnc3ltYm9sJztcbiAgfVxuXG4gIHJlbmRlcihfKSB7Ly8gTk8gUkVOREVSXG4gIH1cblxufVxuXG5jbGFzcyBTVkdGb250TG9hZGVyIHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQpIHtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICBkb2N1bWVudC5mb250cy5wdXNoKHRoaXMpO1xuICB9XG5cbiAgbG9hZChmb250RmFtaWx5LCB1cmwpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgcmV0dXJuIF9hc3luY1RvR2VuZXJhdG9yKGZ1bmN0aW9uKiAoKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGRvY3VtZW50XG4gICAgICAgIH0gPSBfdGhpcztcbiAgICAgICAgdmFyIHN2Z0RvY3VtZW50ID0geWllbGQgZG9jdW1lbnQuY2FudmcucGFyc2VyLmxvYWQodXJsKTtcbiAgICAgICAgdmFyIGZvbnRzID0gc3ZnRG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ZvbnQnKTtcbiAgICAgICAgQXJyYXkuZnJvbShmb250cykuZm9yRWFjaChmb250Tm9kZSA9PiB7XG4gICAgICAgICAgdmFyIGZvbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGZvbnROb2RlKTtcbiAgICAgICAgICBkb2N1bWVudC5kZWZpbml0aW9uc1tmb250RmFtaWx5XSA9IGZvbnQ7XG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciB3aGlsZSBsb2FkaW5nIGZvbnQgXFxcIlwiLmNvbmNhdCh1cmwsIFwiXFxcIjpcIiksIGVycik7XG4gICAgICB9XG5cbiAgICAgIF90aGlzLmxvYWRlZCA9IHRydWU7XG4gICAgfSkoKTtcbiAgfVxuXG59XG5cbmNsYXNzIFN0eWxlRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnc3R5bGUnO1xuICAgIHZhciBjc3MgPSBjb21wcmVzc1NwYWNlcyhBcnJheS5mcm9tKG5vZGUuY2hpbGROb2RlcykgLy8gTkVFRCBURVNUXG4gICAgLm1hcChfID0+IF8udGV4dENvbnRlbnQpLmpvaW4oJycpLnJlcGxhY2UoLyhcXC9cXCooW14qXXxbXFxyXFxuXXwoXFwqKyhbXiovXXxbXFxyXFxuXSkpKSpcXCorXFwvKXwoXltcXHNdKlxcL1xcLy4qKS9nbSwgJycpIC8vIHJlbW92ZSBjb21tZW50c1xuICAgIC5yZXBsYWNlKC9AaW1wb3J0Lio7L2csICcnKSAvLyByZW1vdmUgaW1wb3J0c1xuICAgICk7XG4gICAgdmFyIGNzc0RlZnMgPSBjc3Muc3BsaXQoJ30nKTtcbiAgICBjc3NEZWZzLmZvckVhY2goXyA9PiB7XG4gICAgICB2YXIgZGVmID0gXy50cmltKCk7XG5cbiAgICAgIGlmICghZGVmKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGNzc1BhcnRzID0gZGVmLnNwbGl0KCd7Jyk7XG4gICAgICB2YXIgY3NzQ2xhc3NlcyA9IGNzc1BhcnRzWzBdLnNwbGl0KCcsJyk7XG4gICAgICB2YXIgY3NzUHJvcHMgPSBjc3NQYXJ0c1sxXS5zcGxpdCgnOycpO1xuICAgICAgY3NzQ2xhc3Nlcy5mb3JFYWNoKF8gPT4ge1xuICAgICAgICB2YXIgY3NzQ2xhc3MgPSBfLnRyaW0oKTtcblxuICAgICAgICBpZiAoIWNzc0NsYXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHByb3BzID0gZG9jdW1lbnQuc3R5bGVzW2Nzc0NsYXNzXSB8fCB7fTtcbiAgICAgICAgY3NzUHJvcHMuZm9yRWFjaChjc3NQcm9wID0+IHtcbiAgICAgICAgICB2YXIgcHJvcCA9IGNzc1Byb3AuaW5kZXhPZignOicpO1xuICAgICAgICAgIHZhciBuYW1lID0gY3NzUHJvcC5zdWJzdHIoMCwgcHJvcCkudHJpbSgpO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IGNzc1Byb3Auc3Vic3RyKHByb3AgKyAxLCBjc3NQcm9wLmxlbmd0aCAtIHByb3ApLnRyaW0oKTtcblxuICAgICAgICAgIGlmIChuYW1lICYmIHZhbHVlKSB7XG4gICAgICAgICAgICBwcm9wc1tuYW1lXSA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRvY3VtZW50LnN0eWxlc1tjc3NDbGFzc10gPSBwcm9wcztcbiAgICAgICAgZG9jdW1lbnQuc3R5bGVzU3BlY2lmaWNpdHlbY3NzQ2xhc3NdID0gZ2V0U2VsZWN0b3JTcGVjaWZpY2l0eShjc3NDbGFzcyk7XG5cbiAgICAgICAgaWYgKGNzc0NsYXNzID09PSAnQGZvbnQtZmFjZScpIHtcbiAgICAgICAgICAvLyAgJiYgIW5vZGVFbnZcbiAgICAgICAgICB2YXIgZm9udEZhbWlseSA9IHByb3BzWydmb250LWZhbWlseSddLmdldFN0cmluZygpLnJlcGxhY2UoL1wifCcvZywgJycpO1xuICAgICAgICAgIHZhciBzcmNzID0gcHJvcHMuc3JjLmdldFN0cmluZygpLnNwbGl0KCcsJyk7XG4gICAgICAgICAgc3Jjcy5mb3JFYWNoKHNyYyA9PiB7XG4gICAgICAgICAgICBpZiAoc3JjLmluZGV4T2YoJ2Zvcm1hdChcInN2Z1wiKScpID4gMCkge1xuICAgICAgICAgICAgICB2YXIgdXJsID0gcGFyc2VFeHRlcm5hbFVybChzcmMpO1xuXG4gICAgICAgICAgICAgIGlmICh1cmwpIHtcbiAgICAgICAgICAgICAgICB2b2lkIG5ldyBTVkdGb250TG9hZGVyKGRvY3VtZW50KS5sb2FkKGZvbnRGYW1pbHksIHVybCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxufVxuU3R5bGVFbGVtZW50LnBhcnNlRXh0ZXJuYWxVcmwgPSBwYXJzZUV4dGVybmFsVXJsO1xuXG5jbGFzcyBVc2VFbGVtZW50IGV4dGVuZHMgUmVuZGVyZWRFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLnR5cGUgPSAndXNlJztcbiAgfVxuXG4gIHNldENvbnRleHQoY3R4KSB7XG4gICAgc3VwZXIuc2V0Q29udGV4dChjdHgpO1xuICAgIHZhciB4QXR0ciA9IHRoaXMuZ2V0QXR0cmlidXRlKCd4Jyk7XG4gICAgdmFyIHlBdHRyID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3knKTtcblxuICAgIGlmICh4QXR0ci5oYXNWYWx1ZSgpKSB7XG4gICAgICBjdHgudHJhbnNsYXRlKHhBdHRyLmdldFBpeGVscygneCcpLCAwKTtcbiAgICB9XG5cbiAgICBpZiAoeUF0dHIuaGFzVmFsdWUoKSkge1xuICAgICAgY3R4LnRyYW5zbGF0ZSgwLCB5QXR0ci5nZXRQaXhlbHMoJ3knKSk7XG4gICAgfVxuICB9XG5cbiAgcGF0aChjdHgpIHtcbiAgICB2YXIge1xuICAgICAgZWxlbWVudFxuICAgIH0gPSB0aGlzO1xuXG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIGVsZW1lbnQucGF0aChjdHgpO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlckNoaWxkcmVuKGN0eCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudCxcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgdGVtcFN2ZyA9IGVsZW1lbnQ7XG5cbiAgICAgIGlmIChlbGVtZW50LnR5cGUgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIC8vIHJlbmRlciBtZSB1c2luZyBhIHRlbXBvcmFyeSBzdmcgZWxlbWVudCBpbiBzeW1ib2wgY2FzZXMgKGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9zdHJ1Y3QuaHRtbCNVc2VFbGVtZW50KVxuICAgICAgICB0ZW1wU3ZnID0gbmV3IFNWR0VsZW1lbnQoZG9jdW1lbnQsIG51bGwpO1xuICAgICAgICB0ZW1wU3ZnLmF0dHJpYnV0ZXMudmlld0JveCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ3ZpZXdCb3gnLCBlbGVtZW50LmdldEF0dHJpYnV0ZSgndmlld0JveCcpLmdldFN0cmluZygpKTtcbiAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLnByZXNlcnZlQXNwZWN0UmF0aW8gPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3ByZXNlcnZlQXNwZWN0UmF0aW8nKS5nZXRTdHJpbmcoKSk7XG4gICAgICAgIHRlbXBTdmcuYXR0cmlidXRlcy5vdmVyZmxvdyA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ292ZXJmbG93JywgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ292ZXJmbG93JykuZ2V0U3RyaW5nKCkpO1xuICAgICAgICB0ZW1wU3ZnLmNoaWxkcmVuID0gZWxlbWVudC5jaGlsZHJlbjsgLy8gZWxlbWVudCBpcyBzdGlsbCB0aGUgcGFyZW50IG9mIHRoZSBjaGlsZHJlblxuXG4gICAgICAgIGVsZW1lbnQuc3R5bGVzLm9wYWNpdHkgPSBuZXcgUHJvcGVydHkoZG9jdW1lbnQsICdvcGFjaXR5JywgdGhpcy5jYWxjdWxhdGVPcGFjaXR5KCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGVtcFN2Zy50eXBlID09PSAnc3ZnJykge1xuICAgICAgICB2YXIgd2lkdGhTdHlsZSA9IHRoaXMuZ2V0U3R5bGUoJ3dpZHRoJywgZmFsc2UsIHRydWUpO1xuICAgICAgICB2YXIgaGVpZ2h0U3R5bGUgPSB0aGlzLmdldFN0eWxlKCdoZWlnaHQnLCBmYWxzZSwgdHJ1ZSk7IC8vIGlmIHN5bWJvbCBvciBzdmcsIGluaGVyaXQgd2lkdGgvaGVpZ2h0IGZyb20gbWVcblxuICAgICAgICBpZiAod2lkdGhTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLndpZHRoID0gbmV3IFByb3BlcnR5KGRvY3VtZW50LCAnd2lkdGgnLCB3aWR0aFN0eWxlLmdldFN0cmluZygpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoZWlnaHRTdHlsZS5oYXNWYWx1ZSgpKSB7XG4gICAgICAgICAgdGVtcFN2Zy5hdHRyaWJ1dGVzLmhlaWdodCA9IG5ldyBQcm9wZXJ0eShkb2N1bWVudCwgJ2hlaWdodCcsIGhlaWdodFN0eWxlLmdldFN0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgb2xkUGFyZW50ID0gdGVtcFN2Zy5wYXJlbnQ7XG4gICAgICB0ZW1wU3ZnLnBhcmVudCA9IHRoaXM7XG4gICAgICB0ZW1wU3ZnLnJlbmRlcihjdHgpO1xuICAgICAgdGVtcFN2Zy5wYXJlbnQgPSBvbGRQYXJlbnQ7XG4gICAgfVxuICB9XG5cbiAgZ2V0Qm91bmRpbmdCb3goY3R4KSB7XG4gICAgdmFyIHtcbiAgICAgIGVsZW1lbnRcbiAgICB9ID0gdGhpcztcblxuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICByZXR1cm4gZWxlbWVudC5nZXRCb3VuZGluZ0JveChjdHgpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZWxlbWVudFRyYW5zZm9ybSgpIHtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBlbGVtZW50XG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIFRyYW5zZm9ybS5mcm9tRWxlbWVudChkb2N1bWVudCwgZWxlbWVudCk7XG4gIH1cblxuICBnZXQgZWxlbWVudCgpIHtcbiAgICBpZiAoIXRoaXMuY2FjaGVkRWxlbWVudCkge1xuICAgICAgdGhpcy5jYWNoZWRFbGVtZW50ID0gdGhpcy5nZXRIcmVmQXR0cmlidXRlKCkuZ2V0RGVmaW5pdGlvbigpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLmNhY2hlZEVsZW1lbnQ7XG4gIH1cblxufVxuXG5mdW5jdGlvbiBpbUdldChpbWcsIHgsIHksIHdpZHRoLCBfaGVpZ2h0LCByZ2JhKSB7XG4gIHJldHVybiBpbWdbeSAqIHdpZHRoICogNCArIHggKiA0ICsgcmdiYV07XG59XG5cbmZ1bmN0aW9uIGltU2V0KGltZywgeCwgeSwgd2lkdGgsIF9oZWlnaHQsIHJnYmEsIHZhbCkge1xuICBpbWdbeSAqIHdpZHRoICogNCArIHggKiA0ICsgcmdiYV0gPSB2YWw7XG59XG5cbmZ1bmN0aW9uIG0obWF0cml4LCBpLCB2KSB7XG4gIHZhciBtaSA9IG1hdHJpeFtpXTtcbiAgcmV0dXJuIG1pICogdjtcbn1cblxuZnVuY3Rpb24gYyhhLCBtMSwgbTIsIG0zKSB7XG4gIHJldHVybiBtMSArIE1hdGguY29zKGEpICogbTIgKyBNYXRoLnNpbihhKSAqIG0zO1xufVxuXG5jbGFzcyBGZUNvbG9yTWF0cml4RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnZmVDb2xvck1hdHJpeCc7XG4gICAgdmFyIG1hdHJpeCA9IHRvTnVtYmVycyh0aGlzLmdldEF0dHJpYnV0ZSgndmFsdWVzJykuZ2V0U3RyaW5nKCkpO1xuXG4gICAgc3dpdGNoICh0aGlzLmdldEF0dHJpYnV0ZSgndHlwZScpLmdldFN0cmluZygnbWF0cml4JykpIHtcbiAgICAgIC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL1NWRy9maWx0ZXJzLmh0bWwjZmVDb2xvck1hdHJpeEVsZW1lbnRcbiAgICAgIGNhc2UgJ3NhdHVyYXRlJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBzID0gbWF0cml4WzBdO1xuICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlIGFycmF5LWVsZW1lbnQtbmV3bGluZSAqL1xuXG4gICAgICAgICAgbWF0cml4ID0gWzAuMjEzICsgMC43ODcgKiBzLCAwLjcxNSAtIDAuNzE1ICogcywgMC4wNzIgLSAwLjA3MiAqIHMsIDAsIDAsIDAuMjEzIC0gMC4yMTMgKiBzLCAwLjcxNSArIDAuMjg1ICogcywgMC4wNzIgLSAwLjA3MiAqIHMsIDAsIDAsIDAuMjEzIC0gMC4yMTMgKiBzLCAwLjcxNSAtIDAuNzE1ICogcywgMC4wNzIgKyAwLjkyOCAqIHMsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDFdO1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdodWVSb3RhdGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGEgPSBtYXRyaXhbMF0gKiBNYXRoLlBJIC8gMTgwLjA7XG4gICAgICAgICAgLyogZXNsaW50LWRpc2FibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovXG5cbiAgICAgICAgICBtYXRyaXggPSBbYyhhLCAwLjIxMywgMC43ODcsIC0wLjIxMyksIGMoYSwgMC43MTUsIC0wLjcxNSwgLTAuNzE1KSwgYyhhLCAwLjA3MiwgLTAuMDcyLCAwLjkyOCksIDAsIDAsIGMoYSwgMC4yMTMsIC0wLjIxMywgMC4xNDMpLCBjKGEsIDAuNzE1LCAwLjI4NSwgMC4xNDApLCBjKGEsIDAuMDcyLCAtMC4wNzIsIC0wLjI4MyksIDAsIDAsIGMoYSwgMC4yMTMsIC0wLjIxMywgLTAuNzg3KSwgYyhhLCAwLjcxNSwgLTAuNzE1LCAwLjcxNSksIGMoYSwgMC4wNzIsIDAuOTI4LCAwLjA3MiksIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDFdO1xuICAgICAgICAgIC8qIGVzbGludC1lbmFibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdsdW1pbmFuY2VUb0FscGhhJzpcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgYXJyYXktZWxlbWVudC1uZXdsaW5lICovXG4gICAgICAgIG1hdHJpeCA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLjIxMjUsIDAuNzE1NCwgMC4wNzIxLCAwLCAwLCAwLCAwLCAwLCAwLCAxXTtcbiAgICAgICAgLyogZXNsaW50LWVuYWJsZSBhcnJheS1lbGVtZW50LW5ld2xpbmUgKi9cblxuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB0aGlzLm1hdHJpeCA9IG1hdHJpeDtcbiAgICB0aGlzLmluY2x1ZGVPcGFjaXR5ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2luY2x1ZGVPcGFjaXR5JykuaGFzVmFsdWUoKTtcbiAgfVxuXG4gIGFwcGx5KGN0eCwgX3gsIF95LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gYXNzdW1pbmcgeD09MCAmJiB5PT0wIGZvciBub3dcbiAgICB2YXIge1xuICAgICAgaW5jbHVkZU9wYWNpdHksXG4gICAgICBtYXRyaXhcbiAgICB9ID0gdGhpcztcbiAgICB2YXIgc3JjRGF0YSA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyspIHtcbiAgICAgICAgdmFyIHIgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDApO1xuICAgICAgICB2YXIgZyA9IGltR2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMSk7XG4gICAgICAgIHZhciBiID0gaW1HZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAyKTtcbiAgICAgICAgdmFyIGEgPSBpbUdldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMpO1xuICAgICAgICB2YXIgbnIgPSBtKG1hdHJpeCwgMCwgcikgKyBtKG1hdHJpeCwgMSwgZykgKyBtKG1hdHJpeCwgMiwgYikgKyBtKG1hdHJpeCwgMywgYSkgKyBtKG1hdHJpeCwgNCwgMSk7XG4gICAgICAgIHZhciBuZyA9IG0obWF0cml4LCA1LCByKSArIG0obWF0cml4LCA2LCBnKSArIG0obWF0cml4LCA3LCBiKSArIG0obWF0cml4LCA4LCBhKSArIG0obWF0cml4LCA5LCAxKTtcbiAgICAgICAgdmFyIG5iID0gbShtYXRyaXgsIDEwLCByKSArIG0obWF0cml4LCAxMSwgZykgKyBtKG1hdHJpeCwgMTIsIGIpICsgbShtYXRyaXgsIDEzLCBhKSArIG0obWF0cml4LCAxNCwgMSk7XG4gICAgICAgIHZhciBuYSA9IG0obWF0cml4LCAxNSwgcikgKyBtKG1hdHJpeCwgMTYsIGcpICsgbShtYXRyaXgsIDE3LCBiKSArIG0obWF0cml4LCAxOCwgYSkgKyBtKG1hdHJpeCwgMTksIDEpO1xuXG4gICAgICAgIGlmIChpbmNsdWRlT3BhY2l0eSkge1xuICAgICAgICAgIG5yID0gMDtcbiAgICAgICAgICBuZyA9IDA7XG4gICAgICAgICAgbmIgPSAwO1xuICAgICAgICAgIG5hICo9IGEgLyAyNTU7XG4gICAgICAgIH1cblxuICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDAsIG5yKTtcbiAgICAgICAgaW1TZXQoc3JjRGF0YS5kYXRhLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCAxLCBuZyk7XG4gICAgICAgIGltU2V0KHNyY0RhdGEuZGF0YSwgeCwgeSwgd2lkdGgsIGhlaWdodCwgMiwgbmIpO1xuICAgICAgICBpbVNldChzcmNEYXRhLmRhdGEsIHgsIHksIHdpZHRoLCBoZWlnaHQsIDMsIG5hKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgIGN0eC5wdXRJbWFnZURhdGEoc3JjRGF0YSwgMCwgMCk7XG4gIH1cblxufVxuXG5jbGFzcyBNYXNrRWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMudHlwZSA9ICdtYXNrJztcbiAgfVxuXG4gIGFwcGx5KGN0eCwgZWxlbWVudCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSB0aGlzOyAvLyByZW5kZXIgYXMgdGVtcCBzdmdcblxuICAgIHZhciB4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ3gnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgeSA9IHRoaXMuZ2V0QXR0cmlidXRlKCd5JykuZ2V0UGl4ZWxzKCd5Jyk7XG4gICAgdmFyIHdpZHRoID0gdGhpcy5nZXRTdHlsZSgnd2lkdGgnKS5nZXRQaXhlbHMoJ3gnKTtcbiAgICB2YXIgaGVpZ2h0ID0gdGhpcy5nZXRTdHlsZSgnaGVpZ2h0JykuZ2V0UGl4ZWxzKCd5Jyk7XG5cbiAgICBpZiAoIXdpZHRoICYmICFoZWlnaHQpIHtcbiAgICAgIHZhciBib3VuZGluZ0JveCA9IG5ldyBCb3VuZGluZ0JveCgpO1xuICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgICAgYm91bmRpbmdCb3guYWRkQm91bmRpbmdCb3goY2hpbGQuZ2V0Qm91bmRpbmdCb3goY3R4KSk7XG4gICAgICB9KTtcbiAgICAgIHggPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LngxKTtcbiAgICAgIHkgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LnkxKTtcbiAgICAgIHdpZHRoID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC53aWR0aCk7XG4gICAgICBoZWlnaHQgPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LmhlaWdodCk7XG4gICAgfVxuXG4gICAgdmFyIGlnbm9yZWRTdHlsZXMgPSB0aGlzLnJlbW92ZVN0eWxlcyhlbGVtZW50LCBNYXNrRWxlbWVudC5pZ25vcmVTdHlsZXMpO1xuICAgIHZhciBtYXNrQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgdmFyIG1hc2tDdHggPSBtYXNrQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgZG9jdW1lbnQuc2NyZWVuLnNldERlZmF1bHRzKG1hc2tDdHgpO1xuICAgIHRoaXMucmVuZGVyQ2hpbGRyZW4obWFza0N0eCk7IC8vIGNvbnZlcnQgbWFzayB0byBhbHBoYSB3aXRoIGEgZmFrZSBub2RlXG4gICAgLy8gVE9ETzogcmVmYWN0b3Igb3V0IGFwcGx5IGZyb20gZmVDb2xvck1hdHJpeFxuXG4gICAgbmV3IEZlQ29sb3JNYXRyaXhFbGVtZW50KGRvY3VtZW50LCB7XG4gICAgICBub2RlVHlwZTogMSxcbiAgICAgIGNoaWxkTm9kZXM6IFtdLFxuICAgICAgYXR0cmlidXRlczogW3tcbiAgICAgICAgbm9kZU5hbWU6ICd0eXBlJyxcbiAgICAgICAgdmFsdWU6ICdsdW1pbmFuY2VUb0FscGhhJ1xuICAgICAgfSwge1xuICAgICAgICBub2RlTmFtZTogJ2luY2x1ZGVPcGFjaXR5JyxcbiAgICAgICAgdmFsdWU6ICd0cnVlJ1xuICAgICAgfV1cbiAgICB9KS5hcHBseShtYXNrQ3R4LCAwLCAwLCB4ICsgd2lkdGgsIHkgKyBoZWlnaHQpO1xuICAgIHZhciB0bXBDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVDYW52YXMoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICB2YXIgdG1wQ3R4ID0gdG1wQ2FudmFzLmdldENvbnRleHQoJzJkJyk7XG4gICAgZG9jdW1lbnQuc2NyZWVuLnNldERlZmF1bHRzKHRtcEN0eCk7XG4gICAgZWxlbWVudC5yZW5kZXIodG1wQ3R4KTtcbiAgICB0bXBDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2Rlc3RpbmF0aW9uLWluJztcbiAgICB0bXBDdHguZmlsbFN0eWxlID0gbWFza0N0eC5jcmVhdGVQYXR0ZXJuKG1hc2tDYW52YXMsICduby1yZXBlYXQnKTtcbiAgICB0bXBDdHguZmlsbFJlY3QoMCwgMCwgeCArIHdpZHRoLCB5ICsgaGVpZ2h0KTtcbiAgICBjdHguZmlsbFN0eWxlID0gdG1wQ3R4LmNyZWF0ZVBhdHRlcm4odG1wQ2FudmFzLCAnbm8tcmVwZWF0Jyk7XG4gICAgY3R4LmZpbGxSZWN0KDAsIDAsIHggKyB3aWR0aCwgeSArIGhlaWdodCk7IC8vIHJlYXNzaWduIG1hc2tcblxuICAgIHRoaXMucmVzdG9yZVN0eWxlcyhlbGVtZW50LCBpZ25vcmVkU3R5bGVzKTtcbiAgfVxuXG4gIHJlbmRlcihfKSB7Ly8gTk8gUkVOREVSXG4gIH1cblxufVxuTWFza0VsZW1lbnQuaWdub3JlU3R5bGVzID0gWydtYXNrJywgJ3RyYW5zZm9ybScsICdjbGlwLXBhdGgnXTtcblxudmFyIG5vb3AgPSAoKSA9PiB7Ly8gTk9PUFxufTtcblxuY2xhc3MgQ2xpcFBhdGhFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2NsaXBQYXRoJztcbiAgfVxuXG4gIGFwcGx5KGN0eCkge1xuICAgIHZhciB7XG4gICAgICBkb2N1bWVudFxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBjb250ZXh0UHJvdG8gPSBSZWZsZWN0LmdldFByb3RvdHlwZU9mKGN0eCk7XG4gICAgdmFyIHtcbiAgICAgIGJlZ2luUGF0aCxcbiAgICAgIGNsb3NlUGF0aFxuICAgIH0gPSBjdHg7XG5cbiAgICBpZiAoY29udGV4dFByb3RvKSB7XG4gICAgICBjb250ZXh0UHJvdG8uYmVnaW5QYXRoID0gbm9vcDtcbiAgICAgIGNvbnRleHRQcm90by5jbG9zZVBhdGggPSBub29wO1xuICAgIH1cblxuICAgIFJlZmxlY3QuYXBwbHkoYmVnaW5QYXRoLCBjdHgsIFtdKTtcbiAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZC5wYXRoID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB0cmFuc2Zvcm0gPSB0eXBlb2YgY2hpbGQuZWxlbWVudFRyYW5zZm9ybSAhPT0gJ3VuZGVmaW5lZCcgPyBjaGlsZC5lbGVtZW50VHJhbnNmb3JtKCkgOiBudWxsOyAvLyBoYW5kbGUgPHVzZSAvPlxuXG4gICAgICBpZiAoIXRyYW5zZm9ybSkge1xuICAgICAgICB0cmFuc2Zvcm0gPSBUcmFuc2Zvcm0uZnJvbUVsZW1lbnQoZG9jdW1lbnQsIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICB0cmFuc2Zvcm0uYXBwbHkoY3R4KTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQucGF0aChjdHgpO1xuXG4gICAgICBpZiAoY29udGV4dFByb3RvKSB7XG4gICAgICAgIGNvbnRleHRQcm90by5jbG9zZVBhdGggPSBjbG9zZVBhdGg7XG4gICAgICB9XG5cbiAgICAgIGlmICh0cmFuc2Zvcm0pIHtcbiAgICAgICAgdHJhbnNmb3JtLnVuYXBwbHkoY3R4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBSZWZsZWN0LmFwcGx5KGNsb3NlUGF0aCwgY3R4LCBbXSk7XG4gICAgY3R4LmNsaXAoKTtcblxuICAgIGlmIChjb250ZXh0UHJvdG8pIHtcbiAgICAgIGNvbnRleHRQcm90by5iZWdpblBhdGggPSBiZWdpblBhdGg7XG4gICAgICBjb250ZXh0UHJvdG8uY2xvc2VQYXRoID0gY2xvc2VQYXRoO1xuICAgIH1cbiAgfVxuXG4gIHJlbmRlcihfKSB7Ly8gTk8gUkVOREVSXG4gIH1cblxufVxuXG5jbGFzcyBGaWx0ZXJFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2ZpbHRlcic7XG4gIH1cblxuICBhcHBseShjdHgsIGVsZW1lbnQpIHtcbiAgICAvLyByZW5kZXIgYXMgdGVtcCBzdmdcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnQsXG4gICAgICBjaGlsZHJlblxuICAgIH0gPSB0aGlzO1xuICAgIHZhciBib3VuZGluZ0JveCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdCb3goY3R4KTtcblxuICAgIGlmICghYm91bmRpbmdCb3gpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHggPSAwO1xuICAgIHZhciBweSA9IDA7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICB2YXIgZWZkID0gY2hpbGQuZXh0cmFGaWx0ZXJEaXN0YW5jZSB8fCAwO1xuICAgICAgcHggPSBNYXRoLm1heChweCwgZWZkKTtcbiAgICAgIHB5ID0gTWF0aC5tYXgocHksIGVmZCk7XG4gICAgfSk7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC53aWR0aCk7XG4gICAgdmFyIGhlaWdodCA9IE1hdGguZmxvb3IoYm91bmRpbmdCb3guaGVpZ2h0KTtcbiAgICB2YXIgdG1wQ2FudmFzV2lkdGggPSB3aWR0aCArIDIgKiBweDtcbiAgICB2YXIgdG1wQ2FudmFzSGVpZ2h0ID0gaGVpZ2h0ICsgMiAqIHB5O1xuXG4gICAgaWYgKHRtcENhbnZhc1dpZHRoIDwgMSB8fCB0bXBDYW52YXNIZWlnaHQgPCAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHggPSBNYXRoLmZsb29yKGJvdW5kaW5nQm94LngpO1xuICAgIHZhciB5ID0gTWF0aC5mbG9vcihib3VuZGluZ0JveC55KTtcbiAgICB2YXIgaWdub3JlZFN0eWxlcyA9IHRoaXMucmVtb3ZlU3R5bGVzKGVsZW1lbnQsIEZpbHRlckVsZW1lbnQuaWdub3JlU3R5bGVzKTtcbiAgICB2YXIgdG1wQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlQ2FudmFzKHRtcENhbnZhc1dpZHRoLCB0bXBDYW52YXNIZWlnaHQpO1xuICAgIHZhciB0bXBDdHggPSB0bXBDYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICBkb2N1bWVudC5zY3JlZW4uc2V0RGVmYXVsdHModG1wQ3R4KTtcbiAgICB0bXBDdHgudHJhbnNsYXRlKC14ICsgcHgsIC15ICsgcHkpO1xuICAgIGVsZW1lbnQucmVuZGVyKHRtcEN0eCk7IC8vIGFwcGx5IGZpbHRlcnNcblxuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZC5hcHBseSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjaGlsZC5hcHBseSh0bXBDdHgsIDAsIDAsIHRtcENhbnZhc1dpZHRoLCB0bXBDYW52YXNIZWlnaHQpO1xuICAgICAgfVxuICAgIH0pOyAvLyByZW5kZXIgb24gbWVcblxuICAgIGN0eC5kcmF3SW1hZ2UodG1wQ2FudmFzLCAwLCAwLCB0bXBDYW52YXNXaWR0aCwgdG1wQ2FudmFzSGVpZ2h0LCB4IC0gcHgsIHkgLSBweSwgdG1wQ2FudmFzV2lkdGgsIHRtcENhbnZhc0hlaWdodCk7XG4gICAgdGhpcy5yZXN0b3JlU3R5bGVzKGVsZW1lbnQsIGlnbm9yZWRTdHlsZXMpO1xuICB9XG5cbiAgcmVuZGVyKF8pIHsvLyBOTyBSRU5ERVJcbiAgfVxuXG59XG5GaWx0ZXJFbGVtZW50Lmlnbm9yZVN0eWxlcyA9IFsnZmlsdGVyJywgJ3RyYW5zZm9ybScsICdjbGlwLXBhdGgnXTtcblxuY2xhc3MgRmVEcm9wU2hhZG93RWxlbWVudCBleHRlbmRzIEVsZW1lbnQge1xuICBjb25zdHJ1Y3Rvcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcykge1xuICAgIHN1cGVyKGRvY3VtZW50LCBub2RlLCBjYXB0dXJlVGV4dE5vZGVzKTtcbiAgICB0aGlzLnR5cGUgPSAnZmVEcm9wU2hhZG93JztcbiAgICB0aGlzLmFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24oKTtcbiAgfVxuXG4gIGFwcGx5KF8sIF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0KSB7Ly8gVE9ETzogaW1wbGVtZW50XG4gIH1cblxufVxuXG5jbGFzcyBGZU1vcnBob2xvZ3lFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2ZlTW9ycGhvbG9neSc7XG4gIH1cblxuICBhcHBseShfLCBfeCwgX3ksIF93aWR0aCwgX2hlaWdodCkgey8vIFRPRE86IGltcGxlbWVudFxuICB9XG5cbn1cblxuY2xhc3MgRmVDb21wb3NpdGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2ZlQ29tcG9zaXRlJztcbiAgfVxuXG4gIGFwcGx5KF8sIF94LCBfeSwgX3dpZHRoLCBfaGVpZ2h0KSB7Ly8gVE9ETzogaW1wbGVtZW50XG4gIH1cblxufVxuXG5jbGFzcyBGZUdhdXNzaWFuQmx1ckVsZW1lbnQgZXh0ZW5kcyBFbGVtZW50IHtcbiAgY29uc3RydWN0b3IoZG9jdW1lbnQsIG5vZGUsIGNhcHR1cmVUZXh0Tm9kZXMpIHtcbiAgICBzdXBlcihkb2N1bWVudCwgbm9kZSwgY2FwdHVyZVRleHROb2Rlcyk7XG4gICAgdGhpcy50eXBlID0gJ2ZlR2F1c3NpYW5CbHVyJztcbiAgICB0aGlzLmJsdXJSYWRpdXMgPSBNYXRoLmZsb29yKHRoaXMuZ2V0QXR0cmlidXRlKCdzdGREZXZpYXRpb24nKS5nZXROdW1iZXIoKSk7XG4gICAgdGhpcy5leHRyYUZpbHRlckRpc3RhbmNlID0gdGhpcy5ibHVyUmFkaXVzO1xuICB9XG5cbiAgYXBwbHkoY3R4LCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdmFyIHtcbiAgICAgIGRvY3VtZW50LFxuICAgICAgYmx1clJhZGl1c1xuICAgIH0gPSB0aGlzO1xuICAgIHZhciBib2R5ID0gZG9jdW1lbnQud2luZG93ID8gZG9jdW1lbnQud2luZG93LmRvY3VtZW50LmJvZHkgOiBudWxsO1xuICAgIHZhciBjYW52YXMgPSBjdHguY2FudmFzOyAvLyBTdGFja0JsdXIgcmVxdWlyZXMgY2FudmFzIGJlIG9uIGRvY3VtZW50XG5cbiAgICBjYW52YXMuaWQgPSBkb2N1bWVudC5nZXRVbmlxdWVJZCgpO1xuXG4gICAgaWYgKGJvZHkpIHtcbiAgICAgIGNhbnZhcy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgYm9keS5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIH1cblxuICAgIGNhbnZhc1JHQkEoY2FudmFzLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBibHVyUmFkaXVzKTtcblxuICAgIGlmIChib2R5KSB7XG4gICAgICBib2R5LnJlbW92ZUNoaWxkKGNhbnZhcyk7XG4gICAgfVxuICB9XG5cbn1cblxuY2xhc3MgVGl0bGVFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ3RpdGxlJztcbiAgfVxuXG59XG5cbmNsYXNzIERlc2NFbGVtZW50IGV4dGVuZHMgRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy50eXBlID0gJ2Rlc2MnO1xuICB9XG5cbn1cblxudmFyIGVsZW1lbnRzID0ge1xuICAnc3ZnJzogU1ZHRWxlbWVudCxcbiAgJ3JlY3QnOiBSZWN0RWxlbWVudCxcbiAgJ2NpcmNsZSc6IENpcmNsZUVsZW1lbnQsXG4gICdlbGxpcHNlJzogRWxsaXBzZUVsZW1lbnQsXG4gICdsaW5lJzogTGluZUVsZW1lbnQsXG4gICdwb2x5bGluZSc6IFBvbHlsaW5lRWxlbWVudCxcbiAgJ3BvbHlnb24nOiBQb2x5Z29uRWxlbWVudCxcbiAgJ3BhdGgnOiBQYXRoRWxlbWVudCxcbiAgJ3BhdHRlcm4nOiBQYXR0ZXJuRWxlbWVudCxcbiAgJ21hcmtlcic6IE1hcmtlckVsZW1lbnQsXG4gICdkZWZzJzogRGVmc0VsZW1lbnQsXG4gICdsaW5lYXJHcmFkaWVudCc6IExpbmVhckdyYWRpZW50RWxlbWVudCxcbiAgJ3JhZGlhbEdyYWRpZW50JzogUmFkaWFsR3JhZGllbnRFbGVtZW50LFxuICAnc3RvcCc6IFN0b3BFbGVtZW50LFxuICAnYW5pbWF0ZSc6IEFuaW1hdGVFbGVtZW50LFxuICAnYW5pbWF0ZUNvbG9yJzogQW5pbWF0ZUNvbG9yRWxlbWVudCxcbiAgJ2FuaW1hdGVUcmFuc2Zvcm0nOiBBbmltYXRlVHJhbnNmb3JtRWxlbWVudCxcbiAgJ2ZvbnQnOiBGb250RWxlbWVudCxcbiAgJ2ZvbnQtZmFjZSc6IEZvbnRGYWNlRWxlbWVudCxcbiAgJ21pc3NpbmctZ2x5cGgnOiBNaXNzaW5nR2x5cGhFbGVtZW50LFxuICAnZ2x5cGgnOiBHbHlwaEVsZW1lbnQsXG4gICd0ZXh0JzogVGV4dEVsZW1lbnQsXG4gICd0c3Bhbic6IFRTcGFuRWxlbWVudCxcbiAgJ3RyZWYnOiBUUmVmRWxlbWVudCxcbiAgJ2EnOiBBRWxlbWVudCxcbiAgJ3RleHRQYXRoJzogVGV4dFBhdGhFbGVtZW50LFxuICAnaW1hZ2UnOiBJbWFnZUVsZW1lbnQsXG4gICdnJzogR0VsZW1lbnQsXG4gICdzeW1ib2wnOiBTeW1ib2xFbGVtZW50LFxuICAnc3R5bGUnOiBTdHlsZUVsZW1lbnQsXG4gICd1c2UnOiBVc2VFbGVtZW50LFxuICAnbWFzayc6IE1hc2tFbGVtZW50LFxuICAnY2xpcFBhdGgnOiBDbGlwUGF0aEVsZW1lbnQsXG4gICdmaWx0ZXInOiBGaWx0ZXJFbGVtZW50LFxuICAnZmVEcm9wU2hhZG93JzogRmVEcm9wU2hhZG93RWxlbWVudCxcbiAgJ2ZlTW9ycGhvbG9neSc6IEZlTW9ycGhvbG9neUVsZW1lbnQsXG4gICdmZUNvbXBvc2l0ZSc6IEZlQ29tcG9zaXRlRWxlbWVudCxcbiAgJ2ZlQ29sb3JNYXRyaXgnOiBGZUNvbG9yTWF0cml4RWxlbWVudCxcbiAgJ2ZlR2F1c3NpYW5CbHVyJzogRmVHYXVzc2lhbkJsdXJFbGVtZW50LFxuICAndGl0bGUnOiBUaXRsZUVsZW1lbnQsXG4gICdkZXNjJzogRGVzY0VsZW1lbnRcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBjcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICB2YXIgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICByZXR1cm4gY2FudmFzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbWFnZShfeCkge1xuICByZXR1cm4gX2NyZWF0ZUltYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVJbWFnZSgpIHtcbiAgX2NyZWF0ZUltYWdlID0gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qIChzcmMpIHtcbiAgICB2YXIgYW5vbnltb3VzQ3Jvc3NPcmlnaW4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICAgIHZhciBpbWFnZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2ltZycpO1xuXG4gICAgaWYgKGFub255bW91c0Nyb3NzT3JpZ2luKSB7XG4gICAgICBpbWFnZS5jcm9zc09yaWdpbiA9ICdBbm9ueW1vdXMnO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpbWFnZS5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgIHJlc29sdmUoaW1hZ2UpO1xuICAgICAgfTtcblxuICAgICAgaW1hZ2Uub25lcnJvciA9IChfZXZlbnQsIF9zb3VyY2UsIF9saW5lbm8sIF9jb2xubywgZXJyb3IpID0+IHtcbiAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgIH07XG5cbiAgICAgIGltYWdlLnNyYyA9IHNyYztcbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBfY3JlYXRlSW1hZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuY2xhc3MgRG9jdW1lbnQge1xuICBjb25zdHJ1Y3RvcihjYW52Zykge1xuICAgIHZhciB7XG4gICAgICByb290RW1TaXplID0gMTIsXG4gICAgICBlbVNpemUgPSAxMixcbiAgICAgIGNyZWF0ZUNhbnZhcyA9IERvY3VtZW50LmNyZWF0ZUNhbnZhcyxcbiAgICAgIGNyZWF0ZUltYWdlID0gRG9jdW1lbnQuY3JlYXRlSW1hZ2UsXG4gICAgICBhbm9ueW1vdXNDcm9zc09yaWdpblxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMuY2FudmcgPSBjYW52ZztcbiAgICB0aGlzLmRlZmluaXRpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLnN0eWxlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zdHlsZXNTcGVjaWZpY2l0eSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5pbWFnZXMgPSBbXTtcbiAgICB0aGlzLmZvbnRzID0gW107XG4gICAgdGhpcy5lbVNpemVTdGFjayA9IFtdO1xuICAgIHRoaXMudW5pcXVlSWQgPSAwO1xuICAgIHRoaXMuc2NyZWVuID0gY2Fudmcuc2NyZWVuO1xuICAgIHRoaXMucm9vdEVtU2l6ZSA9IHJvb3RFbVNpemU7XG4gICAgdGhpcy5lbVNpemUgPSBlbVNpemU7XG4gICAgdGhpcy5jcmVhdGVDYW52YXMgPSBjcmVhdGVDYW52YXM7XG4gICAgdGhpcy5jcmVhdGVJbWFnZSA9IHRoaXMuYmluZENyZWF0ZUltYWdlKGNyZWF0ZUltYWdlLCBhbm9ueW1vdXNDcm9zc09yaWdpbik7XG4gICAgdGhpcy5zY3JlZW4ud2FpdCh0aGlzLmlzSW1hZ2VzTG9hZGVkLmJpbmQodGhpcykpO1xuICAgIHRoaXMuc2NyZWVuLndhaXQodGhpcy5pc0ZvbnRzTG9hZGVkLmJpbmQodGhpcykpO1xuICB9XG5cbiAgYmluZENyZWF0ZUltYWdlKGNyZWF0ZUltYWdlLCBhbm9ueW1vdXNDcm9zc09yaWdpbikge1xuICAgIGlmICh0eXBlb2YgYW5vbnltb3VzQ3Jvc3NPcmlnaW4gPT09ICdib29sZWFuJykge1xuICAgICAgcmV0dXJuIChzb3VyY2UsIGZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4pID0+IGNyZWF0ZUltYWdlKHNvdXJjZSwgdHlwZW9mIGZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4gPT09ICdib29sZWFuJyA/IGZvcmNlQW5vbnltb3VzQ3Jvc3NPcmlnaW4gOiBhbm9ueW1vdXNDcm9zc09yaWdpbik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZUltYWdlO1xuICB9XG5cbiAgZ2V0IHdpbmRvdygpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JlZW4ud2luZG93O1xuICB9XG5cbiAgZ2V0IGZldGNoKCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi5mZXRjaDtcbiAgfVxuXG4gIGdldCBjdHgoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2NyZWVuLmN0eDtcbiAgfVxuXG4gIGdldCBlbVNpemUoKSB7XG4gICAgdmFyIHtcbiAgICAgIGVtU2l6ZVN0YWNrXG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuIGVtU2l6ZVN0YWNrW2VtU2l6ZVN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgc2V0IGVtU2l6ZSh2YWx1ZSkge1xuICAgIHZhciB7XG4gICAgICBlbVNpemVTdGFja1xuICAgIH0gPSB0aGlzO1xuICAgIGVtU2l6ZVN0YWNrLnB1c2godmFsdWUpO1xuICB9XG5cbiAgcG9wRW1TaXplKCkge1xuICAgIHZhciB7XG4gICAgICBlbVNpemVTdGFja1xuICAgIH0gPSB0aGlzO1xuICAgIGVtU2l6ZVN0YWNrLnBvcCgpO1xuICB9XG5cbiAgZ2V0VW5pcXVlSWQoKSB7XG4gICAgcmV0dXJuIFwiY2FudmdcIi5jb25jYXQoKyt0aGlzLnVuaXF1ZUlkKTtcbiAgfVxuXG4gIGlzSW1hZ2VzTG9hZGVkKCkge1xuICAgIHJldHVybiB0aGlzLmltYWdlcy5ldmVyeShfID0+IF8ubG9hZGVkKTtcbiAgfVxuXG4gIGlzRm9udHNMb2FkZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuZm9udHMuZXZlcnkoXyA9PiBfLmxvYWRlZCk7XG4gIH1cblxuICBjcmVhdGVEb2N1bWVudEVsZW1lbnQoZG9jdW1lbnQpIHtcbiAgICB2YXIgZG9jdW1lbnRFbGVtZW50ID0gdGhpcy5jcmVhdGVFbGVtZW50KGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgZG9jdW1lbnRFbGVtZW50LnJvb3QgPSB0cnVlO1xuICAgIGRvY3VtZW50RWxlbWVudC5hZGRTdHlsZXNGcm9tU3R5bGVEZWZpbml0aW9uKCk7XG4gICAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudEVsZW1lbnQ7XG4gICAgcmV0dXJuIGRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIGNyZWF0ZUVsZW1lbnQobm9kZSkge1xuICAgIHZhciBlbGVtZW50VHlwZSA9IG5vZGUubm9kZU5hbWUucmVwbGFjZSgvXlteOl0rOi8sICcnKTtcbiAgICB2YXIgRWxlbWVudFR5cGUgPSBEb2N1bWVudC5lbGVtZW50VHlwZXNbZWxlbWVudFR5cGVdO1xuXG4gICAgaWYgKHR5cGVvZiBFbGVtZW50VHlwZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBuZXcgRWxlbWVudFR5cGUodGhpcywgbm9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBVbmtub3duRWxlbWVudCh0aGlzLCBub2RlKTtcbiAgfVxuXG4gIGNyZWF0ZVRleHROb2RlKG5vZGUpIHtcbiAgICByZXR1cm4gbmV3IFRleHROb2RlKHRoaXMsIG5vZGUpO1xuICB9XG5cbiAgc2V0Vmlld0JveChjb25maWcpIHtcbiAgICB0aGlzLnNjcmVlbi5zZXRWaWV3Qm94KF9vYmplY3RTcHJlYWQkMSh7XG4gICAgICBkb2N1bWVudDogdGhpc1xuICAgIH0sIGNvbmZpZykpO1xuICB9XG5cbn1cbkRvY3VtZW50LmNyZWF0ZUNhbnZhcyA9IGNyZWF0ZUNhbnZhcztcbkRvY3VtZW50LmNyZWF0ZUltYWdlID0gY3JlYXRlSW1hZ2U7XG5Eb2N1bWVudC5lbGVtZW50VHlwZXMgPSBlbGVtZW50cztcblxuZnVuY3Rpb24gb3duS2V5cyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuLyoqXHJcbiAqIFNWRyByZW5kZXJlciBvbiBjYW52YXMuXHJcbiAqL1xuXG5jbGFzcyBDYW52ZyB7XG4gIC8qKlxyXG4gICAqIE1haW4gY29uc3RydWN0b3IuXHJcbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgRG9jdW1lbnQuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cclxuICAgKi9cbiAgY29uc3RydWN0b3IoY3R4LCBzdmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdGhpcy5wYXJzZXIgPSBuZXcgUGFyc2VyKG9wdGlvbnMpO1xuICAgIHRoaXMuc2NyZWVuID0gbmV3IFNjcmVlbihjdHgsIG9wdGlvbnMpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdmFyIGRvY3VtZW50ID0gbmV3IERvY3VtZW50KHRoaXMsIG9wdGlvbnMpO1xuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEVsZW1lbnQoc3ZnKTtcbiAgICB0aGlzLmRvY3VtZW50ID0gZG9jdW1lbnQ7XG4gICAgdGhpcy5kb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudEVsZW1lbnQ7XG4gIH1cbiAgLyoqXHJcbiAgICogQ3JlYXRlIENhbnZnIGluc3RhbmNlIGZyb20gU1ZHIHNvdXJjZSBzdHJpbmcgb3IgVVJMLlxyXG4gICAqIEBwYXJhbSBjdHggLSBSZW5kZXJpbmcgY29udGV4dC5cclxuICAgKiBAcGFyYW0gc3ZnIC0gU1ZHIHNvdXJjZSBzdHJpbmcgb3IgVVJMLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXHJcbiAgICovXG5cblxuICBzdGF0aWMgZnJvbShjdHgsIHN2Zykge1xuICAgIHZhciBfYXJndW1lbnRzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBfYXN5bmNUb0dlbmVyYXRvcihmdW5jdGlvbiogKCkge1xuICAgICAgdmFyIG9wdGlvbnMgPSBfYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgX2FyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3VtZW50c1syXSA6IHt9O1xuICAgICAgdmFyIHBhcnNlciA9IG5ldyBQYXJzZXIob3B0aW9ucyk7XG4gICAgICB2YXIgc3ZnRG9jdW1lbnQgPSB5aWVsZCBwYXJzZXIucGFyc2Uoc3ZnKTtcbiAgICAgIHJldHVybiBuZXcgQ2FudmcoY3R4LCBzdmdEb2N1bWVudCwgb3B0aW9ucyk7XG4gICAgfSkoKTtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgQ2FudmcgaW5zdGFuY2UgZnJvbSBTVkcgc291cmNlIHN0cmluZy5cclxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBzb3VyY2Ugc3RyaW5nLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXHJcbiAgICovXG5cblxuICBzdGF0aWMgZnJvbVN0cmluZyhjdHgsIHN2Zykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGFyc2VyID0gbmV3IFBhcnNlcihvcHRpb25zKTtcbiAgICB2YXIgc3ZnRG9jdW1lbnQgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKHN2Zyk7XG4gICAgcmV0dXJuIG5ldyBDYW52ZyhjdHgsIHN2Z0RvY3VtZW50LCBvcHRpb25zKTtcbiAgfVxuICAvKipcclxuICAgKiBDcmVhdGUgbmV3IENhbnZnIGluc3RhbmNlIHdpdGggaW5oZXJpdGVkIG9wdGlvbnMuXHJcbiAgICogQHBhcmFtIGN0eCAtIFJlbmRlcmluZyBjb250ZXh0LlxyXG4gICAqIEBwYXJhbSBzdmcgLSBTVkcgc291cmNlIHN0cmluZyBvciBVUkwuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXJpbmcgb3B0aW9ucy5cclxuICAgKiBAcmV0dXJucyBDYW52ZyBpbnN0YW5jZS5cclxuICAgKi9cblxuXG4gIGZvcmsoY3R4LCBzdmcpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgcmV0dXJuIENhbnZnLmZyb20oY3R4LCBzdmcsIF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgdGhpcy5vcHRpb25zKSwgb3B0aW9ucykpO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZSBuZXcgQ2FudmcgaW5zdGFuY2Ugd2l0aCBpbmhlcml0ZWQgb3B0aW9ucy5cclxuICAgKiBAcGFyYW0gY3R4IC0gUmVuZGVyaW5nIGNvbnRleHQuXHJcbiAgICogQHBhcmFtIHN2ZyAtIFNWRyBzb3VyY2Ugc3RyaW5nLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICogQHJldHVybnMgQ2FudmcgaW5zdGFuY2UuXHJcbiAgICovXG5cblxuICBmb3JrU3RyaW5nKGN0eCwgc3ZnKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBDYW52Zy5mcm9tU3RyaW5nKGN0eCwgc3ZnLCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIHRoaXMub3B0aW9ucyksIG9wdGlvbnMpKTtcbiAgfVxuICAvKipcclxuICAgKiBEb2N1bWVudCBpcyByZWFkeSBwcm9taXNlLlxyXG4gICAqIEByZXR1cm5zIFJlYWR5IHByb21pc2UuXHJcbiAgICovXG5cblxuICByZWFkeSgpIHtcbiAgICByZXR1cm4gdGhpcy5zY3JlZW4ucmVhZHkoKTtcbiAgfVxuICAvKipcclxuICAgKiBEb2N1bWVudCBpcyByZWFkeSB2YWx1ZS5cclxuICAgKiBAcmV0dXJucyBJcyByZWFkeSBvciBub3QuXHJcbiAgICovXG5cblxuICBpc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLnNjcmVlbi5pc1JlYWR5KCk7XG4gIH1cbiAgLyoqXHJcbiAgICogUmVuZGVyIG9ubHkgZmlyc3QgZnJhbWUsIGlnbm9yaW5nIGFuaW1hdGlvbnMgYW5kIG1vdXNlLlxyXG4gICAqIEBwYXJhbSBvcHRpb25zIC0gUmVuZGVyaW5nIG9wdGlvbnMuXHJcbiAgICovXG5cblxuICByZW5kZXIoKSB7XG4gICAgdmFyIF9hcmd1bWVudHMyID0gYXJndW1lbnRzLFxuICAgICAgICBfdGhpcyA9IHRoaXM7XG5cbiAgICByZXR1cm4gX2FzeW5jVG9HZW5lcmF0b3IoZnVuY3Rpb24qICgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gX2FyZ3VtZW50czIubGVuZ3RoID4gMCAmJiBfYXJndW1lbnRzMlswXSAhPT0gdW5kZWZpbmVkID8gX2FyZ3VtZW50czJbMF0gOiB7fTtcblxuICAgICAgX3RoaXMuc3RhcnQoX29iamVjdFNwcmVhZCh7XG4gICAgICAgIGVuYWJsZVJlZHJhdzogdHJ1ZSxcbiAgICAgICAgaWdub3JlQW5pbWF0aW9uOiB0cnVlLFxuICAgICAgICBpZ25vcmVNb3VzZTogdHJ1ZVxuICAgICAgfSwgb3B0aW9ucykpO1xuXG4gICAgICB5aWVsZCBfdGhpcy5yZWFkeSgpO1xuXG4gICAgICBfdGhpcy5zdG9wKCk7XG4gICAgfSkoKTtcbiAgfVxuICAvKipcclxuICAgKiBTdGFydCByZW5kZXJpbmcuXHJcbiAgICogQHBhcmFtIG9wdGlvbnMgLSBSZW5kZXIgb3B0aW9ucy5cclxuICAgKi9cblxuXG4gIHN0YXJ0KCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgZG9jdW1lbnRFbGVtZW50LFxuICAgICAgc2NyZWVuLFxuICAgICAgb3B0aW9uczogYmFzZU9wdGlvbnNcbiAgICB9ID0gdGhpcztcbiAgICBzY3JlZW4uc3RhcnQoZG9jdW1lbnRFbGVtZW50LCBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe1xuICAgICAgZW5hYmxlUmVkcmF3OiB0cnVlXG4gICAgfSwgYmFzZU9wdGlvbnMpLCBvcHRpb25zKSk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3RvcCByZW5kZXJpbmcuXHJcbiAgICovXG5cblxuICBzdG9wKCkge1xuICAgIHRoaXMuc2NyZWVuLnN0b3AoKTtcbiAgfVxuICAvKipcclxuICAgKiBSZXNpemUgU1ZHIHRvIGZpdCBpbiBnaXZlbiBzaXplLlxyXG4gICAqIEBwYXJhbSB3aWR0aFxyXG4gICAqIEBwYXJhbSBoZWlnaHRcclxuICAgKiBAcGFyYW0gcHJlc2VydmVBc3BlY3RSYXRpb1xyXG4gICAqL1xuXG5cbiAgcmVzaXplKHdpZHRoKSB7XG4gICAgdmFyIGhlaWdodCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogd2lkdGg7XG4gICAgdmFyIHByZXNlcnZlQXNwZWN0UmF0aW8gPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIHRoaXMuZG9jdW1lbnRFbGVtZW50LnJlc2l6ZSh3aWR0aCwgaGVpZ2h0LCBwcmVzZXJ2ZUFzcGVjdFJhdGlvKTtcbiAgfVxuXG59XG5cbmV4cG9ydCB7IEFFbGVtZW50LCBBbmltYXRlQ29sb3JFbGVtZW50LCBBbmltYXRlRWxlbWVudCwgQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQsIEJvdW5kaW5nQm94LCBDQjEsIENCMiwgQ0IzLCBDQjQsIENhbnZnLCBDaXJjbGVFbGVtZW50LCBDbGlwUGF0aEVsZW1lbnQsIERlZnNFbGVtZW50LCBEZXNjRWxlbWVudCwgRG9jdW1lbnQsIEVsZW1lbnQsIEVsbGlwc2VFbGVtZW50LCBGZUNvbG9yTWF0cml4RWxlbWVudCwgRmVDb21wb3NpdGVFbGVtZW50LCBGZURyb3BTaGFkb3dFbGVtZW50LCBGZUdhdXNzaWFuQmx1ckVsZW1lbnQsIEZlTW9ycGhvbG9neUVsZW1lbnQsIEZpbHRlckVsZW1lbnQsIEZvbnQsIEZvbnRFbGVtZW50LCBGb250RmFjZUVsZW1lbnQsIEdFbGVtZW50LCBHbHlwaEVsZW1lbnQsIEdyYWRpZW50RWxlbWVudCwgSW1hZ2VFbGVtZW50LCBMaW5lRWxlbWVudCwgTGluZWFyR3JhZGllbnRFbGVtZW50LCBNYXJrZXJFbGVtZW50LCBNYXNrRWxlbWVudCwgTWF0cml4LCBNaXNzaW5nR2x5cGhFbGVtZW50LCBNb3VzZSwgUFNFVURPX1pFUk8sIFBhcnNlciwgUGF0aEVsZW1lbnQsIFBhdGhQYXJzZXIsIFBhdHRlcm5FbGVtZW50LCBQb2ludCwgUG9seWdvbkVsZW1lbnQsIFBvbHlsaW5lRWxlbWVudCwgUHJvcGVydHksIFFCMSwgUUIyLCBRQjMsIFJhZGlhbEdyYWRpZW50RWxlbWVudCwgUmVjdEVsZW1lbnQsIFJlbmRlcmVkRWxlbWVudCwgUm90YXRlLCBTVkdFbGVtZW50LCBTVkdGb250TG9hZGVyLCBTY2FsZSwgU2NyZWVuLCBTa2V3LCBTa2V3WCwgU2tld1ksIFN0b3BFbGVtZW50LCBTdHlsZUVsZW1lbnQsIFN5bWJvbEVsZW1lbnQsIFRSZWZFbGVtZW50LCBUU3BhbkVsZW1lbnQsIFRleHRFbGVtZW50LCBUZXh0UGF0aEVsZW1lbnQsIFRpdGxlRWxlbWVudCwgVHJhbnNmb3JtLCBUcmFuc2xhdGUsIFVua25vd25FbGVtZW50LCBVc2VFbGVtZW50LCBWaWV3UG9ydCwgY29tcHJlc3NTcGFjZXMsIENhbnZnIGFzIGRlZmF1bHQsIGdldFNlbGVjdG9yU3BlY2lmaWNpdHksIG5vcm1hbGl6ZUF0dHJpYnV0ZU5hbWUsIG5vcm1hbGl6ZUNvbG9yLCBwYXJzZUV4dGVybmFsVXJsLCBpbmRleCBhcyBwcmVzZXRzLCB0b051bWJlcnMsIHRyaW1MZWZ0LCB0cmltUmlnaHQsIHZlY3Rvck1hZ25pdHVkZSwgdmVjdG9yc0FuZ2xlLCB2ZWN0b3JzUmF0aW8gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxleUoyWlhKemFXOXVJam96TENKbWFXeGxJam9pYVc1a1pYZ3VaWE11YW5NaUxDSnpiM1Z5WTJWeklqcGJYU3dpYzI5MWNtTmxjME52Ym5SbGJuUWlPbHRkTENKdVlXMWxjeUk2VzEwc0ltMWhjSEJwYm1keklqb2lPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096czdPenM3T3pzN096c2lmUT09XG4iXSwibmFtZXMiOlsiX2FzeW5jVG9HZW5lcmF0b3IiLCJfZGVmaW5lUHJvcGVydHkiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJSR0JDb2xvciIsIlNWR1BhdGhEYXRhIiwiY2FudmFzUkdCQSIsIm9mZnNjcmVlbiIsIkRPTVBhcnNlciIsIkRPTVBhcnNlckZhbGxiYWNrIiwiYXJndW1lbnRzIiwibGVuZ3RoIiwidW5kZWZpbmVkIiwicHJlc2V0Iiwid2luZG93IiwiaWdub3JlQW5pbWF0aW9uIiwiaWdub3JlTW91c2UiLCJjcmVhdGVDYW52YXMiLCJ3aWR0aCIsImhlaWdodCIsIk9mZnNjcmVlbkNhbnZhcyIsImNyZWF0ZUltYWdlIiwidXJsIiwicmVzcG9uc2UiLCJmZXRjaCIsImJsb2IiLCJpbWciLCJjcmVhdGVJbWFnZUJpdG1hcCIsIlJlZmxlY3QiLCJkZWxldGVQcm9wZXJ0eSIsIm5vZGUiLCJfcmVmIiwiY2FudmFzIiwibG9hZEltYWdlIiwiaW5kZXgiLCJPYmplY3QiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJjb21wcmVzc1NwYWNlcyIsInN0ciIsInJlcGxhY2UiLCJ0cmltTGVmdCIsInRyaW1SaWdodCIsInRvTnVtYmVycyIsIm1hdGNoZXMiLCJtYXRjaCIsIm1hcCIsInBhcnNlRmxvYXQiLCJhbGxVcHBlcmNhc2UiLCJub3JtYWxpemVBdHRyaWJ1dGVOYW1lIiwibmFtZSIsInRlc3QiLCJ0b0xvd2VyQ2FzZSIsInBhcnNlRXh0ZXJuYWxVcmwiLCJ1cmxNYXRjaCIsImV4ZWMiLCJub3JtYWxpemVDb2xvciIsImNvbG9yIiwic3RhcnRzV2l0aCIsInJnYlBhcnRzIiwibm9ybWFsaXplZENvbG9yIiwibnVtIiwiaXNGbG9hdCIsIlN0cmluZyIsIk1hdGgiLCJyb3VuZCIsImF0dHJpYnV0ZVJlZ2V4IiwiaWRSZWdleCIsImNsYXNzUmVnZXgiLCJwc2V1ZG9FbGVtZW50UmVnZXgiLCJwc2V1ZG9DbGFzc1dpdGhCcmFja2V0c1JlZ2V4IiwicHNldWRvQ2xhc3NSZWdleCIsImVsZW1lbnRSZWdleCIsImZpbmRTZWxlY3Rvck1hdGNoIiwic2VsZWN0b3IiLCJyZWdleCIsImdldFNlbGVjdG9yU3BlY2lmaWNpdHkiLCJzcGVjaWZpY2l0eSIsImN1cnJlbnRTZWxlY3RvciIsImRlbHRhIiwiam9pbiIsIlBTRVVET19aRVJPIiwidmVjdG9yTWFnbml0dWRlIiwidiIsInNxcnQiLCJwb3ciLCJ2ZWN0b3JzUmF0aW8iLCJ1IiwidmVjdG9yc0FuZ2xlIiwiYWNvcyIsIkNCMSIsInQiLCJDQjIiLCJDQjMiLCJDQjQiLCJRQjEiLCJRQjIiLCJRQjMiLCJQcm9wZXJ0eSIsImNvbnN0cnVjdG9yIiwiZG9jdW1lbnQiLCJ2YWx1ZSIsImlzTm9ybWFsaXplZENvbG9yIiwiZW1wdHkiLCJzcGxpdCIsInNlcGFyYXRvciIsImdldFN0cmluZyIsInRyaW0iLCJoYXNWYWx1ZSIsInplcm9Jc1ZhbHVlIiwiaXNTdHJpbmciLCJyZWdleHAiLCJyZXN1bHQiLCJpc1VybERlZmluaXRpb24iLCJpc1BpeGVscyIsImFzU3RyaW5nIiwiZW5kc1dpdGgiLCJzZXRWYWx1ZSIsImdldFZhbHVlIiwiZGVmIiwiZ2V0TnVtYmVyIiwibiIsImdldENvbG9yIiwiZ2V0RHBpIiwiZ2V0UmVtIiwicm9vdEVtU2l6ZSIsImdldEVtIiwiZW1TaXplIiwiZ2V0VW5pdHMiLCJnZXRQaXhlbHMiLCJheGlzT3JJc0ZvbnRTaXplIiwicHJvY2Vzc1BlcmNlbnQiLCJheGlzIiwiaXNGb250U2l6ZSIsInZpZXdQb3J0Iiwic2NyZWVuIiwibWluIiwiY29tcHV0ZVNpemUiLCJtYXgiLCJnZXRNaWxsaXNlY29uZHMiLCJnZXRSYWRpYW5zIiwiUEkiLCJnZXREZWZpbml0aW9uIiwiZGVmaW5pdGlvbnMiLCJnZXRGaWxsU3R5bGVEZWZpbml0aW9uIiwiZWxlbWVudCIsIm9wYWNpdHkiLCJjcmVhdGVHcmFkaWVudCIsImN0eCIsImNyZWF0ZVBhdHRlcm4iLCJnZXRIcmVmQXR0cmlidXRlIiwicGF0dGVyblRyYW5zZm9ybSIsImdldEF0dHJpYnV0ZSIsImdldFRleHRCYXNlbGluZSIsInRleHRCYXNlbGluZU1hcHBpbmciLCJhZGRPcGFjaXR5IiwibGVuIiwiY29tbWFzIiwiaSIsIm9rIiwiYWxwaGEiLCJ0b1JHQkEiLCJWaWV3UG9ydCIsInZpZXdQb3J0cyIsImNsZWFyIiwic2V0Q3VycmVudCIsInB1c2giLCJyZW1vdmVDdXJyZW50IiwicG9wIiwiZ2V0Q3VycmVudCIsImQiLCJQb2ludCIsIngiLCJ5IiwicGFyc2UiLCJwb2ludCIsImRlZmF1bHRWYWx1ZSIsInBhcnNlU2NhbGUiLCJzY2FsZSIsInBhcnNlUGF0aCIsInBhdGgiLCJwb2ludHMiLCJwYXRoUG9pbnRzIiwiYW5nbGVUbyIsImF0YW4yIiwiYXBwbHlUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm0iLCJ4cCIsInlwIiwiTW91c2UiLCJ3b3JraW5nIiwiZXZlbnRzIiwiZXZlbnRFbGVtZW50cyIsIm9uQ2xpY2siLCJiaW5kIiwib25Nb3VzZU1vdmUiLCJpc1dvcmtpbmciLCJzdGFydCIsIm9uY2xpY2siLCJvbm1vdXNlbW92ZSIsInN0b3AiLCJoYXNFdmVudHMiLCJydW5FdmVudHMiLCJzdHlsZSIsImN1cnNvciIsImZvckVhY2giLCJydW4iLCJwYXJlbnQiLCJjaGVja1BhdGgiLCJfcmVmMiIsImlzUG9pbnRJblBhdGgiLCJjaGVja0JvdW5kaW5nQm94IiwiYm91bmRpbmdCb3giLCJfcmVmMyIsImlzUG9pbnRJbkJveCIsIm1hcFhZIiwib2Zmc2V0TGVmdCIsIm9mZnNldFRvcCIsIm9mZnNldFBhcmVudCIsInNjcm9sbFgiLCJzY3JvbGxZIiwiZXZlbnQiLCJjbGllbnRYIiwiY2xpZW50WSIsInR5cGUiLCJldmVudFRhcmdldCIsImRlZmF1bHRXaW5kb3ciLCJkZWZhdWx0RmV0Y2gkMSIsIlNjcmVlbiIsIkZSQU1FUkFURSIsIk1BWF9WSVJUVUFMX1BJWEVMUyIsIkNMSUVOVF9XSURUSCIsIkNMSUVOVF9IRUlHSFQiLCJtb3VzZSIsImFuaW1hdGlvbnMiLCJ3YWl0cyIsImZyYW1lRHVyYXRpb24iLCJpc1JlYWR5TG9jayIsImlzRmlyc3RSZW5kZXIiLCJpbnRlcnZhbElkIiwid2FpdCIsImNoZWNrZXIiLCJyZWFkeSIsInJlYWR5UHJvbWlzZSIsIlByb21pc2UiLCJyZXNvbHZlIiwiaXNSZWFkeSIsImV2ZXJ5IiwiXyIsInJlc29sdmVSZWFkeSIsInNldERlZmF1bHRzIiwic3Ryb2tlU3R5bGUiLCJsaW5lQ2FwIiwibGluZUpvaW4iLCJtaXRlckxpbWl0Iiwic2V0Vmlld0JveCIsImFzcGVjdFJhdGlvIiwiZGVzaXJlZFdpZHRoIiwiZGVzaXJlZEhlaWdodCIsIm1pblgiLCJtaW5ZIiwicmVmWCIsInJlZlkiLCJjbGlwIiwiY2xpcFgiLCJjbGlwWSIsImNsZWFuQXNwZWN0UmF0aW8iLCJhc3BlY3RSYXRpb0FsaWduIiwiYXNwZWN0UmF0aW9NZWV0T3JTbGljZSIsImFsaWduIiwibWVldE9yU2xpY2UiLCJzY2FsZVgiLCJzY2FsZVkiLCJzY2FsZU1pbiIsInNjYWxlTWF4IiwiZmluYWxEZXNpcmVkV2lkdGgiLCJmaW5hbERlc2lyZWRIZWlnaHQiLCJyZWZYUHJvcCIsInJlZllQcm9wIiwiaGFzUmVmcyIsInRyYW5zbGF0ZSIsInNjYWxlZENsaXBYIiwic2NhbGVkQ2xpcFkiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJjbG9zZVBhdGgiLCJpc01lZXRNaW5ZIiwiaXNTbGljZU1heFkiLCJpc01lZXRNaW5YIiwiaXNTbGljZU1heFgiLCJlbmFibGVSZWRyYXciLCJpZ25vcmVEaW1lbnNpb25zIiwiaWdub3JlQ2xlYXIiLCJmb3JjZVJlZHJhdyIsInNjYWxlV2lkdGgiLCJzY2FsZUhlaWdodCIsIm9mZnNldFgiLCJvZmZzZXRZIiwicmVuZGVyIiwibm93IiwiRGF0ZSIsInRoZW4iLCJ0aWNrIiwic2hvdWxkVXBkYXRlIiwiY2FuY2VsIiwicmVkdWNlIiwiYW5pbWF0aW9uIiwidXBkYXRlIiwid2lkdGhTdHlsZSIsImdldFN0eWxlIiwiaGVpZ2h0U3R5bGUiLCJjb25jYXQiLCJjV2lkdGgiLCJjbGllbnRXaWR0aCIsImNIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJ2aWV3Qm94IiwieFJhdGlvIiwieVJhdGlvIiwiX3dpZHRoU3R5bGUiLCJpc05hTiIsIl9oZWlnaHRTdHlsZSIsInRyYW5zZm9ybVN0eWxlIiwiY2xlYXJSZWN0IiwiZGVmYXVsdEZldGNoIiwiRGVmYXVsdERPTVBhcnNlciIsIlBhcnNlciIsInJlc291cmNlIiwiX3RoaXMiLCJwYXJzZUZyb21TdHJpbmciLCJsb2FkIiwieG1sIiwicGFyc2VyIiwiY2hlY2tEb2N1bWVudCIsImVyciIsInBhcnNlckVycm9yIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJFcnJvciIsInRleHRDb250ZW50IiwiX3RoaXMyIiwidGV4dCIsIlRyYW5zbGF0ZSIsImFwcGx5IiwidW5hcHBseSIsImFwcGx5VG9Qb2ludCIsIlJvdGF0ZSIsInJvdGF0ZSIsInRyYW5zZm9ybU9yaWdpbiIsImFuZ2xlIiwib3JpZ2luWCIsIm9yaWdpblkiLCJjeCIsImN5IiwibnVtYmVycyIsInR4IiwidHkiLCJyYWQiLCJjb3MiLCJzaW4iLCJTY2FsZSIsInNjYWxlU2l6ZSIsIk1hdHJpeCIsIm1hdHJpeCIsImEiLCJiIiwiYyIsImUiLCJmIiwiZyIsImgiLCJkZXQiLCJTa2V3Iiwic2tldyIsIlNrZXdYIiwidGFuIiwiU2tld1kiLCJwYXJzZVRyYW5zZm9ybXMiLCJwYXJzZVRyYW5zZm9ybSIsIlRyYW5zZm9ybSIsInRyYW5zZm9ybXMiLCJkYXRhIiwiVHJhbnNmb3JtVHlwZSIsInRyYW5zZm9ybVR5cGVzIiwiZnJvbUVsZW1lbnQiLCJ0cmFuc2Zvcm1PcmlnaW5YUHJvcGVydHkiLCJ0cmFuc2Zvcm1PcmlnaW5ZUHJvcGVydHkiLCJza2V3WCIsInNrZXdZIiwiRWxlbWVudCIsImNhcHR1cmVUZXh0Tm9kZXMiLCJhdHRyaWJ1dGVzIiwiY3JlYXRlIiwic3R5bGVzIiwic3R5bGVzU3BlY2lmaWNpdHkiLCJhbmltYXRpb25Gcm96ZW4iLCJhbmltYXRpb25Gcm96ZW5WYWx1ZSIsImNoaWxkcmVuIiwibm9kZVR5cGUiLCJBcnJheSIsImZyb20iLCJhdHRyaWJ1dGUiLCJub2RlTmFtZSIsImFkZFN0eWxlc0Zyb21TdHlsZURlZmluaXRpb24iLCJpZCIsImNoaWxkTm9kZXMiLCJjaGlsZE5vZGUiLCJhZGRDaGlsZCIsInRleHROb2RlIiwiY3JlYXRlVGV4dE5vZGUiLCJnZXRUZXh0IiwiY3JlYXRlSWZOb3RFeGlzdHMiLCJhdHRyIiwiX2F0dHIiLCJrZXkiLCJza2lwQW5jZXN0b3JzIiwicGFyZW50U3R5bGUiLCJfc3R5bGUiLCJzYXZlIiwibWFzayIsImFwcGx5RWZmZWN0cyIsImZpbHRlciIsInNldENvbnRleHQiLCJyZW5kZXJDaGlsZHJlbiIsImNsZWFyQ29udGV4dCIsInJlc3RvcmUiLCJjbGlwUGF0aFN0eWxlUHJvcCIsImNoaWxkIiwiY3JlYXRlRWxlbWVudCIsImlnbm9yZUNoaWxkVHlwZXMiLCJpbmNsdWRlcyIsIm1hdGNoZXNTZWxlY3RvciIsIl9ub2RlJGdldEF0dHJpYnV0ZSIsInN0eWxlQ2xhc3NlcyIsImNhbGwiLCJzb21lIiwic3R5bGVDbGFzcyIsImV4aXN0aW5nU3BlY2lmaWNpdHkiLCJyZW1vdmVTdHlsZXMiLCJpZ25vcmVTdHlsZXMiLCJ0b1Jlc3RvcmUiLCJzdHlsZVByb3AiLCJyZXN0b3JlU3R5bGVzIiwiaXNGaXJzdENoaWxkIiwiX3RoaXMkcGFyZW50IiwiaW5kZXhPZiIsIlVua25vd25FbGVtZW50Iiwid3JhcEZvbnRGYW1pbHkiLCJmb250RmFtaWx5IiwidHJpbW1lZCIsInByZXBhcmVGb250RmFtaWx5IiwicHJvY2VzcyIsInByZXBhcmVGb250U3R5bGUiLCJmb250U3R5bGUiLCJ0YXJnZXRGb250U3R5bGUiLCJwcmVwYXJlRm9udFdlaWdodCIsImZvbnRXZWlnaHQiLCJ0YXJnZXRGb250V2VpZ2h0IiwiRm9udCIsImZvbnRWYXJpYW50IiwiZm9udFNpemUiLCJpbmhlcml0IiwiaW5oZXJpdEZvbnQiLCJmb250IiwicGFydHMiLCJzZXQiLCJwYXJ0IiwidmFyaWFudHMiLCJ3ZWlnaHRzIiwidG9TdHJpbmciLCJCb3VuZGluZ0JveCIsIngxIiwiTnVtYmVyIiwiTmFOIiwieTEiLCJ4MiIsInkyIiwiYWRkUG9pbnQiLCJhZGRYIiwiYWRkWSIsImFkZEJvdW5kaW5nQm94Iiwic3VtQ3ViaWMiLCJwMCIsInAxIiwicDIiLCJwMyIsImJlemllckN1cnZlQWRkIiwiZm9yWCIsImIyYWMiLCJ0MSIsInQyIiwiYWRkQmV6aWVyQ3VydmUiLCJwMHgiLCJwMHkiLCJwMXgiLCJwMXkiLCJwMngiLCJwMnkiLCJwM3giLCJwM3kiLCJhZGRRdWFkcmF0aWNDdXJ2ZSIsImNwMXgiLCJjcDF5IiwiY3AyeCIsImNwMnkiLCJQYXRoUGFyc2VyIiwiY29udHJvbCIsImN1cnJlbnQiLCJjb21tYW5kIiwiY29tbWFuZHMiLCJwcmV2aW91c0NvbW1hbmQiLCJhbmdsZXMiLCJyZXNldCIsImlzRW5kIiwibmV4dCIsImdldFBvaW50IiwieFByb3AiLCJ5UHJvcCIsIm1ha2VBYnNvbHV0ZSIsImdldEFzQ29udHJvbFBvaW50IiwiZ2V0QXNDdXJyZW50UG9pbnQiLCJnZXRSZWZsZWN0ZWRDb250cm9sUG9pbnQiLCJDVVJWRV9UTyIsIlNNT09USF9DVVJWRV9UTyIsIlFVQURfVE8iLCJTTU9PVEhfUVVBRF9UTyIsIm94Iiwib3kiLCJyZWxhdGl2ZSIsImFkZE1hcmtlciIsInByaW9yVG8iLCJhZGRNYXJrZXJBbmdsZSIsImdldE1hcmtlclBvaW50cyIsImdldE1hcmtlckFuZ2xlcyIsImoiLCJSZW5kZXJlZEVsZW1lbnQiLCJtb2RpZmllZEVtU2l6ZVN0YWNrIiwiY2FsY3VsYXRlT3BhY2l0eSIsIm9wYWNpdHlTdHlsZSIsImZyb21NZWFzdXJlIiwiZmlsbFN0eWxlUHJvcCIsImZpbGxPcGFjaXR5U3R5bGVQcm9wIiwic3Ryb2tlU3R5bGVQcm9wIiwic3Ryb2tlT3BhY2l0eVByb3AiLCJmaWxsU3R5bGUiLCJfZmlsbFN0eWxlIiwiX2ZpbGxTdHlsZTIiLCJfc3Ryb2tlU3R5bGUiLCJfc3Ryb2tlU3R5bGUyIiwic3Ryb2tlV2lkdGhTdHlsZVByb3AiLCJuZXdMaW5lV2lkdGgiLCJsaW5lV2lkdGgiLCJzdHJva2VMaW5lY2FwU3R5bGVQcm9wIiwic3Ryb2tlTGluZWpvaW5TdHlsZVByb3AiLCJzdHJva2VNaXRlcmxpbWl0UHJvcCIsInN0cm9rZURhc2hhcnJheVN0eWxlUHJvcCIsInN0cm9rZURhc2hvZmZzZXRQcm9wIiwiZ2FwcyIsInNldExpbmVEYXNoIiwid2Via2l0TGluZURhc2giLCJtb3pEYXNoIiwib2Zmc2V0IiwibGluZURhc2hPZmZzZXQiLCJ3ZWJraXRMaW5lRGFzaE9mZnNldCIsIm1vekRhc2hPZmZzZXQiLCJmb250U3R5bGVQcm9wIiwiZm9udFN0eWxlU3R5bGVQcm9wIiwiZm9udFZhcmlhbnRTdHlsZVByb3AiLCJmb250V2VpZ2h0U3R5bGVQcm9wIiwiZm9udFNpemVTdHlsZVByb3AiLCJmb250RmFtaWx5U3R5bGVQcm9wIiwiZ2xvYmFsQWxwaGEiLCJwb3BFbVNpemUiLCJQYXRoRWxlbWVudCIsInBhdGhQYXJzZXIiLCJNT1ZFX1RPIiwicGF0aE0iLCJMSU5FX1RPIiwicGF0aEwiLCJIT1JJWl9MSU5FX1RPIiwicGF0aEgiLCJWRVJUX0xJTkVfVE8iLCJwYXRoViIsInBhdGhDIiwicGF0aFMiLCJwYXRoUSIsInBhdGhUIiwiQVJDIiwicGF0aEEiLCJDTE9TRV9QQVRIIiwicGF0aFoiLCJnZXRCb3VuZGluZ0JveCIsImdldE1hcmtlcnMiLCJtYXJrZXJzIiwiZmlsbFJ1bGVTdHlsZVByb3AiLCJmaWxsIiwic2V0VHJhbnNmb3JtIiwic3Ryb2tlIiwibWFya2Vyc0xhc3RJbmRleCIsIm1hcmtlclN0YXJ0U3R5bGVQcm9wIiwibWFya2VyTWlkU3R5bGVQcm9wIiwibWFya2VyRW5kU3R5bGVQcm9wIiwibWFya2VyIiwiX21hcmtlciIsIl9wb2ludCIsIl9hbmdsZSIsIl9tYXJrZXIyIiwiX3BvaW50MiIsIl9hbmdsZTIiLCJjb250cm9sUG9pbnQiLCJjdXJyZW50UG9pbnQiLCJiZXppZXJDdXJ2ZVRvIiwicXVhZHJhdGljQ3VydmVUbyIsInJYIiwiclkiLCJ4Um90IiwibEFyY0ZsYWciLCJzd2VlcEZsYWciLCJ4QXhpc1JvdGF0aW9uIiwiY3VycnAiLCJsIiwicyIsImNwcCIsImNlbnRwIiwiYTEiLCJhZCIsImRpciIsImFoIiwiaGFsZldheSIsInIiLCJzeCIsInN5IiwiYXJjIiwiQm9vbGVhbiIsIkdseXBoRWxlbWVudCIsImhvcml6QWR2WCIsInVuaWNvZGUiLCJhcmFiaWNGb3JtIiwiVGV4dEVsZW1lbnQiLCJtZWFzdXJlQ2FjaGUiLCJ0ZXh0QmFzZWxpbmUiLCJpbml0aWFsaXplQ29vcmRpbmF0ZXMiLCJsZWFmVGV4dHMiLCJ0ZXh0Q2h1bmtTdGFydCIsIlBPU0lUSVZFX0lORklOSVRZIiwibWF4WCIsIk5FR0FUSVZFX0lORklOSVRZIiwiZ2V0VEVsZW1lbnRCb3VuZGluZ0JveCIsImFkanVzdENoaWxkQ29vcmRpbmF0ZXNSZWN1cnNpdmUiLCJjaGlsZEJvdW5kaW5nQm94IiwiZ2V0Q2hpbGRCb3VuZGluZ0JveCIsImdldEZvbnRTaXplIiwiaW5oZXJpdEZvbnRTaXplIiwibWVhc3VyZVRleHQiLCJnZXRHbHlwaCIsImNoYXIiLCJnbHlwaCIsImlzQXJhYmljIiwicHJldkNoYXIiLCJuZXh0Q2hhciIsImdseXBocyIsIm1heWJlR2x5cGgiLCJtaXNzaW5nR2x5cGgiLCJnZXRUZXh0RnJvbU5vZGUiLCJwYXJlbnROb2RlIiwibGFzdEluZGV4IiwicmVuZGVyVEVsZW1lbnRDaGlsZHJlbiIsInJlbmRlckNoaWxkIiwicmVuZGVyVGV4dCIsImN1c3RvbUZvbnQiLCJ1bml0c1BlckVtIiwiZm9udEZhY2UiLCJjdHhGb250IiwiaXNSVEwiLCJyZXZlcnNlIiwiZHgiLCJsdyIsImZpbGxUZXh0Iiwic3Ryb2tlVGV4dCIsImFwcGx5QW5jaG9yaW5nIiwiZmlyc3RFbGVtZW50IiwidGV4dEFuY2hvciIsInNoaWZ0IiwiYWRqdXN0Q2hpbGRDb29yZGluYXRlc1JlY3Vyc2l2ZUNvcmUiLCJ0ZXh0UGFyZW50IiwiYWRqdXN0Q2hpbGRDb29yZGluYXRlcyIsInhBdHRyIiwieUF0dHIiLCJkeEF0dHIiLCJkeUF0dHIiLCJnZXRJbmhlcml0ZWRBdHRyaWJ1dGUiLCJtZWFzdXJlIiwibWVhc3VyZVRhcmdldFRleHQiLCJ0YXJnZXRUZXh0IiwiX21lYXN1cmUiLCJwYXJlbnRBdHRyIiwiVFNwYW5FbGVtZW50IiwiVGV4dE5vZGUiLCJTVkdFbGVtZW50Iiwicm9vdCIsIl90aGlzJG5vZGUkcGFyZW50Tm9kZSIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiZm9udFNpemVQcm9wIiwicmVmWEF0dHIiLCJyZWZZQXR0ciIsInZpZXdCb3hBdHRyIiwicmVzaXplIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsIndpZHRoQXR0ciIsImhlaWdodEF0dHIiLCJzdHlsZUF0dHIiLCJvcmlnaW5XaWR0aCIsIm9yaWdpbkhlaWdodCIsInByZXNlcnZlQXNwZWN0UmF0aW9BdHRyIiwiUmVjdEVsZW1lbnQiLCJyeEF0dHIiLCJyeUF0dHIiLCJyeCIsInJ5IiwiS0FQUEEiLCJDaXJjbGVFbGVtZW50IiwiRWxsaXBzZUVsZW1lbnQiLCJMaW5lRWxlbWVudCIsImdldFBvaW50cyIsIngwIiwieTAiLCJQb2x5bGluZUVsZW1lbnQiLCJQb2x5Z29uRWxlbWVudCIsIlBhdHRlcm5FbGVtZW50IiwicGFyZW50T3BhY2l0eVByb3AiLCJwYXR0ZXJuU3ZnIiwicGF0dGVybkNhbnZhcyIsInBhdHRlcm5DdHgiLCJnZXRDb250ZXh0IiwicGF0dGVybiIsIk1hcmtlckVsZW1lbnQiLCJvcmllbnQiLCJtYXJrZXJVbml0cyIsIm1hcmtlclN2ZyIsIm92ZXJmbG93IiwiRGVmc0VsZW1lbnQiLCJHRWxlbWVudCIsIkdyYWRpZW50RWxlbWVudCIsImF0dHJpYnV0ZXNUb0luaGVyaXQiLCJzdG9wcyIsImdldEdyYWRpZW50VW5pdHMiLCJzdG9wc0NvbnRhaW5lciIsImluaGVyaXRTdG9wQ29udGFpbmVyIiwiZ3JhZGllbnQiLCJnZXRHcmFkaWVudCIsImFkZFBhcmVudE9wYWNpdHkiLCJhZGRDb2xvclN0b3AiLCJyb290VmlldyIsInJlY3QiLCJncm91cCIsImF0dHJpYnV0ZVRvSW5oZXJpdCIsImNvbG9yUHJvcCIsIkxpbmVhckdyYWRpZW50RWxlbWVudCIsImlzQm91bmRpbmdCb3hVbml0cyIsImNyZWF0ZUxpbmVhckdyYWRpZW50IiwiUmFkaWFsR3JhZGllbnRFbGVtZW50IiwiZngiLCJmeSIsImZyIiwiY3JlYXRlUmFkaWFsR3JhZGllbnQiLCJTdG9wRWxlbWVudCIsInN0b3BPcGFjaXR5Iiwic3RvcENvbG9yIiwiQW5pbWF0ZUVsZW1lbnQiLCJkdXJhdGlvbiIsImluaXRpYWxWYWx1ZSIsImluaXRpYWxVbml0cyIsInJlbW92ZWQiLCJmcm96ZW4iLCJiZWdpbiIsIm1heER1cmF0aW9uIiwidG8iLCJ2YWx1ZXMiLCJ2YWx1ZXNBdHRyIiwiZ2V0UHJvcGVydHkiLCJhdHRyaWJ1dGVUeXBlIiwiYXR0cmlidXRlTmFtZSIsImNhbGNWYWx1ZSIsInByb2dyZXNzIiwiZ2V0UHJvZ3Jlc3MiLCJuZXdWYWx1ZSIsInByb3AiLCJ1cGRhdGVkIiwidHlwZUF0dHIiLCJwIiwibGIiLCJmbG9vciIsInViIiwiY2VpbCIsIkFuaW1hdGVDb2xvckVsZW1lbnQiLCJjb2xvckZyb20iLCJjb2xvclRvIiwiQW5pbWF0ZVRyYW5zZm9ybUVsZW1lbnQiLCJ0cmFuc2Zvcm1Gcm9tIiwidHJhbnNmb3JtVG8iLCJGb250RWxlbWVudCIsImZvbnRGYW1pbHlTdHlsZSIsIkZvbnRGYWNlRWxlbWVudCIsImFzY2VudCIsImRlc2NlbnQiLCJNaXNzaW5nR2x5cGhFbGVtZW50IiwiVFJlZkVsZW1lbnQiLCJmaXJzdENoaWxkIiwiQUVsZW1lbnQiLCJoYXNUZXh0Iiwib3BlbiIsIm93bktleXMkMiIsIm9iamVjdCIsImVudW1lcmFibGVPbmx5Iiwia2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsInN5bWJvbHMiLCJzeW0iLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiX29iamVjdFNwcmVhZCQyIiwidGFyZ2V0Iiwic291cmNlIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIlRleHRQYXRoRWxlbWVudCIsInRleHRXaWR0aCIsInRleHRIZWlnaHQiLCJwYXRoTGVuZ3RoIiwiZ2x5cGhJbmZvIiwibGV0dGVyU3BhY2luZ0NhY2hlIiwibWVhc3VyZXNDYWNoZSIsIk1hcCIsInBhdGhFbGVtZW50IiwiZGF0YUFycmF5IiwicGFyc2VQYXRoRGF0YSIsInRoZXRhIiwiZFRoZXRhIiwicHNpIiwiZnMiLCJzZXRUZXh0RGF0YSIsInRleHREZWNvcmF0aW9uIiwicm90YXRpb24iLCJwYXJ0aWFsVGV4dCIsImdldExldHRlclNwYWNpbmdBdCIsImlkeCIsImZpbmRTZWdtZW50VG9GaXRDaGFyIiwiYW5jaG9yIiwidGV4dEZ1bGxXaWR0aCIsImZ1bGxQYXRoV2lkdGgiLCJzcGFjZXNOdW1iZXIiLCJpbnB1dE9mZnNldCIsImR5IiwiY2hhckkiLCJnbHlwaFdpZHRoIiwic3BsaW5lU3RlcCIsImdldEVxdWlkaXN0YW50UG9pbnRPblBhdGgiLCJzZWdtZW50IiwiZHlYIiwiZHlZIiwiaGFzIiwiZ2V0IiwiY2hhcnMiLCJ0aGlzU3BhY2luZyIsInBhcmVudFNwYWNpbmciLCJsZXR0ZXJTcGFjaW5nIiwidGV4dExlbiIsImR4U3VtIiwiYWNjIiwiY3VyIiwiZ2V0UGF0aExlbmd0aCIsInN0YXJ0T2Zmc2V0IiwibmV4dE9mZnNldCIsInBhdGhDb21tYW5kcyIsInN0YXJ0WCIsInN0YXJ0WSIsIm5leHRDb21tYW5kVHlwZSIsImNhbGNMZW5ndGgiLCJjb21tYW5kVHlwZSIsImdldExpbmVMZW5ndGgiLCJnZXRQb2ludE9uQ3ViaWNCZXppZXIiLCJnZXRQb2ludE9uUXVhZHJhdGljQmV6aWVyIiwiZW5kIiwiaW5jIiwiYWJzIiwiZ2V0UG9pbnRPbkVsbGlwdGljYWxBcmMiLCJnZXRQb2ludE9uTGluZSIsImRpc3QiLCJmcm9tWCIsImZyb21ZIiwibSIsInJpc2UiLCJwdCIsIml4IiwiaXkiLCJwUmlzZSIsInBSdW4iLCJnZXRQb2ludE9uUGF0aCIsImRpc3RhbmNlIiwiZnVsbExlbiIsImN1bXVsYXRpdmVQYXRoTGVuZ3RoIiwiY3VycmVudFQiLCJwY3QiLCJwNHgiLCJwNHkiLCJjb3NQc2kiLCJzaW5Qc2kiLCJidWlsZEVxdWlkaXN0YW50Q2FjaGUiLCJpbnB1dFN0ZXAiLCJpbnB1dFByZWNpc2lvbiIsInByZWNpc2lvbiIsInN0ZXAiLCJlcXVpZGlzdGFudENhY2hlIiwidGFyZ2V0RGlzdGFuY2UiLCJkYXRhVXJpUmVnZXgiLCJJbWFnZUVsZW1lbnQiLCJsb2FkZWQiLCJocmVmIiwiaXNTdmciLCJpbWFnZXMiLCJsb2FkU3ZnIiwiaW1hZ2UiLCJjb25zb2xlIiwiZXJyb3IiLCJhdG9iIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwic3ZnIiwic3ViRG9jdW1lbnQiLCJjYW52ZyIsImZvcmtTdHJpbmciLCJkb2N1bWVudEVsZW1lbnQiLCJfaW1hZ2UiLCJjb21wbGV0ZSIsImRyYXdJbWFnZSIsIlN5bWJvbEVsZW1lbnQiLCJTVkdGb250TG9hZGVyIiwiZm9udHMiLCJzdmdEb2N1bWVudCIsImZvbnROb2RlIiwiU3R5bGVFbGVtZW50IiwiY3NzIiwiY3NzRGVmcyIsImNzc1BhcnRzIiwiY3NzQ2xhc3NlcyIsImNzc1Byb3BzIiwiY3NzQ2xhc3MiLCJwcm9wcyIsImNzc1Byb3AiLCJzdWJzdHIiLCJzcmNzIiwic3JjIiwiVXNlRWxlbWVudCIsInRlbXBTdmciLCJvbGRQYXJlbnQiLCJlbGVtZW50VHJhbnNmb3JtIiwiY2FjaGVkRWxlbWVudCIsImltR2V0IiwiX2hlaWdodCIsInJnYmEiLCJpbVNldCIsInZhbCIsIm1pIiwibTEiLCJtMiIsIm0zIiwiRmVDb2xvck1hdHJpeEVsZW1lbnQiLCJpbmNsdWRlT3BhY2l0eSIsIl94IiwiX3kiLCJzcmNEYXRhIiwiZ2V0SW1hZ2VEYXRhIiwibnIiLCJuZyIsIm5iIiwibmEiLCJwdXRJbWFnZURhdGEiLCJNYXNrRWxlbWVudCIsImlnbm9yZWRTdHlsZXMiLCJtYXNrQ2FudmFzIiwibWFza0N0eCIsInRtcENhbnZhcyIsInRtcEN0eCIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsImZpbGxSZWN0Iiwibm9vcCIsIkNsaXBQYXRoRWxlbWVudCIsImNvbnRleHRQcm90byIsImdldFByb3RvdHlwZU9mIiwiRmlsdGVyRWxlbWVudCIsInB4IiwicHkiLCJlZmQiLCJleHRyYUZpbHRlckRpc3RhbmNlIiwidG1wQ2FudmFzV2lkdGgiLCJ0bXBDYW52YXNIZWlnaHQiLCJGZURyb3BTaGFkb3dFbGVtZW50IiwiX3dpZHRoIiwiRmVNb3JwaG9sb2d5RWxlbWVudCIsIkZlQ29tcG9zaXRlRWxlbWVudCIsIkZlR2F1c3NpYW5CbHVyRWxlbWVudCIsImJsdXJSYWRpdXMiLCJib2R5IiwiZ2V0VW5pcXVlSWQiLCJkaXNwbGF5IiwiYXBwZW5kQ2hpbGQiLCJyZW1vdmVDaGlsZCIsIlRpdGxlRWxlbWVudCIsIkRlc2NFbGVtZW50IiwiZWxlbWVudHMiLCJvd25LZXlzJDEiLCJfb2JqZWN0U3ByZWFkJDEiLCJfY3JlYXRlSW1hZ2UiLCJhbm9ueW1vdXNDcm9zc09yaWdpbiIsImNyb3NzT3JpZ2luIiwicmVqZWN0Iiwib25sb2FkIiwib25lcnJvciIsIl9ldmVudCIsIl9zb3VyY2UiLCJfbGluZW5vIiwiX2NvbG5vIiwiRG9jdW1lbnQiLCJlbVNpemVTdGFjayIsInVuaXF1ZUlkIiwiYmluZENyZWF0ZUltYWdlIiwiaXNJbWFnZXNMb2FkZWQiLCJpc0ZvbnRzTG9hZGVkIiwiZm9yY2VBbm9ueW1vdXNDcm9zc09yaWdpbiIsImNyZWF0ZURvY3VtZW50RWxlbWVudCIsImVsZW1lbnRUeXBlIiwiRWxlbWVudFR5cGUiLCJlbGVtZW50VHlwZXMiLCJjb25maWciLCJvd25LZXlzIiwiX29iamVjdFNwcmVhZCIsIkNhbnZnIiwib3B0aW9ucyIsIl9hcmd1bWVudHMiLCJmcm9tU3RyaW5nIiwiZm9yayIsIl9hcmd1bWVudHMyIiwiYmFzZU9wdGlvbnMiLCJkZWZhdWx0IiwicHJlc2V0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvg/lib/index.es.js\n");

/***/ })

};
;